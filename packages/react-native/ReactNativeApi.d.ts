/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @generated SignedSource<<777be5f40fbdeb1c2f6d5756eb6fa636>>
 *
 * This file was generated by scripts/build-types/index.js.
 */

// ----------------------------------------------------------------------------
// JavaScript API snapshot for react-native.
//
// This snapshot captures the public JavaScript API of React Native, based on
// types exported by packages/react-native/index.js.flow.
//
// Modifications to this file indicate changes to the shape of JavaScript
// values and types that can be imported from the react-native package.
// ----------------------------------------------------------------------------

import * as React from "react";
export declare type AccessibilityActionEvent = NativeSyntheticEvent<
  Readonly<{
    actionName: string;
  }>
>;
export declare const AccessibilityInfo: typeof AccessibilityInfo_2;
export declare type AccessibilityInfo = typeof AccessibilityInfo;
export declare type AccessibilityProps = Readonly<
  Omit<
    AccessibilityPropsAndroid,
    | keyof {
        accessibilityHint?: string | undefined;
        accessibilityLabel?: string | undefined;
        accessibilityRole?: AccessibilityRole | undefined;
        accessibilityState?: AccessibilityState | undefined;
        accessibilityValue?: AccessibilityValue | undefined;
        accessible?: boolean | undefined;
        "aria-label"?: string | undefined;
        experimental_accessibilityOrder?: Array<string> | undefined;
        role?: Role | undefined;
        "aria-valuemax"?: AccessibilityValue["max"] | undefined;
        "aria-valuemin"?: AccessibilityValue["min"] | undefined;
        "aria-valuenow"?: AccessibilityValue["now"] | undefined;
        "aria-valuetext"?: AccessibilityValue["text"] | undefined;
        accessibilityActions?:
          | ReadonlyArray<AccessibilityActionInfo>
          | undefined;
        "aria-busy"?: boolean | undefined;
        "aria-checked"?: "mixed" | (boolean | undefined);
        "aria-disabled"?: boolean | undefined;
        "aria-expanded"?: boolean | undefined;
        "aria-selected"?: boolean | undefined;
        "aria-hidden"?: boolean | undefined;
      }
    | keyof AccessibilityPropsIOS
  > &
    Omit<
      AccessibilityPropsIOS,
      keyof {
        accessibilityHint?: string | undefined;
        accessibilityLabel?: string | undefined;
        accessibilityRole?: AccessibilityRole | undefined;
        accessibilityState?: AccessibilityState | undefined;
        accessibilityValue?: AccessibilityValue | undefined;
        accessible?: boolean | undefined;
        "aria-label"?: string | undefined;
        experimental_accessibilityOrder?: Array<string> | undefined;
        role?: Role | undefined;
        "aria-valuemax"?: AccessibilityValue["max"] | undefined;
        "aria-valuemin"?: AccessibilityValue["min"] | undefined;
        "aria-valuenow"?: AccessibilityValue["now"] | undefined;
        "aria-valuetext"?: AccessibilityValue["text"] | undefined;
        accessibilityActions?:
          | ReadonlyArray<AccessibilityActionInfo>
          | undefined;
        "aria-busy"?: boolean | undefined;
        "aria-checked"?: "mixed" | (boolean | undefined);
        "aria-disabled"?: boolean | undefined;
        "aria-expanded"?: boolean | undefined;
        "aria-selected"?: boolean | undefined;
        "aria-hidden"?: boolean | undefined;
      }
    > & {
      accessibilityHint?: string | undefined;
      accessibilityLabel?: string | undefined;
      accessibilityRole?: AccessibilityRole | undefined;
      accessibilityState?: AccessibilityState | undefined;
      accessibilityValue?: AccessibilityValue | undefined;
      accessible?: boolean | undefined;
      "aria-label"?: string | undefined;
      experimental_accessibilityOrder?: Array<string> | undefined;
      role?: Role | undefined;
      "aria-valuemax"?: AccessibilityValue["max"] | undefined;
      "aria-valuemin"?: AccessibilityValue["min"] | undefined;
      "aria-valuenow"?: AccessibilityValue["now"] | undefined;
      "aria-valuetext"?: AccessibilityValue["text"] | undefined;
      accessibilityActions?: ReadonlyArray<AccessibilityActionInfo> | undefined;
      "aria-busy"?: boolean | undefined;
      "aria-checked"?: "mixed" | (boolean | undefined);
      "aria-disabled"?: boolean | undefined;
      "aria-expanded"?: boolean | undefined;
      "aria-selected"?: boolean | undefined;
      "aria-hidden"?: boolean | undefined;
    }
>;
export declare type AccessibilityRole =
  | "adjustable"
  | "alert"
  | "button"
  | "checkbox"
  | "combobox"
  | "drawerlayout"
  | "dropdownlist"
  | "grid"
  | "header"
  | "horizontalscrollview"
  | "iconmenu"
  | "image"
  | "imagebutton"
  | "keyboardkey"
  | "link"
  | "list"
  | "menu"
  | "menubar"
  | "menuitem"
  | "none"
  | "pager"
  | "progressbar"
  | "radio"
  | "radiogroup"
  | "scrollbar"
  | "scrollview"
  | "search"
  | "slidingdrawer"
  | "spinbutton"
  | "summary"
  | "switch"
  | "tab"
  | "tabbar"
  | "tablist"
  | "text"
  | "timer"
  | "togglebutton"
  | "toolbar"
  | "viewgroup"
  | "webview"
  | string;
export declare type AccessibilityState = {
  busy?: boolean | undefined;
  checked?: "mixed" | (boolean | undefined);
  disabled?: boolean | undefined;
  expanded?: boolean | undefined;
  selected?: boolean | undefined;
};
export declare type AccessibilityValue = Readonly<{
  max?: number;
  min?: number;
  now?: number;
  text?: string;
}>;
export declare const ActionSheetIOS: typeof ActionSheetIOS_2;
export declare type ActionSheetIOS = typeof ActionSheetIOS;
export declare type ActionSheetIOSOptions = Readonly<{
  anchor?: number | undefined;
  cancelButtonIndex?: number | undefined;
  cancelButtonTintColor?: ColorValue | ProcessedColorValue;
  destructiveButtonIndex?: (Array<number> | undefined) | (number | undefined);
  disabledButtonIndices?: Array<number>;
  disabledButtonTintColor?: ColorValue | ProcessedColorValue;
  message?: string | undefined;
  options: Array<string>;
  tintColor?: ColorValue | ProcessedColorValue;
  title?: string | undefined;
  userInterfaceStyle?: string;
}>;
export declare const ActivityIndicator: typeof ActivityIndicator_2;
export declare type ActivityIndicator = typeof ActivityIndicator;
export declare type ActivityIndicatorProps = Readonly<
  Omit<
    ViewProps,
    | keyof {
        animating?: boolean | undefined;
        color?: ColorValue | undefined;
        size?: IndicatorSize | undefined;
      }
    | keyof ActivityIndicatorIOSProps
  > &
    Omit<
      ActivityIndicatorIOSProps,
      keyof {
        animating?: boolean | undefined;
        color?: ColorValue | undefined;
        size?: IndicatorSize | undefined;
      }
    > & {
      animating?: boolean | undefined;
      color?: ColorValue | undefined;
      size?: IndicatorSize | undefined;
    }
>;
export declare class Alert {
  static alert(
    title: null | string | undefined,
    message?: null | string | undefined,
    buttons?: AlertButtons,
    options?: AlertOptions
  ): void;
  static prompt(
    title: null | string | undefined,
    message?: null | string | undefined,
    callbackOrButtons?:
      | (((text: string) => void) | AlertButtons)
      | null
      | undefined,
    type?: AlertType | null | undefined,
    defaultValue?: string,
    keyboardType?: string,
    options?: AlertOptions
  ): void;
}
export declare type AlertButton = {
  isPreferred?: boolean;
  onPress?: (((value?: string) => any) | undefined) | (Function | undefined);
  style?: AlertButtonStyle;
  text?: string;
};
export declare type AlertButtonStyle = "cancel" | "default" | "destructive";
export declare type AlertOptions = {
  cancelable?: boolean | undefined;
  onDismiss?: (() => void) | undefined;
  userInterfaceStyle?: "dark" | "light" | "unspecified";
};
export declare type AlertType =
  | "default"
  | "login-password"
  | "plain-text"
  | "secure-text";
export declare type AndroidKeyboardEvent = Readonly<
  Omit<
    BaseKeyboardEvent,
    keyof {
      duration: 0;
      easing: "keyboard";
    }
  > & {
    duration: 0;
    easing: "keyboard";
  }
>;
export declare namespace Animated {
  export {
    $$AnimatedFlatList as FlatList,
    $$AnimatedImage as Image,
    $$AnimatedScrollView as ScrollView,
    $$AnimatedSectionList as SectionList,
    $$AnimatedText as Text,
    $$AnimatedView as View,
    AnimatedColor as Color,
    AnimatedEvent as Event,
    AnimatedInterpolation as Interpolation,
    AnimatedNode as Node,
    AnimatedValue as Value,
    AnimatedValueXY as ValueXY,
    AnimatedInterpolation,
    AnimatedColor,
    AnimatedValueConfig as AnimatedConfig,
    AnimatedNode,
    AnimatedAddition,
    AnimatedDiffClamp,
    AnimatedDivision,
    AnimatedModulo,
    AnimatedMultiplication,
    AnimatedSubtraction,
    WithAnimatedValue,
    AnimatedProps,
    AnimatedComponentType as AnimatedComponent,
    add,
    attachNativeEvent_2 as attachNativeEvent,
    createAnimatedComponent_2 as createAnimatedComponent,
    decay_2 as decay,
    delay_2 as delay,
    diffClamp_2 as diffClamp,
    divide_2 as divide,
    event_2 as event,
    forkEvent_2 as forkEvent,
    loop_2 as loop,
    modulo_2 as modulo,
    multiply_2 as multiply,
    parallel_2 as parallel,
    sequence_2 as sequence,
    spring_2 as spring,
    stagger_2 as stagger,
    subtract_2 as subtract,
    timing_2 as timing,
    unforkEvent_2 as unforkEvent,
  };
}
export declare type AppConfig = {
  appKey: string;
  component?: ComponentProvider;
  run?: Runnable;
  section?: boolean;
};
export declare namespace Appearance {
  export {
    getColorScheme,
    setColorScheme,
    addChangeListener,
    AppearancePreferences,
  };
}
export declare namespace AppRegistry {
  export {
    setWrapperComponentProvider,
    setRootViewStyleProvider,
    registerConfig,
    registerComponent,
    registerRunnable,
    registerSection,
    getAppKeys,
    getSectionKeys,
    getSections,
    getRunnable,
    getRegistry,
    setComponentProviderInstrumentationHook,
    runApplication,
    setSurfaceProps,
    unmountApplicationComponentAtRootTag,
    registerHeadlessTask,
    registerCancellableHeadlessTask,
    startHeadlessTask,
    cancelHeadlessTask,
    TaskCanceller,
    TaskCancelProvider,
  };
}
export declare const AppState: typeof AppState_2;
export declare type AppState = typeof AppState;
export declare type AppStateEvent = keyof AppStateEventDefinitions;
export declare type AppStateStatus =
  | "active"
  | "background"
  | "extension"
  | "inactive"
  | "unknown";
export declare type AutoCapitalize =
  | "characters"
  | "none"
  | "sentences"
  | "words";
export declare const BackHandler: typeof BackHandler_2;
export declare type BackHandler = typeof BackHandler;
export declare type BackPressEventName = "backPress" | "hardwareBackPress";
export declare type BlurEvent = NativeSyntheticEvent<TargetedEvent>;
export declare type BoxShadowValue = {
  blurRadius?: number | string;
  color?: ____ColorValue_Internal;
  inset?: boolean;
  offsetX: number | string;
  offsetY: number | string;
  spreadDistance?: number | string;
};
export declare const Button: typeof Button_2;
export declare type Button = typeof Button;
export declare type ButtonProps = Readonly<{
  accessibilityActions?: ReadonlyArray<AccessibilityActionInfo> | undefined;
  accessibilityHint?: string | undefined;
  accessibilityLabel?: string | undefined;
  accessibilityLanguage?: string | undefined;
  accessibilityState?: AccessibilityState | undefined;
  accessible?: boolean | undefined;
  color?: ColorValue | undefined;
  disabled?: boolean | undefined;
  hasTVPreferredFocus?: boolean | undefined;
  importantForAccessibility?:
    | ("auto" | "no-hide-descendants" | "no" | "yes")
    | undefined;
  nextFocusDown?: number | undefined;
  nextFocusForward?: number | undefined;
  nextFocusLeft?: number | undefined;
  nextFocusRight?: number | undefined;
  nextFocusUp?: number | undefined;
  onAccessibilityAction?:
    | ((event: AccessibilityActionEvent) => unknown)
    | undefined;
  testID?: string | undefined;
  title: string;
  touchSoundDisabled?: boolean | undefined;
  "aria-label"?: string | undefined;
  "aria-busy"?: boolean | undefined;
  "aria-checked"?: "mixed" | (boolean | undefined);
  "aria-disabled"?: boolean | undefined;
  "aria-expanded"?: boolean | undefined;
  "aria-selected"?: boolean | undefined;
  onPress?: (event?: GestureResponderEvent) => unknown;
}>;
export declare const Clipboard: {
  getString(): Promise<string>;
  setString(content: string): void;
};
export declare type Clipboard = typeof Clipboard;
export declare const codegenNativeCommands: typeof codegenNativeCommands_2;
export declare type codegenNativeCommands = typeof codegenNativeCommands;
export declare const codegenNativeComponent: typeof codegenNativeComponent_2;
export declare type codegenNativeComponent = typeof codegenNativeComponent;
export { CodegenTypes };
export declare type ColorSchemeName = "dark" | "light" | "unspecified";
export declare type ColorValue = ____ColorValue_Internal;
export declare type ComponentProvider = () => React.ComponentType<any>;
export declare type ComponentProviderInstrumentationHook = (
  component_: ComponentProvider,
  scopedPerformanceLogger: IPerformanceLogger
) => React.ComponentType<any>;
export declare type CursorValue = "auto" | "pointer";
export declare const DeviceEventEmitter: IEventEmitter<RCTDeviceEventDefinitions>;
export declare type DeviceEventEmitter = typeof DeviceEventEmitter;
export declare const DeviceInfo: typeof $$NativeDeviceInfo;
export declare type DeviceInfo = typeof DeviceInfo;
export declare type DeviceInfoConstants = {
  readonly Dimensions: DimensionsPayload;
  readonly isIPhoneX_deprecated?: boolean;
};
export declare const DevMenu: typeof DevMenu_2;
export declare type DevMenu = typeof DevMenu;
export declare const DevSettings: typeof DevSettings_2;
export declare type DevSettings = typeof DevSettings;
export declare class Dimensions {
  static addEventListener(type: "change", handler: Function): EventSubscription;
  static get(dim: string): DisplayMetrics | DisplayMetricsAndroid;
  static set(dims: Readonly<DimensionsPayload>): void;
}
export declare type DimensionsPayload = {
  screen?: DisplayMetrics;
  screenPhysicalPixels?: DisplayMetricsAndroid;
  window?: DisplayMetrics;
  windowPhysicalPixels?: DisplayMetricsAndroid;
};
export declare type DimensionValue = "auto" | null | number | string;
export declare type DisplayMetrics = {
  fontScale: number;
  height: number;
  scale: number;
  width: number;
};
export declare type DisplayMetricsAndroid = {
  densityDpi: number;
  fontScale: number;
  height: number;
  scale: number;
  width: number;
};
export declare const DrawerLayoutAndroid: typeof DrawerLayoutAndroid_2;
export declare type DrawerLayoutAndroid = typeof DrawerLayoutAndroid;
export declare type DrawerLayoutAndroidProps = Readonly<
  Omit<
    ViewProps,
    keyof {
      drawerBackgroundColor?: ColorValue | undefined;
      drawerLockMode?:
        | ("locked-closed" | "locked-open" | "unlocked")
        | undefined;
      drawerPosition: ("left" | "right") | undefined;
      drawerWidth?: number | undefined;
      keyboardDismissMode?: ("none" | "on-drag") | undefined;
      onDrawerClose?: (() => unknown) | undefined;
      onDrawerOpen?: (() => unknown) | undefined;
      onDrawerSlide?: ((event: DrawerSlideEvent) => unknown) | undefined;
      onDrawerStateChanged?: ((state: DrawerStates) => unknown) | undefined;
      statusBarBackgroundColor?: ColorValue | undefined;
      renderNavigationView: () => React.JSX.Element;
    }
  > & {
    drawerBackgroundColor?: ColorValue | undefined;
    drawerLockMode?: ("locked-closed" | "locked-open" | "unlocked") | undefined;
    drawerPosition: ("left" | "right") | undefined;
    drawerWidth?: number | undefined;
    keyboardDismissMode?: ("none" | "on-drag") | undefined;
    onDrawerClose?: (() => unknown) | undefined;
    onDrawerOpen?: (() => unknown) | undefined;
    onDrawerSlide?: ((event: DrawerSlideEvent) => unknown) | undefined;
    onDrawerStateChanged?: ((state: DrawerStates) => unknown) | undefined;
    statusBarBackgroundColor?: ColorValue | undefined;
    renderNavigationView: () => React.JSX.Element;
  }
>;
export declare type DrawerSlideEvent = NativeSyntheticEvent<
  Readonly<{
    offset: number;
  }>
>;
export declare type DropShadowValue = {
  color?: ____ColorValue_Internal;
  offsetX: number | string;
  offsetY: number | string;
  standardDeviation?: number | string;
};
export declare const DynamicColorIOS: (
  tuple: DynamicColorIOSTuple
) => ColorValue;
export declare type DynamicColorIOS = typeof DynamicColorIOS;
export declare type DynamicColorIOSTuple = {
  dark: ColorValue;
  highContrastDark?: ColorValue;
  highContrastLight?: ColorValue;
  light: ColorValue;
};
export declare const Easing: typeof EasingStatic;
export declare type Easing = typeof Easing;
export declare type EasingFunction = (t: number) => number;
export declare type EdgeInsetsValue = {
  bottom: number;
  left: number;
  right: number;
  top: number;
};
export declare type EmitterSubscription = EventSubscription;
export declare type EnterKeyHintTypeOptions =
  | EnterKeyHintType
  | EnterKeyHintTypeAndroid
  | EnterKeyHintTypeIOS;
export declare type ErrorUtils = {
  applyWithGuard<TArgs extends ReadonlyArray<unknown>, TOut>(
    fun: Fn<TArgs, TOut>,
    context?: unknown,
    args?: TArgs | undefined,
    unused_onError?: null,
    unused_name?: string | undefined
  ): TOut | undefined;
  applyWithGuardIfNeeded<TArgs extends ReadonlyArray<unknown>, TOut>(
    fun: Fn<TArgs, TOut>,
    context?: unknown,
    args?: TArgs | undefined
  ): TOut | undefined;
  getGlobalHandler(): ErrorHandler;
  guard<TArgs extends ReadonlyArray<unknown>, TOut>(
    fun: Fn<TArgs, TOut>,
    name?: string | undefined,
    context?: unknown
  ): ((...$$REST$$: TArgs) => TOut | undefined) | undefined;
  inGuard(): boolean;
  reportError(error: unknown): void;
  reportFatalError(error: unknown): void;
  setGlobalHandler(fun: ErrorHandler): void;
};
export declare interface EventSubscription {
  remove(): void;
}
export declare const experimental_LayoutConformance: (
  props: LayoutConformanceProps
) => React.ReactNode;
export declare type experimental_LayoutConformance =
  typeof experimental_LayoutConformance;
export declare type ExtendedExceptionData = ExceptionData & {
  isComponentError: boolean;
};
export declare type FilterFunction =
  | {
      blur: number | string;
    }
  | {
      brightness: number | string;
    }
  | {
      contrast: number | string;
    }
  | {
      dropShadow: DropShadowValue | string;
    }
  | {
      grayscale: number | string;
    }
  | {
      hueRotate: number | string;
    }
  | {
      invert: number | string;
    }
  | {
      opacity: number | string;
    }
  | {
      saturate: number | string;
    }
  | {
      sepia: number | string;
    };
export declare function findNodeHandle<TElementType extends React.ElementType>(
  componentOrHandle:
    | (number | React.ComponentRef<TElementType>)
    | null
    | undefined
): null | number | undefined;
export declare class FlatList<ItemT = any> extends React.PureComponent<
  FlatListProps<ItemT>
> {
  componentDidUpdate(prevProps: FlatListProps<ItemT>): void;
  constructor(props: FlatListProps<ItemT>);
  flashScrollIndicators(): void;
  getNativeScrollRef():
    | (null | React.ComponentRef<ScrollViewNativeComponent> | undefined)
    | (null | React.ComponentRef<typeof View> | undefined);
  getScrollableNode(): any;
  getScrollResponder(): null | ScrollResponderType | undefined;
  recordInteraction(): void;
  render(): React.ReactNode;
  scrollToEnd(
    params?:
      | null
      | undefined
      | {
          animated?: boolean | undefined;
        }
  ): void;
  scrollToIndex(params: {
    animated?: boolean | undefined;
    index: number;
    viewOffset?: number;
    viewPosition?: number;
  }): void;
  scrollToItem(params: {
    animated?: boolean | undefined;
    item: ItemT;
    viewOffset?: number;
    viewPosition?: number;
  }): void;
  scrollToOffset(params: {
    animated?: boolean | undefined;
    offset: number;
  }): void;
  setNativeProps(props: { [$$Key$$: string]: unknown }): void;
}
export declare type FlatListProps<ItemT> = Omit<
  Omit<
    VirtualizedListProps_2,
    | "data"
    | "getItem"
    | "getItemCount"
    | "getItemLayout"
    | "keyExtractor"
    | "renderItem"
  >,
  keyof {} | keyof FlatListBaseProps<ItemT>
> &
  Omit<FlatListBaseProps<ItemT>, keyof {}> & {};
export declare type FocusEvent = NativeSyntheticEvent<TargetedEvent>;
export declare type FontVariant = ____FontVariant_Internal;
export declare type GestureResponderEvent =
  ResponderSyntheticEvent<NativeTouchEvent>;
export declare type GestureResponderHandlers = Readonly<{
  onMoveShouldSetResponder?:
    | ((e: GestureResponderEvent) => boolean)
    | undefined;
  onMoveShouldSetResponderCapture?:
    | ((e: GestureResponderEvent) => boolean)
    | undefined;
  onResponderEnd?: ((e: GestureResponderEvent) => void) | undefined;
  onResponderGrant?: ((e: GestureResponderEvent) => boolean | void) | undefined;
  onResponderMove?: ((e: GestureResponderEvent) => void) | undefined;
  onResponderReject?: ((e: GestureResponderEvent) => void) | undefined;
  onResponderRelease?: ((e: GestureResponderEvent) => void) | undefined;
  onResponderStart?: ((e: GestureResponderEvent) => void) | undefined;
  onResponderTerminate?: ((e: GestureResponderEvent) => void) | undefined;
  onResponderTerminationRequest?:
    | ((e: GestureResponderEvent) => boolean)
    | undefined;
  onStartShouldSetResponder?:
    | ((e: GestureResponderEvent) => boolean)
    | undefined;
  onStartShouldSetResponderCapture?:
    | ((e: GestureResponderEvent) => boolean)
    | undefined;
}>;
export declare type Handle = number;
export declare type HostComponent<Config extends {}> = (
  props: Omit<
    Config,
    keyof {
      ref?: React.Ref<HostInstance>;
    }
  > & {
    ref?: React.Ref<HostInstance>;
  }
) => React.ReactNode;
export declare type HostInstance = LegacyHostInstanceMethods;
export declare const I18nManager: {
  doLeftAndRightSwapInRTL: I18nManagerConstants["doLeftAndRightSwapInRTL"];
  isRTL: I18nManagerConstants["isRTL"];
  allowRTL: (shouldAllow: boolean) => void;
  forceRTL: (shouldForce: boolean) => void;
  getConstants: () => I18nManagerConstants;
  swapLeftAndRightInRTL: (flipStyles: boolean) => void;
};
export declare type I18nManager = typeof I18nManager;
export declare type IgnorePattern = RegExp | string;
export declare const Image: ImageType;
export declare type Image = typeof Image;
export declare class ImageBackground extends React.Component<ImageBackgroundProps> {
  render(): React.ReactNode;
  setNativeProps(props: {}): void;
}
export declare type ImageBackgroundProps = Readonly<
  Omit<
    ImageProps,
    keyof {
      children?: React.ReactNode;
      imageRef?: React.Ref<React.ComponentRef<ImageType>>;
      imageStyle?: ImageStyleProp | undefined;
      style?: undefined | ViewStyleProp;
    }
  > & {
    children?: React.ReactNode;
    imageRef?: React.Ref<React.ComponentRef<ImageType>>;
    imageStyle?: ImageStyleProp | undefined;
    style?: undefined | ViewStyleProp;
  }
>;
export declare type ImageErrorEvent = NativeSyntheticEvent<
  Readonly<ImageErrorEventData>
>;
export declare type ImageLoadEvent = NativeSyntheticEvent<
  Readonly<ImageLoadEventData>
>;
export declare type ImageProgressEventIOS = NativeSyntheticEvent<
  Readonly<ImageProgressEventDataIOS>
>;
export declare type ImageProps = Readonly<
  Omit<
    ImagePropsIOS,
    | keyof {
        style?: ImageStyleProp | undefined;
      }
    | keyof ImagePropsAndroid
    | keyof ImagePropsBase
  > &
    Omit<
      ImagePropsAndroid,
      | keyof {
          style?: ImageStyleProp | undefined;
        }
      | keyof ImagePropsBase
    > &
    Omit<
      ImagePropsBase,
      keyof {
        style?: ImageStyleProp | undefined;
      }
    > & {
      style?: ImageStyleProp | undefined;
    }
>;
export declare type ImagePropsAndroid = Readonly<{
  fadeDuration?: number | undefined;
  loadingIndicatorSource?: (number | Readonly<ImageURISource>) | undefined;
  progressiveRenderingEnabled?: boolean | undefined;
  resizeMethod?: ("auto" | "none" | "resize" | "scale") | undefined;
  resizeMultiplier?: number | undefined;
}>;
export declare type ImagePropsBase = Readonly<
  Omit<
    Omit<ViewProps, "style">,
    keyof {
      accessibilityLabel?: string | undefined;
      accessible?: boolean | undefined;
      alt?: string | undefined;
      blurRadius?: number | undefined;
      children?: never;
      crossOrigin?: ("anonymous" | "use-credentials") | undefined;
      internal_analyticTag?: string | undefined;
      "aria-label"?: string | undefined;
      "aria-labelledby"?: string | undefined;
      capInsets?: EdgeInsetsProp | undefined;
      height?: number;
      onError?: ((event: ImageErrorEvent) => void) | undefined;
      onLayout?: ((event: LayoutChangeEvent) => unknown) | undefined;
      onLoad?: ((event: ImageLoadEvent) => void) | undefined;
      onLoadEnd?: (() => void) | undefined;
      onLoadStart?: (() => void) | undefined;
      referrerPolicy?:
        | (
            | "no-referrer-when-downgrade"
            | "no-referrer"
            | "origin-when-cross-origin"
            | "origin"
            | "same-origin"
            | "strict-origin-when-cross-origin"
            | "strict-origin"
            | "unsafe-url"
          )
        | undefined;
      resizeMode?: ImageResizeMode | undefined;
      source?: ImageSource | undefined;
      src?: string | undefined;
      srcSet?: string | undefined;
      testID?: string | undefined;
      tintColor?: ColorValue;
      width?: number;
    }
  > & {
    accessibilityLabel?: string | undefined;
    accessible?: boolean | undefined;
    alt?: string | undefined;
    blurRadius?: number | undefined;
    children?: never;
    crossOrigin?: ("anonymous" | "use-credentials") | undefined;
    internal_analyticTag?: string | undefined;
    "aria-label"?: string | undefined;
    "aria-labelledby"?: string | undefined;
    capInsets?: EdgeInsetsProp | undefined;
    height?: number;
    onError?: ((event: ImageErrorEvent) => void) | undefined;
    onLayout?: ((event: LayoutChangeEvent) => unknown) | undefined;
    onLoad?: ((event: ImageLoadEvent) => void) | undefined;
    onLoadEnd?: (() => void) | undefined;
    onLoadStart?: (() => void) | undefined;
    referrerPolicy?:
      | (
          | "no-referrer-when-downgrade"
          | "no-referrer"
          | "origin-when-cross-origin"
          | "origin"
          | "same-origin"
          | "strict-origin-when-cross-origin"
          | "strict-origin"
          | "unsafe-url"
        )
      | undefined;
    resizeMode?: ImageResizeMode | undefined;
    source?: ImageSource | undefined;
    src?: string | undefined;
    srcSet?: string | undefined;
    testID?: string | undefined;
    tintColor?: ColorValue;
    width?: number;
  }
>;
export declare type ImagePropsIOS = Readonly<{
  defaultSource?: ImageSource | undefined;
  onPartialLoad?: (() => void) | undefined;
  onProgress?: ((event: ImageProgressEventIOS) => void) | undefined;
}>;
export declare type ImageRequireSource = number;
export declare type ImageResolvedAssetSource = ResolvedAssetSource;
export declare type ImageSize = {
  height: number;
  width: number;
};
export declare type ImageSource =
  | ImageRequireSource
  | ImageURISource
  | ReadonlyArray<ImageURISource>;
export declare type ImageSourcePropType = ImageSource;
export declare type ImageStyle = ____ImageStyle_Internal;
export declare interface ImageURISource {
  readonly body?: string | undefined;
  readonly bundle?: string | undefined;
  readonly cache?:
    | ("default" | "force-cache" | "only-if-cached" | "reload")
    | undefined;
  readonly headers?:
    | undefined
    | {
        [$$Key$$: string]: string;
      };
  readonly height?: number | undefined;
  readonly method?: string | undefined;
  readonly scale?: number | undefined;
  readonly uri?: string | undefined;
  readonly width?: number | undefined;
}
export declare const InputAccessoryView: typeof InputAccessoryView_2;
export declare type InputAccessoryView = typeof InputAccessoryView;
export declare type InputAccessoryViewProps = Readonly<{
  backgroundColor?: ColorValue | undefined;
  readonly children: React.ReactNode;
  nativeID?: string | undefined;
  style?: undefined | ViewStyleProp;
}>;
export declare type InputModeOptions =
  | "decimal"
  | "email"
  | "none"
  | "numeric"
  | "search"
  | "tel"
  | "text"
  | "url";
export declare type Insets = Rect;
export declare const InteractionManager: typeof InteractionManager_2;
export declare type InteractionManager = typeof InteractionManager;
export declare type IOSKeyboardEvent = Readonly<
  Omit<
    BaseKeyboardEvent,
    keyof {
      isEventFromThisApp: boolean;
      startCoordinates: KeyboardMetrics;
    }
  > & {
    isEventFromThisApp: boolean;
    startCoordinates: KeyboardMetrics;
  }
>;
export declare const Keyboard: typeof Keyboard_2;
export declare type Keyboard = typeof Keyboard;
export declare class KeyboardAvoidingView extends React.Component<
  KeyboardAvoidingViewProps,
  KeyboardAvoidingViewState
> {
  viewRef: {
    current: null | React.ComponentRef<typeof View>;
  };
  componentDidMount(): void;
  componentDidUpdate(
    _: KeyboardAvoidingViewProps,
    prevState: KeyboardAvoidingViewState
  ): void;
  componentWillUnmount(): void;
  constructor(props: KeyboardAvoidingViewProps);
  render(): React.ReactNode;
}
export declare type KeyboardAvoidingViewProps = Readonly<
  Omit<
    ViewProps,
    keyof {
      behavior?: ("height" | "padding" | "position") | undefined;
      contentContainerStyle?: undefined | ViewStyleProp;
      enabled?: boolean | undefined;
      keyboardVerticalOffset?: number;
    }
  > & {
    behavior?: ("height" | "padding" | "position") | undefined;
    contentContainerStyle?: undefined | ViewStyleProp;
    enabled?: boolean | undefined;
    keyboardVerticalOffset?: number;
  }
>;
export declare type KeyboardEvent = AndroidKeyboardEvent | IOSKeyboardEvent;
export declare type KeyboardEventEasing =
  | "easeIn"
  | "easeInEaseOut"
  | "easeOut"
  | "keyboard"
  | "linear";
export declare type KeyboardEventName = keyof KeyboardEventDefinitions;
export declare type KeyboardMetrics = Readonly<{
  height: number;
  screenX: number;
  screenY: number;
  width: number;
}>;
export declare type KeyboardTypeOptions =
  | KeyboardType
  | KeyboardTypeAndroid
  | KeyboardTypeIOS;
export declare const LayoutAnimation: typeof LayoutAnimation_2;
export declare type LayoutAnimation = typeof LayoutAnimation;
export declare type LayoutAnimationAnim = Readonly<{
  delay?: number;
  duration?: number;
  initialVelocity?: number;
  property?: LayoutAnimationProperty;
  springDamping?: number;
  type?: LayoutAnimationType;
}>;
export declare type LayoutAnimationConfig = LayoutAnimationConfig_2;
export declare type LayoutAnimationProperties = Readonly<{
  [prop in LayoutAnimationProperty]: prop;
}>;
export declare type LayoutAnimationProperty =
  | "opacity"
  | "scaleX"
  | "scaleXY"
  | "scaleY";
export declare type LayoutAnimationType =
  | "easeIn"
  | "easeInEaseOut"
  | "easeOut"
  | "keyboard"
  | "linear"
  | "spring";
export declare type LayoutAnimationTypes = Readonly<{
  [type in LayoutAnimationType]: type;
}>;
export declare type LayoutChangeEvent = NativeSyntheticEvent<
  Readonly<{
    layout: LayoutRectangle;
  }>
>;
export declare type LayoutConformanceProps = Readonly<{
  children: React.ReactNode;
  mode: "compatibility" | "strict";
}>;
export declare type LayoutRectangle = Readonly<{
  height: number;
  width: number;
  x: number;
  y: number;
}>;
export declare const Linking: typeof Linking_2;
export declare type Linking = typeof Linking;
export declare type ListRenderItem<ItemT> = (
  info: ListRenderItemInfo<ItemT>
) => React.ReactNode;
export declare type ListRenderItemInfo<ItemT> = {
  index: number;
  item: ItemT;
  separators: Separators;
};
export declare const LogBox: ILogBox;
export declare type LogBox = typeof LogBox;
export declare type LogData = Readonly<{
  category: Category;
  componentStack: ComponentStack;
  componentStackType: ComponentStackType | null;
  level: LogLevel;
  message: Message;
  stack?: string;
}>;
export declare type MeasureInWindowOnSuccessCallback = (
  x: number,
  y: number,
  width: number,
  height: number
) => void;
export declare type MeasureLayoutOnSuccessCallback = (
  left: number,
  top: number,
  width: number,
  height: number
) => void;
export declare type MeasureOnSuccessCallback = (
  x: number,
  y: number,
  width: number,
  height: number,
  pageX: number,
  pageY: number
) => void;
export declare const Modal: typeof Wrapper;
export declare type Modal = typeof Modal;
export declare type ModalBaseProps = {
  animated?: boolean;
  animationType?: ("fade" | "none" | "slide") | undefined;
  backdropColor?: ColorValue;
  modalRef?: React.Ref<PublicModalInstance>;
  onRequestClose?: DirectEventHandler<null> | undefined;
  onShow?: DirectEventHandler<null> | undefined;
  transparent?: boolean | undefined;
  visible?: boolean | undefined;
};
export declare type ModalProps = Omit<
  ModalBaseProps,
  keyof {} | keyof ModalPropsAndroid | keyof ModalPropsIOS | keyof ViewProps
> &
  Omit<ModalPropsIOS, keyof {} | keyof ModalPropsAndroid | keyof ViewProps> &
  Omit<ModalPropsAndroid, keyof {} | keyof ViewProps> &
  Omit<ViewProps, keyof {}> & {};
export declare type ModalPropsAndroid = {
  hardwareAccelerated?: boolean | undefined;
  navigationBarTranslucent?: boolean | undefined;
  statusBarTranslucent?: boolean | undefined;
};
export declare type ModalPropsIOS = {
  onDismiss?: (() => void) | undefined;
  onOrientationChange?: DirectEventHandler<OrientationChangeEvent> | undefined;
  presentationStyle?:
    | ("formSheet" | "fullScreen" | "overFullScreen" | "pageSheet")
    | undefined;
  supportedOrientations?:
    | ReadonlyArray<
        | "landscape-left"
        | "landscape-right"
        | "landscape"
        | "portrait-upside-down"
        | "portrait"
      >
    | undefined;
};
export declare type MouseEvent = NativeSyntheticEvent<
  Readonly<{
    clientX: number;
    clientY: number;
    pageX: number;
    pageY: number;
    timestamp: number;
  }>
>;
export declare const NativeAppEventEmitter: typeof RCTNativeAppEventEmitter;
export declare type NativeAppEventEmitter = typeof NativeAppEventEmitter;
export declare type NativeColorValue = symbol & {
  __NativeColorValue__: string;
};
export declare const NativeDialogManagerAndroid: typeof $$NativeDialogManagerAndroid;
export declare type NativeDialogManagerAndroid =
  typeof NativeDialogManagerAndroid;
export declare class NativeEventEmitter<
  TEventToArgsMap extends Readonly<
    Record<string, ReadonlyArray<UnsafeObject_2>>
  > = Readonly<Record<string, ReadonlyArray<UnsafeObject_2>>>
> implements IEventEmitter<TEventToArgsMap>
{
  addListener<TEvent extends keyof TEventToArgsMap>(
    eventType: TEvent,
    listener: (...args: TEventToArgsMap[TEvent]) => unknown,
    context?: unknown
  ): EventSubscription;
  constructor(nativeModule?: NativeModule | null | undefined);
  emit<TEvent extends keyof TEventToArgsMap>(
    eventType: TEvent,
    ...args: TEventToArgsMap[TEvent]
  ): void;
  listenerCount<TEvent extends keyof TEventToArgsMap>(
    eventType: TEvent
  ): number;
  removeAllListeners<TEvent extends keyof TEventToArgsMap>(
    eventType?: null | TEvent | undefined
  ): void;
}
export declare type NativeEventSubscription = EventSubscription;
export declare type NativeMethods = LegacyHostInstanceMethods;
export declare type NativeMethodsMixin = LegacyHostInstanceMethods;
export declare const NativeModules: typeof NativeModules_2;
export declare type NativeModules = typeof NativeModules;
export declare interface NativeMouseEvent extends NativeUIEvent {
  readonly altKey: boolean;
  readonly button: number;
  readonly buttons: number;
  readonly clientX: number;
  readonly clientY: number;
  readonly ctrlKey: boolean;
  readonly metaKey: boolean;
  readonly offsetX: number;
  readonly offsetY: number;
  readonly pageX: number;
  readonly pageY: number;
  readonly relatedTarget: HostInstance | null | number;
  readonly screenX: number;
  readonly screenY: number;
  readonly shiftKey: boolean;
  readonly x: number;
  readonly y: number;
}
export declare interface NativePointerEvent extends NativeMouseEvent {
  readonly height: number;
  readonly isPrimary: boolean;
  readonly pointerId: number;
  readonly pointerType: string;
  readonly pressure: number;
  readonly tangentialPressure: number;
  readonly tiltX: number;
  readonly tiltY: number;
  readonly twist: number;
  readonly width: number;
}
export declare type NativeScrollEvent = Readonly<{
  contentInset: NativeScrollRectangle;
  contentOffset: NativeScrollPoint;
  contentSize: NativeScrollSize;
  layoutMeasurement: NativeScrollSize;
  responderIgnoreScroll?: boolean;
  targetContentOffset?: NativeScrollPoint;
  velocity?: NativeScrollVelocity;
  zoomScale?: number;
}>;
export declare type NativeSyntheticEvent<T> = Readonly<{
  bubbles: boolean | undefined;
  cancelable: boolean | undefined;
  currentTarget: HostInstance | number;
  defaultPrevented: boolean | undefined;
  dispatchConfig: Readonly<{
    registrationName: string;
  }>;
  eventPhase: number | undefined;
  isTrusted: boolean | undefined;
  nativeEvent: T;
  target: (number | undefined) | HostInstance;
  timeStamp: number;
  type: string | undefined;
  isDefaultPrevented: () => boolean;
  isPropagationStopped: () => boolean;
  persist: () => void;
  preventDefault: () => void;
  stopPropagation: () => void;
}>;
export declare type NativeTouchEvent = Readonly<{
  changedTouches: ReadonlyArray<NativeTouchEvent>;
  force?: number;
  identifier: number;
  locationX: number;
  locationY: number;
  pageX: number;
  pageY: number;
  target: number | undefined;
  timestamp: number;
  touches: ReadonlyArray<NativeTouchEvent>;
}>;
export declare interface NativeUIEvent {
  readonly detail: number;
}
export declare const Networking: typeof RCTNetworking;
export declare type Networking = typeof Networking;
export declare type OpaqueColorValue = NativeColorValue;
export declare const PanResponder: typeof PanResponder_2;
export declare type PanResponder = typeof PanResponder;
export declare type PanResponderCallbacks = Readonly<{
  onMoveShouldSetPanResponder?: ActiveCallback | undefined;
  onMoveShouldSetPanResponderCapture?: ActiveCallback | undefined;
  onPanResponderEnd?: PassiveCallback | undefined;
  onPanResponderGrant?: (ActiveCallback | PassiveCallback) | undefined;
  onPanResponderMove?: PassiveCallback | undefined;
  onPanResponderReject?: PassiveCallback | undefined;
  onPanResponderRelease?: PassiveCallback | undefined;
  onPanResponderStart?: PassiveCallback | undefined;
  onPanResponderTerminate?: PassiveCallback | undefined;
  onPanResponderTerminationRequest?: ActiveCallback | undefined;
  onShouldBlockNativeResponder?: ActiveCallback | undefined;
  onStartShouldSetPanResponder?: ActiveCallback | undefined;
  onStartShouldSetPanResponderCapture?: ActiveCallback | undefined;
}>;
export declare type PanResponderGestureState = {
  dx: number;
  dy: number;
  moveX: number;
  moveY: number;
  numberActiveTouches: number;
  stateID: number;
  vx: number;
  vy: number;
  x0: number;
  y0: number;
};
export declare type PanResponderInstance = ReturnType<
  (typeof PanResponder_2)["create"]
>;
export declare type Permission = PermissionsType[keyof PermissionsType];
export declare const PermissionsAndroid: typeof PermissionsAndroidInstance;
export declare type PermissionsAndroid = typeof PermissionsAndroid;
export declare type PermissionStatus = "denied" | "granted" | "never_ask_again";
export declare class PixelRatio {
  static get(): number;
  static getFontScale(): number;
  static getPixelSizeForLayoutSize(layoutSize: number): number;
  static roundToNearestPixel(layoutSize: number): number;
  static startDetecting(): void;
}
export declare const Platform: Platform_2;
export declare type Platform = typeof Platform;
export declare function PlatformColor(...names: Array<string>): ColorValue;
export declare type PlatformOSType =
  | "android"
  | "ios"
  | "macos"
  | "native"
  | "web"
  | "windows";
export declare type PlatformSelectSpec<T> =
  | (Omit<
      OptionalPlatformSelectSpec<T>,
      keyof {
        default: T;
      }
    > & {
      default: T;
    })
  | OptionalPlatformSelectSpec<T>;
export declare type PointerEvent = NativeSyntheticEvent<NativePointerEvent>;
export declare type PointValue = {
  x: number;
  y: number;
};
export declare const Pressable: (
  props: Omit<
    PressableProps,
    keyof {
      ref?: React.Ref<React.ComponentRef<typeof View>>;
    }
  > & {
    ref?: React.Ref<React.ComponentRef<typeof View>>;
  }
) => React.ReactNode;
export declare type Pressable = typeof Pressable;
export declare type PressableAndroidRippleConfig = {
  borderless?: boolean;
  color?: ColorValue;
  foreground?: boolean;
  radius?: number;
};
export declare type PressableProps = Readonly<
  Omit<
    Omit<ViewProps, "onMouseEnter" | "onMouseLeave">,
    keyof {} | keyof PressableBaseProps
  > &
    Omit<PressableBaseProps, keyof {}> & {}
>;
export declare type PressableStateCallbackType = Readonly<{
  pressed: boolean;
}>;
export declare const processColor: typeof processColor_2;
export declare type processColor = typeof processColor;
export declare type ProcessedColorValue = NativeColorValue | number;
export declare const ProgressBarAndroid: typeof ProgressBarAndroid_2;
export declare type ProgressBarAndroid = typeof ProgressBarAndroid;
export declare type ProgressBarAndroidProps =
  | Readonly<
      Omit<
        ViewProps,
        | keyof {}
        | keyof DeterminateProgressBarAndroidStyleAttrProp
        | keyof ProgressBarAndroidBaseProps
      > &
        Omit<
          ProgressBarAndroidBaseProps,
          keyof {} | keyof DeterminateProgressBarAndroidStyleAttrProp
        > &
        Omit<DeterminateProgressBarAndroidStyleAttrProp, keyof {}> & {}
    >
  | Readonly<
      Omit<
        ViewProps,
        | keyof {}
        | keyof IndeterminateProgressBarAndroidStyleAttrProp
        | keyof ProgressBarAndroidBaseProps
      > &
        Omit<
          ProgressBarAndroidBaseProps,
          keyof {} | keyof IndeterminateProgressBarAndroidStyleAttrProp
        > &
        Omit<IndeterminateProgressBarAndroidStyleAttrProp, keyof {}> & {}
    >;
export declare type PromiseTask = {
  name: string;
  gen: () => Promise<void>;
};
export declare type PublicRootInstance = symbol & {
  __PublicRootInstance__: string;
};
export declare type PublicTextInstance = ReturnType<createPublicTextInstance>;
export declare type PushNotificationEventName = keyof {
  localNotification: string;
  notification: string;
  register: string;
  registrationError: string;
};
export declare class PushNotificationIOS {
  static FetchResult: FetchResult;
  static abandonPermissions(): void;
  static addEventListener(
    type: PushNotificationEventName,
    handler: Function
  ): void;
  static cancelAllLocalNotifications(): void;
  static cancelLocalNotifications(userInfo: Object): void;
  static checkPermissions(
    callback: (permissions: PushNotificationPermissions) => void
  ): void;
  constructor(nativeNotif: Object);
  finish(fetchResult: string): void;
  getAlert(): (null | Object | undefined) | (null | string | undefined);
  static getApplicationIconBadgeNumber(callback: Function): void;
  static getAuthorizationStatus(
    callback: (authorizationStatus: number) => void
  ): void;
  getBadgeCount(): null | number | undefined;
  getCategory(): null | string | undefined;
  getContentAvailable(): ContentAvailable;
  getData(): null | Object | undefined;
  static getDeliveredNotifications(
    callback: (notifications: Array<Object>) => void
  ): void;
  static getInitialNotification(): Promise<null | PushNotification | undefined>;
  getMessage(): (null | Object | undefined) | (null | string | undefined);
  static getScheduledLocalNotifications(callback: Function): void;
  getSound(): null | string | undefined;
  getThreadID(): null | string | undefined;
  static presentLocalNotification(
    details: PresentLocalNotificationDetails
  ): void;
  static removeAllDeliveredNotifications(): void;
  static removeDeliveredNotifications(identifiers: Array<string>): void;
  static removeEventListener(type: PushNotificationEventName): void;
  static requestPermissions(
    permissions?: PushNotificationPermissions
  ): Promise<{
    alert: boolean;
    badge: boolean;
    sound: boolean;
  }>;
  static scheduleLocalNotification(
    details: ScheduleLocalNotificationDetails
  ): void;
  static setApplicationIconBadgeNumber(number: number): void;
}
export declare type PushNotificationPermissions = {
  [key: string]: boolean | number;
  alert: boolean;
  badge: boolean;
  sound: boolean;
};
export declare type Rationale = {
  buttonNegative?: string;
  buttonNeutral?: string;
  buttonPositive?: string;
  message: string;
  title: string;
};
export declare class RefreshControl extends React.Component<RefreshControlProps> {
  componentDidMount(): void;
  componentDidUpdate(prevProps: RefreshControlProps): void;
  render(): React.ReactNode;
}
export declare type RefreshControlProps = Readonly<
  Omit<
    ViewProps,
    | keyof {}
    | keyof RefreshControlBaseProps
    | keyof RefreshControlPropsAndroid
    | keyof RefreshControlPropsIOS
  > &
    Omit<
      RefreshControlPropsIOS,
      | keyof {}
      | keyof RefreshControlBaseProps
      | keyof RefreshControlPropsAndroid
    > &
    Omit<RefreshControlPropsAndroid, keyof {} | keyof RefreshControlBaseProps> &
    Omit<RefreshControlBaseProps, keyof {}> & {}
>;
export declare type RefreshControlPropsAndroid = Readonly<{
  colors?: ReadonlyArray<ColorValue> | undefined;
  enabled?: boolean | undefined;
  progressBackgroundColor?: ColorValue | undefined;
  size?: ("default" | "large") | undefined;
}>;
export declare type RefreshControlPropsIOS = Readonly<{
  tintColor?: ColorValue | undefined;
  title?: string | undefined;
  titleColor?: ColorValue | undefined;
}>;
export declare const registerCallableModule: typeof registerCallableModule_2;
export declare type registerCallableModule = typeof registerCallableModule;
export declare type Registry = {
  runnables: Runnables;
  sections: ReadonlyArray<string>;
};
export declare const requireNativeComponent: typeof requireNativeComponent_2;
export declare type requireNativeComponent = typeof requireNativeComponent;
export declare type ResponderSyntheticEvent<T> = Readonly<
  Omit<
    NativeSyntheticEvent<T>,
    keyof {
      touchHistory: Readonly<{
        indexOfSingleActiveTouch: number;
        mostRecentTimeStamp: number;
        numberActiveTouches: number;
        touchBank: ReadonlyArray<
          Readonly<{
            currentPageX: number;
            currentPageY: number;
            currentTimeStamp: number;
            previousPageX: number;
            previousPageY: number;
            previousTimeStamp: number;
            startPageX: number;
            startPageY: number;
            startTimeStamp: number;
            touchActive: boolean;
          }>
        >;
      }>;
    }
  > & {
    touchHistory: Readonly<{
      indexOfSingleActiveTouch: number;
      mostRecentTimeStamp: number;
      numberActiveTouches: number;
      touchBank: ReadonlyArray<
        Readonly<{
          currentPageX: number;
          currentPageY: number;
          currentTimeStamp: number;
          previousPageX: number;
          previousPageY: number;
          previousTimeStamp: number;
          startPageX: number;
          startPageY: number;
          startTimeStamp: number;
          touchActive: boolean;
        }>
      >;
    }>;
  }
>;
export declare type ReturnKeyTypeOptions =
  | ReturnKeyType
  | ReturnKeyTypeAndroid
  | ReturnKeyTypeIOS;
export declare type Role =
  | "alert"
  | "alertdialog"
  | "application"
  | "article"
  | "banner"
  | "button"
  | "cell"
  | "checkbox"
  | "columnheader"
  | "combobox"
  | "complementary"
  | "contentinfo"
  | "definition"
  | "dialog"
  | "directory"
  | "document"
  | "feed"
  | "figure"
  | "form"
  | "grid"
  | "group"
  | "heading"
  | "img"
  | "link"
  | "list"
  | "listitem"
  | "log"
  | "main"
  | "marquee"
  | "math"
  | "menu"
  | "menubar"
  | "menuitem"
  | "meter"
  | "navigation"
  | "none"
  | "note"
  | "option"
  | "presentation"
  | "progressbar"
  | "radio"
  | "radiogroup"
  | "region"
  | "row"
  | "rowgroup"
  | "rowheader"
  | "scrollbar"
  | "searchbox"
  | "separator"
  | "slider"
  | "spinbutton"
  | "status"
  | "summary"
  | "switch"
  | "tab"
  | "table"
  | "tablist"
  | "tabpanel"
  | "term"
  | "timer"
  | "toolbar"
  | "tooltip"
  | "tree"
  | "treegrid"
  | "treeitem";
export declare type RootTag = symbol & {
  __RootTag__: string;
};
export declare const RootTagContext: React.Context<RootTag>;
export declare type RootTagContext = typeof RootTagContext;
export declare type RootViewStyleProvider = (
  appParameters: Object
) => ViewStyleProp;
export declare type Runnable = (
  appParameters: AppParameters,
  displayMode: DisplayModeType
) => void;
export declare type Runnables = {
  [appKey: string]: Runnable;
};
export declare const SafeAreaView: typeof exported;
export declare type SafeAreaView = typeof SafeAreaView;
export declare type ScaledSize = DisplayMetrics;
export declare type ScrollEvent = NativeSyntheticEvent<NativeScrollEvent>;
export declare type ScrollResponderType = ScrollViewImperativeMethods;
export declare type ScrollToLocationParamsType = {
  animated?: boolean | undefined;
  itemIndex: number;
  sectionIndex: number;
  viewOffset?: number;
  viewPosition?: number;
};
export declare const ScrollView: typeof ScrollViewWrapper &
  ScrollViewComponentStatics;
export declare type ScrollView = typeof ScrollView;
export declare type ScrollViewProps = Readonly<
  Omit<
    ViewProps,
    | keyof {}
    | keyof ScrollViewBaseProps
    | keyof ScrollViewPropsAndroid
    | keyof ScrollViewPropsIOS
  > &
    Omit<
      ScrollViewPropsIOS,
      keyof {} | keyof ScrollViewBaseProps | keyof ScrollViewPropsAndroid
    > &
    Omit<ScrollViewPropsAndroid, keyof {} | keyof ScrollViewBaseProps> &
    Omit<ScrollViewBaseProps, keyof {}> & {}
>;
export declare type ScrollViewPropsAndroid = Readonly<{
  endFillColor?: ColorValue | undefined;
  fadingEdgeLength?:
    | (number | undefined)
    | {
        end: number;
        start: number;
      };
  nestedScrollEnabled?: boolean | undefined;
  overScrollMode?: ("always" | "auto" | "never") | undefined;
  persistentScrollbar?: boolean | undefined;
  scrollPerfTag?: string | undefined;
}>;
export declare type ScrollViewPropsIOS = Readonly<{
  alwaysBounceHorizontal?: boolean | undefined;
  alwaysBounceVertical?: boolean | undefined;
  automaticallyAdjustContentInsets?: boolean | undefined;
  automaticallyAdjustKeyboardInsets?: boolean | undefined;
  automaticallyAdjustsScrollIndicatorInsets?: boolean | undefined;
  bounces?: boolean | undefined;
  bouncesZoom?: boolean | undefined;
  canCancelContentTouches?: boolean | undefined;
  centerContent?: boolean | undefined;
  contentInset?: EdgeInsetsProp | undefined;
  contentInsetAdjustmentBehavior?:
    | ("always" | "automatic" | "never" | "scrollableAxes")
    | undefined;
  directionalLockEnabled?: boolean | undefined;
  disableScrollViewPanResponder?: boolean | undefined;
  indicatorStyle?: ("black" | "default" | "white") | undefined;
  maximumZoomScale?: number | undefined;
  minimumZoomScale?: number | undefined;
  pinchGestureEnabled?: boolean | undefined;
  scrollIndicatorInsets?: EdgeInsetsProp | undefined;
  scrollsToTop?: boolean | undefined;
  scrollToOverflowEnabled?: boolean | undefined;
  showsHorizontalScrollIndicator?: boolean | undefined;
  zoomScale?: number | undefined;
  onScrollToTop?: (event: ScrollEvent) => void;
}>;
export declare type SectionBase<SectionItemT, SectionT = DefaultSectionT> = {
  data: ReadonlyArray<SectionItemT>;
  ItemSeparatorComponent?: React.ComponentType<any> | undefined;
  key?: string;
  renderItem?:
    | ((info: {
        index: number;
        item: SectionItemT;
        section: SectionListData<SectionItemT, SectionT>;
        separators: {
          highlight: () => void;
          unhighlight: () => void;
          updateProps: (
            select: "leading" | "trailing",
            newProps: Object
          ) => void;
        };
      }) => null | React.JSX.Element)
    | undefined;
  keyExtractor?: (
    item: SectionItemT | undefined,
    index?: number | undefined
  ) => string;
};
export declare class SectionList<
  ItemT = any,
  SectionT = DefaultSectionT_2
> extends React.PureComponent<SectionListProps<ItemT, SectionT>> {
  props: SectionListProps<ItemT, SectionT>;
  flashScrollIndicators(): void;
  getScrollableNode(): any;
  getScrollResponder(): null | ScrollResponderType | undefined;
  recordInteraction(): void;
  render(): React.ReactNode;
  scrollToLocation(params: ScrollToLocationParamsType): void;
  setNativeProps(props: Object): void;
}
export declare type SectionListData<SectionItemT, SectionT = DefaultSectionT> =
  | (Readonly<SectionBase<SectionItemT, SectionT>> & SectionT)
  | (SectionBase<SectionItemT, SectionT> & SectionT)
  | SectionT;
export declare type SectionListProps<
  ItemT,
  SectionT = DefaultSectionT_2
> = Omit<
  Omit<
    VirtualizedSectionListProps<ItemT, SectionT>,
    "getItem" | "getItemCount" | "keyExtractor" | "renderItem"
  >,
  | keyof {}
  | keyof OptionalProps_4<ItemT, SectionT>
  | keyof RequiredProps_4<ItemT, SectionT>
> &
  Omit<
    RequiredProps_4<ItemT, SectionT>,
    keyof {} | keyof OptionalProps_4<ItemT, SectionT>
  > &
  Omit<OptionalProps_4<ItemT, SectionT>, keyof {}> & {};
export declare type SectionListRenderItem<
  ItemT,
  SectionT = DefaultSectionT_2
> = (
  info: SectionListRenderItemInfo<ItemT, SectionT>
) => null | React.ReactNode;
export declare type SectionListRenderItemInfo<
  ItemT,
  SectionT = DefaultSectionT_2
> = Omit<
  ListRenderItemInfo<ItemT>,
  keyof {
    section: SectionListData<ItemT, SectionT>;
  }
> & {
  section: SectionListData<ItemT, SectionT>;
};
export declare type Separators = {
  highlight: () => void;
  unhighlight: () => void;
  updateProps: (select: "leading" | "trailing", newProps: Object) => void;
};
export declare const Settings: typeof Settings_2;
export declare type Settings = typeof Settings;
export declare class Share {
  static dismissedAction: "dismissedAction";
  static sharedAction: "sharedAction";
  static share(
    content: ShareContent,
    options?: ShareOptions
  ): Promise<{
    action: string;
    activityType: string | undefined;
  }>;
}
export declare type ShareAction = {
  action: "dismissedAction" | "sharedAction";
  activityType?: null | string;
};
export declare type ShareActionSheetError = Readonly<{
  code: string;
  domain: string;
  message: string;
  userInfo?: Object | undefined;
}>;
export declare type ShareActionSheetIOSOptions = Readonly<{
  anchor?: number | undefined;
  cancelButtonTintColor?: number | undefined;
  disabledButtonTintColor?: number | undefined;
  excludedActivityTypes?: Array<string> | undefined;
  message?: string | undefined;
  subject?: string | undefined;
  tintColor?: number | undefined;
  url?: string | undefined;
  userInterfaceStyle?: string | undefined;
}>;
export declare type ShareContent =
  | {
      message?: string;
      title?: string;
      url: string;
    }
  | {
      message: string;
      title?: string;
      url?: string;
    };
export declare type ShareOptions = {
  anchor?: number;
  dialogTitle?: string;
  excludedActivityTypes?: Array<string>;
  subject?: string;
  tintColor?: ColorValue;
};
export declare type SimpleTask = {
  name: string;
  run: () => void;
};
export declare class StatusBar extends React.Component<StatusBarProps> {
  static currentHeight: null | number | undefined;
  componentDidMount(): void;
  componentDidUpdate(): void;
  componentWillUnmount(): void;
  static popStackEntry(entry: StackProps): void;
  static pushStackEntry(props: StatusBarProps): StackProps;
  render(): React.ReactNode;
  static replaceStackEntry(
    entry: StackProps,
    props: StatusBarProps
  ): StackProps;
  static setBackgroundColor(color: ColorValue, animated?: boolean): void;
  static setBarStyle(style: StatusBarStyle, animated?: boolean): void;
  static setHidden(hidden: boolean, animation?: StatusBarAnimation): void;
  static setNetworkActivityIndicatorVisible(visible: boolean): void;
  static setTranslucent(translucent: boolean): void;
}
export declare type StatusBarAnimation = keyof {
  fade: string;
  none: string;
  slide: string;
};
export declare type StatusBarProps = Readonly<
  Omit<
    StatusBarPropsAndroid,
    keyof {} | keyof StatusBarBaseProps | keyof StatusBarPropsIOS
  > &
    Omit<StatusBarPropsIOS, keyof {} | keyof StatusBarBaseProps> &
    Omit<StatusBarBaseProps, keyof {}> & {}
>;
export declare type StatusBarStyle = keyof {
  default: string;
  "light-content": string;
  "dark-content": string;
};
export declare type StyleProp<T> =
  | ""
  | false
  | null
  | ReadonlyArray<StyleProp<T>>
  | T
  | void;
export declare namespace StyleSheet {
  export {
    hairlineWidth,
    absoluteFill,
    absoluteFillObject,
    compose,
    flatten,
    setStyleAttributePreprocessor,
    create_2 as create,
  };
}
export declare type SubmitBehavior = "blurAndSubmit" | "newline" | "submit";
export declare const Switch: typeof Switch_2;
export declare type Switch = typeof Switch;
export declare type SwitchChangeEvent =
  NativeSyntheticEvent<SwitchChangeEventData>;
export declare type SwitchProps = Readonly<
  Omit<ViewProps, keyof {} | keyof SwitchPropsBase | keyof SwitchPropsIOS> &
    Omit<SwitchPropsIOS, keyof {} | keyof SwitchPropsBase> &
    Omit<SwitchPropsBase, keyof {}> & {}
>;
export declare namespace Systrace {
  export {
    isEnabled,
    setEnabled_2 as setEnabled,
    beginEvent,
    endEvent,
    beginAsyncEvent,
    endAsyncEvent,
    counterEvent,
    EventName,
    EventArgs,
  };
}
export declare type TargetedEvent = Readonly<{
  target: number;
}>;
export declare type TaskProvider = () => Task;
export declare const Text: typeof TextImpl;
export declare type Text = typeof Text;
export declare type TextContentType =
  | "addressCity"
  | "addressCityAndState"
  | "addressState"
  | "birthdate"
  | "birthdateDay"
  | "birthdateMonth"
  | "birthdateYear"
  | "cellularEID"
  | "cellularIMEI"
  | "countryName"
  | "creditCardExpiration"
  | "creditCardExpirationMonth"
  | "creditCardExpirationYear"
  | "creditCardFamilyName"
  | "creditCardGivenName"
  | "creditCardMiddleName"
  | "creditCardName"
  | "creditCardNumber"
  | "creditCardSecurityCode"
  | "creditCardType"
  | "dateTime"
  | "emailAddress"
  | "familyName"
  | "flightNumber"
  | "fullStreetAddress"
  | "givenName"
  | "jobTitle"
  | "location"
  | "middleName"
  | "name"
  | "namePrefix"
  | "nameSuffix"
  | "newPassword"
  | "nickname"
  | "none"
  | "oneTimeCode"
  | "organizationName"
  | "password"
  | "postalCode"
  | "shipmentTrackingNumber"
  | "streetAddressLine1"
  | "streetAddressLine2"
  | "sublocality"
  | "telephoneNumber"
  | "URL"
  | "username";
export declare const TextInput: TextInputType;
export declare type TextInput = typeof TextInput;
export declare type TextInputAndroidProps = Readonly<{
  cursorColor?: ColorValue | undefined;
  disableFullscreenUI?: boolean | undefined;
  importantForAutofill?:
    | ("auto" | "no" | "noExcludeDescendants" | "yes" | "yesExcludeDescendants")
    | undefined;
  inlineImageLeft?: string | undefined;
  inlineImagePadding?: number | undefined;
  numberOfLines?: number | undefined;
  returnKeyLabel?: string | undefined;
  rows?: number | undefined;
  selectionHandleColor?: ColorValue | undefined;
  showSoftInputOnFocus?: boolean | undefined;
  textBreakStrategy?: ("balanced" | "highQuality" | "simple") | undefined;
  underlineColorAndroid?: ColorValue | undefined;
}>;
export declare type TextInputChangeEvent =
  NativeSyntheticEvent<TextInputChangeEventData>;
export declare type TextInputContentSizeChangeEvent =
  NativeSyntheticEvent<TextInputContentSizeChangeEventData>;
export declare type TextInputEndEditingEvent =
  NativeSyntheticEvent<TextInputEndEditingEventData>;
export declare type TextInputFocusEvent = FocusEvent;
export declare type TextInputIOSProps = Readonly<{
  clearButtonMode?:
    | ("always" | "never" | "unless-editing" | "while-editing")
    | undefined;
  clearTextOnFocus?: boolean | undefined;
  dataDetectorTypes?:
    | (DataDetectorTypesType | undefined)
    | ReadonlyArray<DataDetectorTypesType>;
  disableKeyboardShortcuts?: boolean | undefined;
  enablesReturnKeyAutomatically?: boolean | undefined;
  inputAccessoryViewButtonLabel?: string | undefined;
  inputAccessoryViewID?: string | undefined;
  keyboardAppearance?: ("dark" | "default" | "light") | undefined;
  lineBreakModeIOS?:
    | ("char" | "clip" | "head" | "middle" | "tail" | "wordWrapping")
    | undefined;
  lineBreakStrategyIOS?:
    | ("hangul-word" | "none" | "push-out" | "standard")
    | undefined;
  passwordRules?: PasswordRules | undefined;
  rejectResponderTermination?: boolean | undefined;
  scrollEnabled?: boolean | undefined;
  smartInsertDelete?: boolean | undefined;
  spellCheck?: boolean | undefined;
  textContentType?: TextContentType | undefined;
}>;
export declare type TextInputKeyPressEvent =
  NativeSyntheticEvent<TextInputKeyPressEventData>;
export declare type TextInputProps = Readonly<
  Omit<
    Omit<ViewProps, "style">,
    | keyof {}
    | keyof TextInputAndroidProps
    | keyof TextInputBaseProps
    | keyof TextInputIOSProps
  > &
    Omit<
      TextInputIOSProps,
      keyof {} | keyof TextInputAndroidProps | keyof TextInputBaseProps
    > &
    Omit<TextInputAndroidProps, keyof {} | keyof TextInputBaseProps> &
    Omit<TextInputBaseProps, keyof {}> & {}
>;
export declare type TextInputSelectionChangeEvent =
  NativeSyntheticEvent<TextInputSelectionChangeEventData>;
export declare type TextInputSubmitEditingEvent =
  NativeSyntheticEvent<TextInputSubmitEditingEventData>;
export declare type TextLayoutEvent = NativeSyntheticEvent<TextLayoutEventData>;
export declare type TextProps = Readonly<
  Omit<
    PointerEventProps_2,
    | keyof {}
    | keyof AccessibilityProps
    | keyof TextBaseProps
    | keyof TextPropsAndroid
    | keyof TextPropsIOS
  > &
    Omit<
      TextPropsIOS,
      | keyof {}
      | keyof AccessibilityProps
      | keyof TextBaseProps
      | keyof TextPropsAndroid
    > &
    Omit<
      TextPropsAndroid,
      keyof {} | keyof AccessibilityProps | keyof TextBaseProps
    > &
    Omit<TextBaseProps, keyof {} | keyof AccessibilityProps> &
    Omit<AccessibilityProps, keyof {}> & {}
>;
export declare type TextStyle = ____TextStyle_Internal;
export declare const ToastAndroid: typeof ToastAndroid_2;
export declare type ToastAndroid = typeof ToastAndroid;
export declare const Touchable: typeof TouchableImpl;
export declare type Touchable = typeof Touchable;
export declare const TouchableHighlight: typeof TouchableHighlight_2;
export declare type TouchableHighlight = typeof TouchableHighlight;
export declare type TouchableHighlightProps = Readonly<
  Omit<
    TouchableWithoutFeedbackProps,
    | keyof {}
    | keyof AndroidProps
    | keyof IOSProps
    | keyof TouchableHighlightBaseProps
  > &
    Omit<
      AndroidProps,
      keyof {} | keyof IOSProps | keyof TouchableHighlightBaseProps
    > &
    Omit<IOSProps, keyof {} | keyof TouchableHighlightBaseProps> &
    Omit<TouchableHighlightBaseProps, keyof {}> & {}
>;
export declare class TouchableNativeFeedback extends React.Component<
  TouchableNativeFeedbackProps,
  TouchableNativeFeedbackState
> {
  state: TouchableNativeFeedbackState;
  static canUseNativeForeground: () => boolean;
  static Ripple: (
    color: string,
    borderless: boolean,
    rippleRadius?: null | number | undefined
  ) => Readonly<{
    borderless: boolean;
    color: number | undefined;
    rippleRadius: number | undefined;
    type: "RippleAndroid";
  }>;
  static SelectableBackground: (
    rippleRadius?: null | number | undefined
  ) => Readonly<{
    attribute: "selectableItemBackground";
    rippleRadius: number | undefined;
    type: "ThemeAttrAndroid";
  }>;
  static SelectableBackgroundBorderless: (
    rippleRadius?: null | number | undefined
  ) => Readonly<{
    attribute: "selectableItemBackgroundBorderless";
    rippleRadius: number | undefined;
    type: "ThemeAttrAndroid";
  }>;
  componentDidMount(): unknown;
  componentDidUpdate(
    prevProps: TouchableNativeFeedbackProps,
    prevState: TouchableNativeFeedbackState
  ): void;
  componentWillUnmount(): void;
  render(): React.ReactNode;
}
export declare type TouchableNativeFeedbackProps = Readonly<
  Omit<
    TouchableWithoutFeedbackProps,
    | keyof {
        background?:
          | (
              | Readonly<{
                  borderless: boolean;
                  color: number | undefined;
                  rippleRadius: number | undefined;
                  type: "RippleAndroid";
                }>
              | Readonly<{
                  attribute:
                    | "selectableItemBackground"
                    | "selectableItemBackgroundBorderless";
                  rippleRadius: number | undefined;
                  type: "ThemeAttrAndroid";
                }>
            )
          | undefined;
        useForeground?: boolean | undefined;
      }
    | keyof TVProps
  > &
    Omit<
      TVProps,
      keyof {
        background?:
          | (
              | Readonly<{
                  borderless: boolean;
                  color: number | undefined;
                  rippleRadius: number | undefined;
                  type: "RippleAndroid";
                }>
              | Readonly<{
                  attribute:
                    | "selectableItemBackground"
                    | "selectableItemBackgroundBorderless";
                  rippleRadius: number | undefined;
                  type: "ThemeAttrAndroid";
                }>
            )
          | undefined;
        useForeground?: boolean | undefined;
      }
    > & {
      background?:
        | (
            | Readonly<{
                borderless: boolean;
                color: number | undefined;
                rippleRadius: number | undefined;
                type: "RippleAndroid";
              }>
            | Readonly<{
                attribute:
                  | "selectableItemBackground"
                  | "selectableItemBackgroundBorderless";
                rippleRadius: number | undefined;
                type: "ThemeAttrAndroid";
              }>
          )
        | undefined;
      useForeground?: boolean | undefined;
    }
>;
export declare const TouchableOpacity: typeof Touchable_3;
export declare type TouchableOpacity = typeof TouchableOpacity;
export declare type TouchableOpacityProps = Readonly<
  Omit<
    TouchableWithoutFeedbackProps,
    keyof {} | keyof TouchableOpacityBaseProps | keyof TVProps_2
  > &
    Omit<TVProps_2, keyof {} | keyof TouchableOpacityBaseProps> &
    Omit<TouchableOpacityBaseProps, keyof {}> & {}
>;
export declare function TouchableWithoutFeedback(
  props: TouchableWithoutFeedbackProps
): React.ReactNode;
export declare type TouchableWithoutFeedbackProps = Readonly<
  {
    children?: React.ReactNode | undefined;
    delayLongPress?: number | undefined;
    delayPressIn?: number | undefined;
    delayPressOut?: number | undefined;
    disabled?: boolean | undefined;
    focusable?: boolean | undefined;
    hitSlop?: EdgeInsetsOrSizeProp | undefined;
    id?: string;
    importantForAccessibility?:
      | ("auto" | "no-hide-descendants" | "no" | "yes")
      | undefined;
    nativeID?: string | undefined;
    onAccessibilityAction?:
      | ((event: AccessibilityActionEvent) => unknown)
      | undefined;
    onBlur?: ((event: BlurEvent) => unknown) | undefined;
    onFocus?: ((event: FocusEvent) => unknown) | undefined;
    onLayout?: ((event: LayoutChangeEvent) => unknown) | undefined;
    onLongPress?: ((event: GestureResponderEvent) => unknown) | undefined;
    onPress?: ((event: GestureResponderEvent) => unknown) | undefined;
    onPressIn?: ((event: GestureResponderEvent) => unknown) | undefined;
    onPressOut?: ((event: GestureResponderEvent) => unknown) | undefined;
    pressRetentionOffset?: EdgeInsetsOrSizeProp | undefined;
    rejectResponderTermination?: boolean | undefined;
    style?: undefined | ViewStyleProp;
    testID?: string | undefined;
  } & TouchableWithoutFeedbackPropsAndroid &
    TouchableWithoutFeedbackPropsIOS &
    AccessibilityProps
>;
export declare type TransformsStyle = ____TransformStyle_Internal;
export declare interface TurboModule extends DEPRECATED_RCTExport<void> {}
export declare namespace TurboModuleRegistry {
  export { get, getEnforcing };
}
export declare type TVViewPropsIOS = Readonly<{
  hasTVPreferredFocus?: boolean;
  isTVSelectable?: boolean;
  tvParallaxMagnification?: number;
  tvParallaxShiftDistanceX?: number;
  tvParallaxShiftDistanceY?: number;
  tvParallaxTiltAngle?: number;
}>;
export declare const UIManager: typeof UIManager_2;
export declare type UIManager = typeof UIManager;
export declare function unstable_batchedUpdates<T>(
  fn: ($$PARAM_0$$: T) => void,
  bookkeeping: T
): void;
export declare function useAnimatedValue(
  initialValue: number,
  config?: Animated.AnimatedConfig | null | undefined
): Animated.Value;
export declare function useColorScheme(): ColorSchemeName | null | undefined;
export declare function useWindowDimensions():
  | DisplayMetrics
  | DisplayMetricsAndroid;
export declare const UTFSequence: typeof UTFSequence_2;
export declare type UTFSequence = typeof UTFSequence;
export declare const Vibration: typeof Vibration_2;
export declare type Vibration = typeof Vibration;
export declare const View: (
  props: Omit<
    ViewProps,
    keyof {
      ref?: React.Ref<React.ComponentRef<typeof $$ViewNativeComponent>>;
    }
  > & {
    ref?: React.Ref<React.ComponentRef<typeof $$ViewNativeComponent>>;
  }
) => React.ReactNode;
export declare type View = typeof View;
export declare type ViewProps = Readonly<
  Omit<
    DirectEventProps,
    | keyof {}
    | keyof AccessibilityProps
    | keyof FocusEventProps
    | keyof GestureResponderHandlers
    | keyof MouseEventProps
    | keyof PointerEventProps
    | keyof TouchEventProps
    | keyof ViewBaseProps
    | keyof ViewPropsAndroid
    | keyof ViewPropsIOS
  > &
    Omit<
      GestureResponderHandlers,
      | keyof {}
      | keyof AccessibilityProps
      | keyof FocusEventProps
      | keyof MouseEventProps
      | keyof PointerEventProps
      | keyof TouchEventProps
      | keyof ViewBaseProps
      | keyof ViewPropsAndroid
      | keyof ViewPropsIOS
    > &
    Omit<
      MouseEventProps,
      | keyof {}
      | keyof AccessibilityProps
      | keyof FocusEventProps
      | keyof PointerEventProps
      | keyof TouchEventProps
      | keyof ViewBaseProps
      | keyof ViewPropsAndroid
      | keyof ViewPropsIOS
    > &
    Omit<
      PointerEventProps,
      | keyof {}
      | keyof AccessibilityProps
      | keyof FocusEventProps
      | keyof TouchEventProps
      | keyof ViewBaseProps
      | keyof ViewPropsAndroid
      | keyof ViewPropsIOS
    > &
    Omit<
      FocusEventProps,
      | keyof {}
      | keyof AccessibilityProps
      | keyof TouchEventProps
      | keyof ViewBaseProps
      | keyof ViewPropsAndroid
      | keyof ViewPropsIOS
    > &
    Omit<
      TouchEventProps,
      | keyof {}
      | keyof AccessibilityProps
      | keyof ViewBaseProps
      | keyof ViewPropsAndroid
      | keyof ViewPropsIOS
    > &
    Omit<
      ViewPropsAndroid,
      | keyof {}
      | keyof AccessibilityProps
      | keyof ViewBaseProps
      | keyof ViewPropsIOS
    > &
    Omit<
      ViewPropsIOS,
      keyof {} | keyof AccessibilityProps | keyof ViewBaseProps
    > &
    Omit<AccessibilityProps, keyof {} | keyof ViewBaseProps> &
    Omit<ViewBaseProps, keyof {}> & {}
>;
export declare type ViewPropsAndroid = Readonly<{
  focusable?: boolean | undefined;
  hasTVPreferredFocus?: boolean | undefined;
  nativeBackgroundAndroid?: AndroidDrawable | undefined;
  nativeForegroundAndroid?: AndroidDrawable | undefined;
  nextFocusDown?: number | undefined;
  nextFocusForward?: number | undefined;
  nextFocusLeft?: number | undefined;
  nextFocusRight?: number | undefined;
  nextFocusUp?: number | undefined;
  onClick?: ((event: GestureResponderEvent) => unknown) | undefined;
  renderToHardwareTextureAndroid?: boolean | undefined;
  tabIndex?: -1 | 0;
}>;
export declare type ViewPropsIOS = Readonly<{
  shouldRasterizeIOS?: boolean | undefined;
}>;
export declare type ViewStyle = ____ViewStyle_Internal;
export declare const VirtualizedList: typeof VirtualizedList_6;
export declare type VirtualizedList = typeof VirtualizedList;
export declare type VirtualizedListProps = Omit<
  ScrollViewProps,
  keyof {} | keyof OptionalProps | keyof RequiredProps
> &
  Omit<RequiredProps, keyof {} | keyof OptionalProps> &
  Omit<OptionalProps, keyof {}> & {};
export declare const VirtualizedSectionList: typeof VirtualizedSectionList_2;
export declare type VirtualizedSectionList = typeof VirtualizedSectionList;
export declare type VirtualizedSectionListProps<
  ItemT,
  SectionT = DefaultSectionT
> = Omit<
  RequiredProps_2<ItemT, SectionT>,
  | keyof {}
  | keyof Omit<VirtualizedListProps, "data" | "renderItem">
  | keyof OptionalProps_2<ItemT, SectionT>
> &
  Omit<
    OptionalProps_2<ItemT, SectionT>,
    keyof {} | keyof Omit<VirtualizedListProps, "data" | "renderItem">
  > &
  Omit<Omit<VirtualizedListProps, "data" | "renderItem">, keyof {}> & {};
export declare type WrapperComponentProvider = (
  appParameters: Object
) => React.ComponentType<any>;
export {};
declare const $$AndroidSwitchNativeComponent: NativeType;
declare type $$AndroidSwitchNativeComponent =
  typeof $$AndroidSwitchNativeComponent;
declare const $$AnimatedFlatList: <ItemT = any>(
  props: Omit<
    AnimatedProps<FlatListProps<ItemT>>,
    keyof {
      ref?: React.Ref<FlatList<ItemT>>;
    }
  > & {
    ref?: React.Ref<FlatList<ItemT>>;
  }
) => React.ReactNode;
declare type $$AnimatedFlatList = typeof $$AnimatedFlatList;
declare const $$AnimatedImage: AnimatedComponentType<
  React.JSX.LibraryManagedAttributes<
    typeof Image,
    React.ComponentProps<typeof Image>
  >,
  React.ComponentRef<typeof Image>
>;
declare type $$AnimatedImage = typeof $$AnimatedImage;
declare const $$AnimatedImplementation: {
  add: typeof add_2;
  attachNativeEvent: typeof attachNativeEvent;
  Color: typeof AnimatedColor;
  createAnimatedComponent: typeof createAnimatedComponent;
  decay: typeof decay;
  delay: typeof delay;
  diffClamp: typeof diffClamp;
  divide: typeof divide;
  event: typeof event;
  Event: typeof AnimatedEvent;
  forkEvent: typeof forkEvent;
  Interpolation: typeof AnimatedInterpolation;
  loop: typeof loop;
  modulo: typeof modulo;
  multiply: typeof multiply;
  Node: typeof AnimatedNode;
  parallel: typeof parallel;
  sequence: typeof sequence;
  spring: typeof spring;
  stagger: typeof stagger;
  subtract: typeof subtract;
  timing: typeof timing;
  unforkEvent: typeof unforkEvent;
  Value: typeof AnimatedValue;
  ValueXY: typeof AnimatedValueXY;
};
declare type $$AnimatedImplementation = typeof $$AnimatedImplementation;
declare const $$AnimatedScrollView: typeof AnimatedScrollView;
declare type $$AnimatedScrollView = typeof $$AnimatedScrollView;
declare const $$AnimatedSectionList: <ItemT = any, SectionT = any>(
  props: Omit<
    AnimatedProps<SectionListProps<ItemT, SectionT>>,
    keyof {
      ref?: React.Ref<SectionList<ItemT, SectionT>>;
    }
  > & {
    ref?: React.Ref<SectionList<ItemT, SectionT>>;
  }
) => React.ReactNode;
declare type $$AnimatedSectionList = typeof $$AnimatedSectionList;
declare const $$AnimatedText: AnimatedComponentType<
  React.JSX.LibraryManagedAttributes<
    typeof Text,
    React.ComponentProps<typeof Text>
  >,
  React.ComponentRef<typeof Text>
>;
declare type $$AnimatedText = typeof $$AnimatedText;
declare const $$AnimatedView: AnimatedComponentType<
  React.JSX.LibraryManagedAttributes<
    typeof View,
    React.ComponentProps<typeof View>
  >,
  React.ComponentRef<typeof View>
>;
declare type $$AnimatedView = typeof $$AnimatedView;
declare const $$flattenStyle: typeof flattenStyle;
declare type $$flattenStyle = typeof $$flattenStyle;
declare const $$ImageViewNativeComponent: typeof ImageViewNativeComponent_default;
declare type $$ImageViewNativeComponent = typeof $$ImageViewNativeComponent;
declare const $$index: {
  keyExtractor: typeof keyExtractor;
  get FillRateHelper(): FillRateHelper;
  get ViewabilityHelper(): ViewabilityHelper;
  get VirtualizedList(): VirtualizedList_3;
  get VirtualizedListContextResetter(): VirtualizedListContextResetter;
  get VirtualizedSectionList(): AnyVirtualizedSectionList;
};
declare type $$index = typeof $$index;
declare const $$NativeDeviceInfo: typeof $$NativeDeviceInfo_2;
declare type $$NativeDeviceInfo = typeof $$NativeDeviceInfo;
declare const $$NativeDeviceInfo_2: typeof NativeDeviceInfo;
declare type $$NativeDeviceInfo_2 = typeof $$NativeDeviceInfo_2;
declare const $$NativeDialogManagerAndroid: null | Spec | undefined;
declare type $$NativeDialogManagerAndroid = typeof $$NativeDialogManagerAndroid;
declare const $$ProgressBarAndroidNativeComponent: HostComponent<NativeProps_2>;
declare type $$ProgressBarAndroidNativeComponent =
  typeof $$ProgressBarAndroidNativeComponent;
declare const $$ScrollViewContext: typeof ScrollViewContext;
declare type $$ScrollViewContext = typeof $$ScrollViewContext;
declare const $$ScrollViewNativeComponent: typeof ScrollViewNativeComponent_default;
declare type $$ScrollViewNativeComponent = typeof $$ScrollViewNativeComponent;
declare const $$SwitchNativeComponent: ComponentType;
declare type $$SwitchNativeComponent = typeof $$SwitchNativeComponent;
declare const $$TextInlineImageNativeComponent: typeof TextInlineImage;
declare type $$TextInlineImageNativeComponent =
  typeof $$TextInlineImageNativeComponent;
declare const $$ViewNativeComponent: typeof ViewNativeComponent;
declare type $$ViewNativeComponent = typeof $$ViewNativeComponent;
declare type ____BlendMode_Internal =
  | "color-burn"
  | "color-dodge"
  | "color"
  | "darken"
  | "difference"
  | "exclusion"
  | "hard-light"
  | "hue"
  | "lighten"
  | "luminosity"
  | "multiply"
  | "normal"
  | "overlay"
  | "saturation"
  | "screen"
  | "soft-light";
declare type ____ColorValue_Internal =
  | NativeColorValue
  | null
  | number
  | string;
declare type ____DangerouslyImpreciseAnimatedStyleProp_Internal =
  WithAnimatedValue<StyleProp<Partial<____DangerouslyImpreciseStyle_Internal>>>;
declare type ____DangerouslyImpreciseStyle_Internal = Readonly<
  Omit<
    ____DangerouslyImpreciseStyle_InternalCore,
    keyof ____DangerouslyImpreciseStyle_InternalOverrides | keyof {}
  > &
    Omit<____DangerouslyImpreciseStyle_InternalOverrides, keyof {}> & {}
>;
declare type ____DangerouslyImpreciseStyle_InternalCore = Readonly<
  Omit<
    ____TextStyle_Internal,
    keyof {
      objectFit?: "contain" | "cover" | "fill" | "none" | "scale-down";
      overlayColor?: ColorValue;
      resizeMode?: ImageResizeMode;
      tintColor?: ____ColorValue_Internal;
    }
  > & {
    objectFit?: "contain" | "cover" | "fill" | "none" | "scale-down";
    overlayColor?: ColorValue;
    resizeMode?: ImageResizeMode;
    tintColor?: ____ColorValue_Internal;
  }
>;
declare type ____DangerouslyImpreciseStyle_InternalOverrides = Readonly<{}>;
declare type ____FlattenStyleProp_Helper<
  TStyleProp extends StyleProp<unknown>,
  Depth extends FlattenDepthLimiter[keyof FlattenDepthLimiter] = 9
> = Depth extends 0
  ? never
  : TStyleProp extends "" | false | null | void
  ? never
  : TStyleProp extends ReadonlyArray<infer V>
  ? ____FlattenStyleProp_Helper<
      V,
      Depth extends number ? FlattenDepthLimiter[Depth] : 0
    >
  : TStyleProp;
declare type ____FlattenStyleProp_Internal<
  TStyleProp extends StyleProp<unknown>
> = ____FlattenStyleProp_Helper<TStyleProp> extends never
  ? any
  : ____FlattenStyleProp_Helper<TStyleProp>;
declare type ____FontVariant_Internal =
  | "common-ligatures"
  | "contextual"
  | "discretionary-ligatures"
  | "historical-ligatures"
  | "lining-nums"
  | "no-common-ligatures"
  | "no-contextual"
  | "no-discretionary-ligatures"
  | "no-historical-ligatures"
  | "oldstyle-nums"
  | "proportional-nums"
  | "small-caps"
  | "stylistic-eight"
  | "stylistic-eighteen"
  | "stylistic-eleven"
  | "stylistic-fifteen"
  | "stylistic-five"
  | "stylistic-four"
  | "stylistic-fourteen"
  | "stylistic-nine"
  | "stylistic-nineteen"
  | "stylistic-one"
  | "stylistic-seven"
  | "stylistic-seventeen"
  | "stylistic-six"
  | "stylistic-sixteen"
  | "stylistic-ten"
  | "stylistic-thirteen"
  | "stylistic-three"
  | "stylistic-twelve"
  | "stylistic-twenty"
  | "stylistic-two"
  | "tabular-nums";
declare type ____FontVariantArray_Internal =
  ReadonlyArray<____FontVariant_Internal>;
declare type ____FontWeight_Internal =
  | "100"
  | "200"
  | "300"
  | "400"
  | "500"
  | "600"
  | "700"
  | "800"
  | "900"
  | "black"
  | "bold"
  | "condensed"
  | "condensedBold"
  | "heavy"
  | "light"
  | "medium"
  | "normal"
  | "regular"
  | "semibold"
  | "thin"
  | "ultralight"
  | 100
  | 200
  | 300
  | 400
  | 500
  | 600
  | 700
  | 800
  | 900;
declare type ____ImageStyle_Internal = Readonly<
  Omit<
    ____ImageStyle_InternalCore,
    keyof ____ImageStyle_InternalOverrides | keyof {}
  > &
    Omit<____ImageStyle_InternalOverrides, keyof {}> & {}
>;
declare type ____ImageStyle_InternalCore = Readonly<
  Omit<
    ____ViewStyle_Internal,
    keyof {
      objectFit?: "contain" | "cover" | "fill" | "none" | "scale-down";
      overflow?: "hidden" | "visible";
      overlayColor?: ColorValue;
      resizeMode?: ImageResizeMode;
      tintColor?: ____ColorValue_Internal;
    }
  > & {
    objectFit?: "contain" | "cover" | "fill" | "none" | "scale-down";
    overflow?: "hidden" | "visible";
    overlayColor?: ColorValue;
    resizeMode?: ImageResizeMode;
    tintColor?: ____ColorValue_Internal;
  }
>;
declare type ____ImageStyle_InternalOverrides = Readonly<{}>;
declare type ____ImageStyleProp_Internal = StyleProp<
  Readonly<Partial<____ImageStyle_Internal>>
>;
declare type ____LayoutStyle_Internal = Readonly<{
  alignContent?:
    | "center"
    | "flex-end"
    | "flex-start"
    | "space-around"
    | "space-between"
    | "space-evenly"
    | "stretch";
  alignItems?: "baseline" | "center" | "flex-end" | "flex-start" | "stretch";
  alignSelf?:
    | "auto"
    | "baseline"
    | "center"
    | "flex-end"
    | "flex-start"
    | "stretch";
  aspectRatio?: number | string;
  borderBottomWidth?: number;
  borderEndWidth?: number;
  borderLeftWidth?: number;
  borderRightWidth?: number;
  borderStartWidth?: number;
  borderTopWidth?: number;
  borderWidth?: number;
  bottom?: DimensionValue;
  boxSizing?: "border-box" | "content-box";
  columnGap?: number | string;
  direction?: "inherit" | "ltr" | "rtl";
  display?: "contents" | "flex" | "none";
  end?: DimensionValue;
  flex?: number;
  flexBasis?: number | string;
  flexDirection?: "column-reverse" | "column" | "row-reverse" | "row";
  flexGrow?: number;
  flexShrink?: number;
  flexWrap?: "nowrap" | "wrap-reverse" | "wrap";
  gap?: number | string;
  height?: DimensionValue;
  inset?: DimensionValue;
  insetBlock?: DimensionValue;
  insetBlockEnd?: DimensionValue;
  insetBlockStart?: DimensionValue;
  insetInline?: DimensionValue;
  insetInlineEnd?: DimensionValue;
  insetInlineStart?: DimensionValue;
  justifyContent?:
    | "center"
    | "flex-end"
    | "flex-start"
    | "space-around"
    | "space-between"
    | "space-evenly";
  left?: DimensionValue;
  margin?: DimensionValue;
  marginBlock?: DimensionValue;
  marginBlockEnd?: DimensionValue;
  marginBlockStart?: DimensionValue;
  marginBottom?: DimensionValue;
  marginEnd?: DimensionValue;
  marginHorizontal?: DimensionValue;
  marginInline?: DimensionValue;
  marginInlineEnd?: DimensionValue;
  marginInlineStart?: DimensionValue;
  marginLeft?: DimensionValue;
  marginRight?: DimensionValue;
  marginStart?: DimensionValue;
  marginTop?: DimensionValue;
  marginVertical?: DimensionValue;
  maxHeight?: DimensionValue;
  maxWidth?: DimensionValue;
  minHeight?: DimensionValue;
  minWidth?: DimensionValue;
  overflow?: "hidden" | "scroll" | "visible";
  padding?: DimensionValue;
  paddingBlock?: DimensionValue;
  paddingBlockEnd?: DimensionValue;
  paddingBlockStart?: DimensionValue;
  paddingBottom?: DimensionValue;
  paddingEnd?: DimensionValue;
  paddingHorizontal?: DimensionValue;
  paddingInline?: DimensionValue;
  paddingInlineEnd?: DimensionValue;
  paddingInlineStart?: DimensionValue;
  paddingLeft?: DimensionValue;
  paddingRight?: DimensionValue;
  paddingStart?: DimensionValue;
  paddingTop?: DimensionValue;
  paddingVertical?: DimensionValue;
  position?: "absolute" | "relative" | "static";
  right?: DimensionValue;
  rowGap?: number | string;
  start?: DimensionValue;
  top?: DimensionValue;
  width?: DimensionValue;
  zIndex?: number;
}>;
declare type ____ShadowStyle_Internal = Readonly<
  Omit<
    ____ShadowStyle_InternalCore,
    keyof ____ShadowStyle_InternalOverrides | keyof {}
  > &
    Omit<____ShadowStyle_InternalOverrides, keyof {}> & {}
>;
declare type ____ShadowStyle_InternalCore = Readonly<{
  shadowColor?: ____ColorValue_Internal;
  shadowOffset?: Readonly<{
    height?: number;
    width?: number;
  }>;
  shadowOpacity?: number;
  shadowRadius?: number;
}>;
declare type ____ShadowStyle_InternalOverrides = Readonly<{}>;
declare type ____Styles_Internal = {
  readonly [key: string]: Partial<____DangerouslyImpreciseStyle_Internal>;
};
declare type ____TextStyle_Internal = Readonly<
  Omit<
    ____TextStyle_InternalCore,
    keyof ____TextStyle_InternalOverrides | keyof {}
  > &
    Omit<____TextStyle_InternalOverrides, keyof {}> & {}
>;
declare type ____TextStyle_InternalBase = Readonly<{
  color?: ____ColorValue_Internal;
  fontFamily?: string;
  fontSize?: number;
  fontStyle?: "italic" | "normal";
  fontVariant?: ____FontVariantArray_Internal | string;
  fontWeight?: ____FontWeight_Internal;
  includeFontPadding?: boolean;
  letterSpacing?: number;
  lineHeight?: number;
  textAlign?: "auto" | "center" | "justify" | "left" | "right";
  textAlignVertical?: "auto" | "bottom" | "center" | "top";
  textDecorationColor?: ____ColorValue_Internal;
  textDecorationLine?:
    | "line-through"
    | "none"
    | "underline line-through"
    | "underline";
  textDecorationStyle?: "dashed" | "dotted" | "double" | "solid";
  textShadowColor?: ____ColorValue_Internal;
  textShadowOffset?: Readonly<{
    height: number;
    width: number;
  }>;
  textShadowRadius?: number;
  textTransform?: "capitalize" | "lowercase" | "none" | "uppercase";
  userSelect?: "all" | "auto" | "contain" | "none" | "text";
  verticalAlign?: "auto" | "bottom" | "middle" | "top";
  writingDirection?: "auto" | "ltr" | "rtl";
}>;
declare type ____TextStyle_InternalCore = Readonly<
  Omit<____ViewStyle_Internal, keyof ____TextStyle_InternalBase | keyof {}> &
    Omit<____TextStyle_InternalBase, keyof {}> & {}
>;
declare type ____TextStyle_InternalOverrides = Readonly<{}>;
declare type ____TextStyleProp_Internal = StyleProp<
  Readonly<Partial<____TextStyle_Internal>>
>;
declare type ____TransformStyle_Internal = Readonly<{
  transform?:
    | ReadonlyArray<
        Readonly<
          MaximumOneOf<
            MergeUnion<
              | {
                  readonly matrix:
                    | AnimatedNode
                    | ReadonlyArray<AnimatedNode | number>;
                }
              | {
                  readonly perspective: AnimatedNode | number;
                }
              | {
                  readonly rotate: AnimatedNode | string;
                }
              | {
                  readonly rotateX: AnimatedNode | string;
                }
              | {
                  readonly rotateY: AnimatedNode | string;
                }
              | {
                  readonly rotateZ: AnimatedNode | string;
                }
              | {
                  readonly scale: AnimatedNode | number;
                }
              | {
                  readonly scaleX: AnimatedNode | number;
                }
              | {
                  readonly scaleY: AnimatedNode | number;
                }
              | {
                  readonly skewX: AnimatedNode | string;
                }
              | {
                  readonly skewY: AnimatedNode | string;
                }
              | {
                  readonly translate:
                    | [
                        AnimatedNode | number | string,
                        AnimatedNode | number | string
                      ]
                    | AnimatedNode;
                }
              | {
                  readonly translateX: AnimatedNode | number | string;
                }
              | {
                  readonly translateY: AnimatedNode | number | string;
                }
            >
          >
        >
      >
    | string;
  transformOrigin?:
    | [number | string, number | string, number | string]
    | string;
}>;
declare type ____ViewStyle_Internal = Readonly<
  Omit<
    ____ViewStyle_InternalCore,
    keyof ____ViewStyle_InternalOverrides | keyof {}
  > &
    Omit<____ViewStyle_InternalOverrides, keyof {}> & {}
>;
declare type ____ViewStyle_InternalBase = Readonly<{
  backfaceVisibility?: "hidden" | "visible";
  backgroundColor?: ____ColorValue_Internal;
  borderBlockColor?: ____ColorValue_Internal;
  borderBlockEndColor?: ____ColorValue_Internal;
  borderBlockStartColor?: ____ColorValue_Internal;
  borderBottomColor?: ____ColorValue_Internal;
  borderBottomEndRadius?: number | string;
  borderBottomLeftRadius?: number | string;
  borderBottomRightRadius?: number | string;
  borderBottomStartRadius?: number | string;
  borderBottomWidth?: number;
  borderColor?: ____ColorValue_Internal;
  borderCurve?: "circular" | "continuous";
  borderEndColor?: ____ColorValue_Internal;
  borderEndEndRadius?: number | string;
  borderEndStartRadius?: number | string;
  borderEndWidth?: number;
  borderLeftColor?: ____ColorValue_Internal;
  borderLeftWidth?: number;
  borderRadius?: number | string;
  borderRightColor?: ____ColorValue_Internal;
  borderRightWidth?: number;
  borderStartColor?: ____ColorValue_Internal;
  borderStartEndRadius?: number | string;
  borderStartStartRadius?: number | string;
  borderStartWidth?: number;
  borderStyle?: "dashed" | "dotted" | "solid";
  borderTopColor?: ____ColorValue_Internal;
  borderTopEndRadius?: number | string;
  borderTopLeftRadius?: number | string;
  borderTopRightRadius?: number | string;
  borderTopStartRadius?: number | string;
  borderTopWidth?: number;
  borderWidth?: number;
  boxShadow?: ReadonlyArray<BoxShadowValue> | string;
  cursor?: CursorValue;
  elevation?: number;
  experimental_backgroundImage?: ReadonlyArray<BackgroundImageValue> | string;
  filter?: ReadonlyArray<FilterFunction> | string;
  isolation?: "auto" | "isolate";
  mixBlendMode?: ____BlendMode_Internal;
  opacity?: number;
  outlineColor?: ____ColorValue_Internal;
  outlineOffset?: number;
  outlineStyle?: "dashed" | "dotted" | "solid";
  outlineWidth?: number;
  pointerEvents?: "auto" | "box-none" | "box-only" | "none";
}>;
declare type ____ViewStyle_InternalCore = Readonly<
  Omit<
    ____LayoutStyle_Internal,
    | keyof ____ShadowStyle_Internal
    | keyof ____TransformStyle_Internal
    | keyof ____ViewStyle_InternalBase
    | keyof {}
  > &
    Omit<
      ____ShadowStyle_Internal,
      | keyof ____TransformStyle_Internal
      | keyof ____ViewStyle_InternalBase
      | keyof {}
    > &
    Omit<
      ____TransformStyle_Internal,
      keyof ____ViewStyle_InternalBase | keyof {}
    > &
    Omit<____ViewStyle_InternalBase, keyof {}> & {}
>;
declare type ____ViewStyle_InternalOverrides = Readonly<{}>;
declare type ____ViewStyleProp_Internal = StyleProp<
  Readonly<Partial<____ViewStyle_Internal>>
>;
declare const absoluteFill: any;
declare type absoluteFill = typeof absoluteFill;
declare const absoluteFillObject: {
  readonly bottom: 0;
  readonly left: 0;
  readonly position: "absolute";
  readonly right: 0;
  readonly top: 0;
};
declare type absoluteFillObject = typeof absoluteFillObject;
declare type AbstractImageAndroid = (
  props: Omit<
    ImageProps,
    keyof {
      ref?: React.Ref<
        | React.ComponentRef<ImageViewNativeComponent>
        | React.ComponentRef<TextInlineImageNativeComponent>
      >;
    }
  > & {
    ref?: React.Ref<
      | React.ComponentRef<ImageViewNativeComponent>
      | React.ComponentRef<TextInlineImageNativeComponent>
    >;
  }
) => React.ReactNode;
declare type AbstractImageIOS = (
  props: Omit<
    ImageProps,
    keyof {
      ref?: React.Ref<React.ComponentRef<ImageViewNativeComponent>>;
    }
  > & {
    ref?: React.Ref<React.ComponentRef<ImageViewNativeComponent>>;
  }
) => React.ReactNode;
declare type AccessibilityActionInfo = Readonly<{
  label?: string;
  name: AccessibilityActionName | string;
}>;
declare type AccessibilityActionName =
  | "activate"
  | "decrement"
  | "escape"
  | "increment"
  | "longpress"
  | "magicTap";
declare type AccessibilityEventDefinitions = Omit<
  AccessibilityEventDefinitionsAndroid,
  | keyof {
      change: [boolean];
      reduceMotionChanged: [boolean];
      screenReaderChanged: [boolean];
    }
  | keyof AccessibilityEventDefinitionsIOS
> &
  Omit<
    AccessibilityEventDefinitionsIOS,
    keyof {
      change: [boolean];
      reduceMotionChanged: [boolean];
      screenReaderChanged: [boolean];
    }
  > & {
    change: [boolean];
    reduceMotionChanged: [boolean];
    screenReaderChanged: [boolean];
  };
declare type AccessibilityEventDefinitionsAndroid = {
  accessibilityServiceChanged: [boolean];
  highTextContrastChanged: [boolean];
};
declare type AccessibilityEventDefinitionsIOS = {
  announcementFinished: [
    {
      announcement: string;
      success: boolean;
    }
  ];
  boldTextChanged: [boolean];
  darkerSystemColorsChanged: [boolean];
  grayscaleChanged: [boolean];
  invertColorsChanged: [boolean];
  reduceTransparencyChanged: [boolean];
};
declare type AccessibilityEventTypes = "click" | "focus" | "viewHoverEnter";
declare const AccessibilityInfo_2: {
  addEventListener<K extends keyof AccessibilityEventDefinitions>(
    eventName: K,
    handler: (...$$REST$$: AccessibilityEventDefinitions[K]) => void
  ): EventSubscription;
  announceForAccessibility(announcement: string): void;
  announceForAccessibilityWithOptions(
    announcement: string,
    options: {
      queue?: boolean;
    }
  ): void;
  getRecommendedTimeoutMillis(originalTimeout: number): Promise<number>;
  isAccessibilityServiceEnabled(): Promise<boolean>;
  isBoldTextEnabled(): Promise<boolean>;
  isDarkerSystemColorsEnabled(): Promise<boolean>;
  isGrayscaleEnabled(): Promise<boolean>;
  isHighTextContrastEnabled(): Promise<boolean>;
  isInvertColorsEnabled(): Promise<boolean>;
  isReduceMotionEnabled(): Promise<boolean>;
  isReduceTransparencyEnabled(): Promise<boolean>;
  isScreenReaderEnabled(): Promise<boolean>;
  prefersCrossFadeTransitions(): Promise<boolean>;
  sendAccessibilityEvent(
    handle: HostInstance,
    eventType: AccessibilityEventTypes
  ): void;
  setAccessibilityFocus(reactTag: number): void;
};
declare type AccessibilityPropsAndroid = Readonly<{
  accessibilityLabelledBy?: (Array<string> | undefined) | (string | undefined);
  "aria-labelledby"?: string | undefined;
  accessibilityLiveRegion?: ("assertive" | "none" | "polite") | undefined;
  "aria-live"?: ("assertive" | "off" | "polite") | undefined;
  importantForAccessibility?:
    | ("auto" | "no-hide-descendants" | "no" | "yes")
    | undefined;
  screenReaderFocusable?: boolean;
}>;
declare type AccessibilityPropsIOS = Readonly<{
  accessibilityElementsHidden?: boolean | undefined;
  accessibilityIgnoresInvertColors?: boolean | undefined;
  accessibilityLanguage?: string | undefined;
  accessibilityLargeContentTitle?: string | undefined;
  accessibilityRespondsToUserInteraction?: boolean | undefined;
  accessibilityShowsLargeContentViewer?: boolean | undefined;
  accessibilityViewIsModal?: boolean | undefined;
  "aria-modal"?: boolean | undefined;
}>;
declare const ActionSheetIOS_2: {
  dismissActionSheet: () => void;
  showActionSheetWithOptions(
    options: ActionSheetIOSOptions,
    callback: (buttonIndex: number) => void
  ): void;
  showShareActionSheetWithOptions(
    options: ShareActionSheetIOSOptions,
    failureCallback: ((error: ShareActionSheetError) => void) | Function,
    successCallback:
      | ((success: boolean, method: null | string | undefined) => void)
      | Function
  ): void;
};
declare type ActiveCallback = (
  event: GestureResponderEvent,
  gestureState: PanResponderGestureState
) => boolean;
declare const ActivityIndicator_2: (
  props: Omit<
    ActivityIndicatorProps,
    keyof {
      ref?: React.Ref<HostComponent<never>>;
    }
  > & {
    ref?: React.Ref<HostComponent<never>>;
  }
) => React.ReactNode;
declare type ActivityIndicatorIOSProps = Readonly<{
  hidesWhenStopped?: boolean | undefined;
}>;
declare const add: typeof $$AnimatedImplementation.add;
declare type add = typeof add;
declare const add_2: (
  a: AnimatedNode | number,
  b: AnimatedNode | number
) => AnimatedAddition;
declare function addChangeListener(
  listener: ($$PARAM_0$$: { colorScheme: ColorSchemeName | undefined }) => void
): EventSubscription;
declare type AlertButtons = Array<AlertButton>;
declare type AndroidDrawable = AndroidDrawableRipple | AndroidDrawableThemeAttr;
declare type AndroidDrawableRipple = Readonly<{
  borderless?: boolean | undefined;
  color?: number | undefined;
  rippleRadius?: number | undefined;
  type: "RippleAndroid";
}>;
declare type AndroidDrawableThemeAttr = Readonly<{
  attribute: string;
  type: "ThemeAttrAndroid";
}>;
declare type AndroidPlatform = {
  OS: "android";
  select: <T>(spec: PlatformSelectSpec<T>) => T;
  get constants(): {
    Brand: string;
    Fingerprint: string;
    isDisableAnimations?: boolean;
    isTesting: boolean;
    Manufacturer: string;
    Model: string;
    reactNativeVersion: {
      major: number;
      minor: number;
      patch: number;
      prerelease: string | undefined;
    };
    Release: string;
    Serial: string;
    ServerHost?: string;
    uiMode: string;
    Version: number;
  };
  get isDisableAnimations(): boolean;
  get isTesting(): boolean;
  get isTV(): boolean;
  get isVision(): boolean;
  get Version(): number;
};
declare type AndroidProps = Readonly<{
  nextFocusDown?: number | undefined;
  nextFocusForward?: number | undefined;
  nextFocusLeft?: number | undefined;
  nextFocusRight?: number | undefined;
  nextFocusUp?: number | undefined;
}>;
declare class AnimatedAddition extends AnimatedWithChildren {
  constructor(
    a: AnimatedNode | number,
    b: AnimatedNode | number,
    config?: AnimatedNodeConfig | null | undefined
  );
  interpolate<OutputT extends number | string>(
    config: InterpolationConfigType<OutputT>
  ): AnimatedInterpolation<OutputT>;
}
declare class AnimatedColor extends AnimatedWithChildren {
  a: AnimatedValue;
  b: AnimatedValue;
  g: AnimatedValue;
  nativeColor: NativeColorValue | null | undefined;
  r: AnimatedValue;
  constructor(
    valueIn?: InputValue,
    config?: AnimatedColorConfig | null | undefined
  );
  extractOffset(): void;
  flattenOffset(): void;
  resetAnimation(callback?: ColorListenerCallback): void;
  setOffset(offset: RgbaValue): void;
  setValue(value: ColorValue | RgbaValue): void;
  stopAnimation(callback?: ColorListenerCallback): void;
}
declare type AnimatedColorConfig = Readonly<
  Omit<
    AnimatedNodeConfig,
    keyof {
      useNativeDriver: boolean;
    }
  > & {
    useNativeDriver: boolean;
  }
>;
declare type AnimatedComponentType<Props extends {}, Instance = unknown> = (
  props: Omit<
    AnimatedProps<Props>,
    keyof {
      ref?: React.Ref<Instance>;
    }
  > & {
    ref?: React.Ref<Instance>;
  }
) => React.ReactNode;
declare class AnimatedDiffClamp extends AnimatedWithChildren {
  constructor(
    a: AnimatedNode,
    min: number,
    max: number,
    config?: AnimatedNodeConfig | null | undefined
  );
  interpolate<OutputT extends number | string>(
    config: InterpolationConfigType<OutputT>
  ): AnimatedInterpolation<OutputT>;
}
declare class AnimatedDivision extends AnimatedWithChildren {
  constructor(
    a: AnimatedNode | number,
    b: AnimatedNode | number,
    config?: AnimatedNodeConfig | null | undefined
  );
  interpolate<OutputT extends number | string>(
    config: InterpolationConfigType<OutputT>
  ): AnimatedInterpolation<OutputT>;
}
declare class AnimatedEvent {
  constructor(
    argMapping: ReadonlyArray<Mapping | null | undefined>,
    config: EventConfig<any>
  );
}
declare class AnimatedInterpolation<
  OutputT extends number | string
> extends AnimatedWithChildren {
  constructor(parent: AnimatedNode, config: InterpolationConfigType<OutputT>);
  interpolate<NewOutputT extends number | string>(
    config: InterpolationConfigType<NewOutputT>
  ): AnimatedInterpolation<NewOutputT>;
}
declare class AnimatedModulo extends AnimatedWithChildren {
  constructor(
    a: AnimatedNode,
    modulus: number,
    config?: AnimatedNodeConfig | null | undefined
  );
  interpolate<OutputT extends number | string>(
    config: InterpolationConfigType<OutputT>
  ): AnimatedInterpolation<OutputT>;
}
declare class AnimatedMultiplication extends AnimatedWithChildren {
  constructor(
    a: AnimatedNode | number,
    b: AnimatedNode | number,
    config?: AnimatedNodeConfig | null | undefined
  );
  interpolate<OutputT extends number | string>(
    config: InterpolationConfigType<OutputT>
  ): AnimatedInterpolation<OutputT>;
}
declare class AnimatedNode {
  addListener(callback: (value: any) => unknown): string;
  constructor(
    config?:
      | null
      | Readonly<Omit<AnimatedNodeConfig, keyof {}> & {}>
      | undefined
  );
  hasListeners(): boolean;
  removeAllListeners(): void;
  removeListener(id: string): void;
  toJSON(): unknown;
}
declare type AnimatedNodeConfig = Readonly<{
  debugID?: string;
}>;
declare type AnimatedProps<Props extends {}> = {
  [K in keyof Props]: K extends NonAnimatedProps
    ? Props[K]
    : WithAnimatedValue<Props[K]>;
} & PassThroughProps;
declare const AnimatedScrollView: AnimatedComponentType<
  AnimatedScrollViewProps,
  AnimatedScrollViewInstance
>;
declare type AnimatedScrollViewInstance = React.ComponentRef<typeof ScrollView>;
declare type AnimatedScrollViewProps = React.JSX.LibraryManagedAttributes<
  typeof ScrollView,
  React.ComponentProps<typeof ScrollView>
>;
declare class AnimatedSubtraction extends AnimatedWithChildren {
  constructor(
    a: AnimatedNode | number,
    b: AnimatedNode | number,
    config?: AnimatedNodeConfig | null | undefined
  );
  interpolate<OutputT extends number | string>(
    config: InterpolationConfigType<OutputT>
  ): AnimatedInterpolation<OutputT>;
}
declare class AnimatedTracking extends AnimatedNode {
  constructor(
    value: AnimatedValue,
    parent: AnimatedNode,
    animationClass: any,
    animationConfig: Object,
    callback?: EndCallback | null | undefined,
    config?: AnimatedNodeConfig | null | undefined
  );
  update(): void;
}
declare class AnimatedValue extends AnimatedWithChildren {
  addListener(callback: (value: any) => unknown): string;
  animate(animation: Animation, callback: EndCallback | null | undefined): void;
  constructor(value: number, config?: AnimatedValueConfig | null | undefined);
  extractOffset(): void;
  flattenOffset(): void;
  interpolate<OutputT extends number | string>(
    config: InterpolationConfigType<OutputT>
  ): AnimatedInterpolation<OutputT>;
  removeAllListeners(): void;
  removeListener(id: string): void;
  resetAnimation(callback?: ((value: number) => void) | null | undefined): void;
  setOffset(offset: number): void;
  setValue(value: number): void;
  stopAnimation(callback?: ((value: number) => void) | null | undefined): void;
  stopTracking(): void;
  track(tracking: AnimatedTracking): void;
}
declare type AnimatedValueConfig = Readonly<
  Omit<
    AnimatedNodeConfig,
    keyof {
      useNativeDriver: boolean;
    }
  > & {
    useNativeDriver: boolean;
  }
>;
declare class AnimatedValueXY extends AnimatedWithChildren {
  x: AnimatedValue;
  y: AnimatedValue;
  addListener(callback: ValueXYListenerCallback): string;
  constructor(
    valueIn?:
      | null
      | undefined
      | {
          readonly x: AnimatedValue | number;
          readonly y: AnimatedValue | number;
        },
    config?: AnimatedValueXYConfig | null | undefined
  );
  extractOffset(): void;
  flattenOffset(): void;
  getLayout(): {
    [key: string]: AnimatedValue;
  };
  getTranslateTransform(): Array<
    | {
        translateX: AnimatedValue;
      }
    | {
        translateY: AnimatedValue;
      }
  >;
  removeAllListeners(): void;
  removeListener(id: string): void;
  resetAnimation(callback?: (value: { x: number; y: number }) => void): void;
  setOffset(offset: { x: number; y: number }): void;
  setValue(value: { x: number; y: number }): void;
  stopAnimation(callback?: (value: { x: number; y: number }) => void): void;
}
declare type AnimatedValueXYConfig = Readonly<
  Omit<
    AnimatedNodeConfig,
    keyof {
      useNativeDriver: boolean;
    }
  > & {
    useNativeDriver: boolean;
  }
>;
declare class AnimatedWithChildren extends AnimatedNode {}
declare class Animation {
  constructor(config: AnimationConfig);
  start(
    fromValue: number,
    onUpdate: (value: number) => void,
    onEnd: EndCallback | null | undefined,
    previousAnimation: Animation | null | undefined,
    animatedValue: AnimatedValue
  ): void;
  stop(): void;
}
declare type AnimationConfig = Readonly<{
  debugID?: string | undefined;
  isInteraction?: boolean;
  isLooping?: boolean;
  iterations?: number;
  onComplete?: EndCallback | undefined;
  platformConfig?: PlatformConfig;
  useNativeDriver: boolean;
}>;
declare type AnyAttributeType = AttributeType<any, any>;
declare type AnyVirtualizedSectionList = typeof VirtualizedSectionListComponent;
declare type AppearancePreferences = {
  colorScheme?: ColorSchemeName | undefined;
};
declare type AppParameters = {
  fabric?: boolean;
  initialProps: Readonly<{
    [$$Key$$: string]: unknown;
  }>;
  rootTag: RootTag;
};
declare const AppState_2: AppStateImpl;
declare type AppStateEventDefinitions = {
  blur: [];
  change: [AppStateStatus];
  focus: [];
  memoryWarning: [];
};
declare class AppStateImpl {
  currentState: null | string | undefined;
  isAvailable: boolean;
  addEventListener<K extends AppStateEvent>(
    type: K,
    handler: (...$$REST$$: AppStateEventDefinitions[K]) => void
  ): EventSubscription;
  constructor();
}
declare interface ArrayLike_2<T> extends Iterable<T> {
  [indexer: number]: T;
  readonly length: number;
}
declare function attachNativeEvent(
  viewRef: any,
  eventName: string,
  argMapping: ReadonlyArray<Mapping | null | undefined>,
  platformConfig: null | PlatformConfig | undefined
): {
  detach: () => void;
};
declare const attachNativeEvent_2: typeof $$AnimatedImplementation.attachNativeEvent;
declare type attachNativeEvent_2 = typeof attachNativeEvent_2;
declare type AttributeConfiguration = Readonly<{
  [propName: string]: AnyAttributeType;
  style: Readonly<{
    [propName: string]: AnyAttributeType;
  }>;
}>;
declare type AttributeType<T, V> =
  | Readonly<{
      diff?: (arg1: T, arg2: T) => boolean;
      process?: (arg1: V) => T;
    }>
  | true;
declare type BackgroundImageValue = LinearGradientValue | RadialGradientValue;
declare const BackHandler_2: TBackHandler;
declare type BaseKeyboardEvent = {
  duration: number;
  easing: KeyboardEventEasing;
  endCoordinates: KeyboardMetrics;
};
declare function beginAsyncEvent(
  eventName: EventName,
  args?: EventArgs
): number;
declare function beginEvent(eventName: EventName, args?: EventArgs): void;
declare class Blob {
  close(): void;
  constructor(parts?: Array<Blob | string>, options?: BlobOptions);
  set data(data: BlobData | null | undefined);
  get data(): BlobData;
  get size(): number;
  slice(start?: number, end?: number, contentType?: string): Blob;
  get type(): string;
}
declare type BlobData = {
  blobId: string;
  lastModified?: number;
  name?: string;
  offset: number;
  size: number;
  type?: string;
};
declare type BlobOptions = {
  lastModified: number;
  type: string;
};
declare type BubblingEventHandler<
  T,
  PaperName extends never | string = never
> = (event: NativeSyntheticEvent<T>) => Promise<void> | void;
declare type Builtin = (
  ...$$REST$$: ReadonlyArray<never>
) => Date | Error | RegExp | unknown;
declare const Button_2: (
  props: Omit<
    ButtonProps,
    keyof {
      ref?: React.Ref<ButtonRef>;
    }
  > & {
    ref?: React.Ref<ButtonRef>;
  }
) => React.ReactNode;
declare type ButtonRef = React.ComponentRef<typeof Touchable_2>;
declare function cancelHeadlessTask(taskId: number, taskKey: string): void;
declare type Category = string;
declare type CellMetricProps = {
  data: VirtualizedListProps["data"];
  getItem: VirtualizedListProps["getItem"];
  getItemCount: VirtualizedListProps["getItemCount"];
  getItemLayout?: VirtualizedListProps["getItemLayout"];
  keyExtractor?: VirtualizedListProps["keyExtractor"];
};
declare type CellMetrics = {
  index: number;
  isMounted: boolean;
  length: number;
  offset: number;
};
declare type CellRegion = {
  first: number;
  isSpacer: boolean;
  last: number;
};
declare type CellRendererProps<ItemT> = Readonly<{
  cellKey: string;
  children: React.ReactNode;
  index: number;
  item: ItemT;
  style: StyleProp<ViewStyle>;
  onFocusCapture?: (event: FocusEvent) => void;
  onLayout?: (event: LayoutChangeEvent) => void;
}>;
declare class CellRenderMask {
  addCells(cells: { first: number; last: number }): void;
  constructor(numCells: number);
  enumerateRegions(): ReadonlyArray<CellRegion>;
  equals(other: CellRenderMask): boolean;
  numCells(): number;
}
declare type CodeFrame = Readonly<{
  collapse?: boolean;
  content: string;
  fileName: string;
  location:
    | undefined
    | {
        column: number;
        row: number;
      };
}>;
declare function codegenNativeCommands_2<T extends {}>(
  options: Options_2<keyof T>
): T;
declare function codegenNativeComponent_2<Props extends {}>(
  componentName: string,
  options?: Options
): NativeComponentType<Props>;
declare namespace CodegenTypes {
  export {
    BubblingEventHandler,
    DirectEventHandler,
    Double,
    Float,
    Int32,
    UnsafeObject_3 as UnsafeObject,
    UnsafeMixed,
    DefaultTypes,
    WithDefault,
    EventEmitter,
  };
}
declare type ColorListenerCallback = (value: ColorValue) => unknown;
declare type ComponentStack = ReadonlyArray<CodeFrame>;
declare type ComponentStackType = "legacy" | "stack";
declare type ComponentType = HostComponent<NativeProps_3>;
declare const compose: typeof composeStyles;
declare type compose = typeof compose;
declare function composeStyles<T, U extends T, V extends T>(
  style1: null | U | undefined,
  style2: null | undefined | V
): (ReadonlyArray<T> | T) | null | undefined;
declare type CompositeAnimation = {
  reset: () => void;
  start: (callback?: EndCallback | undefined, isLooping?: boolean) => void;
  stop: () => void;
};
declare function configureNext(
  config: LayoutAnimationConfig,
  onAnimationDidEnd?: OnAnimationDidEndCallback,
  onAnimationDidFail?: OnAnimationDidFailCallback
): void;
declare type ContentAvailable = 1 | null | void;
declare type Context = Readonly<{
  cellKey: string | undefined;
  horizontal: boolean | undefined;
  getOutermostParentListRef: () => React.ComponentRef<VirtualizedList_5>;
  getScrollMetrics: () => {
    contentLength: number;
    dOffset: number;
    dt: number;
    offset: number;
    timestamp: number;
    velocity: number;
    visibleLength: number;
    zoomScale: number;
  };
  registerAsNestedChild: ($$PARAM_0$$: {
    cellKey: string;
    ref: React.ComponentRef<VirtualizedList_5>;
  }) => void;
  unregisterAsNestedChild: ($$PARAM_0$$: {
    ref: React.ComponentRef<VirtualizedList_5>;
  }) => void;
}>;
declare function counterEvent(eventName: EventName, value: number): void;
declare function create(
  duration: number,
  type?: LayoutAnimationType,
  property?: LayoutAnimationProperty
): LayoutAnimationConfig;
declare const create_2: <S extends ____Styles_Internal>(
  obj: S & ____Styles_Internal
) => Readonly<S>;
declare type create_2 = typeof create_2;
declare function createAnimatedComponent<
  TInstance extends React.ComponentType<any>
>(
  Component: TInstance
): AnimatedComponentType<
  Readonly<React.ComponentProps<TInstance>>,
  React.ComponentRef<TInstance>
>;
declare const createAnimatedComponent_2: typeof $$AnimatedImplementation.createAnimatedComponent;
declare type createAnimatedComponent_2 = typeof createAnimatedComponent_2;
declare type createPublicTextInstance = typeof createPublicTextInstance_2;
declare function createPublicTextInstance_2(
  internalInstanceHandle: InternalInstanceHandle,
  ownerDocument: ReactNativeDocument
): ReadOnlyText;
declare type DangerouslyImpreciseStyle = ____DangerouslyImpreciseStyle_Internal;
declare type DataDetectorTypesType =
  | "address"
  | "all"
  | "calendarEvent"
  | "flightNumber"
  | "link"
  | "lookupSuggestion"
  | "none"
  | "phoneNumber"
  | "trackingNumber";
declare const decay: (
  value: AnimatedColor | AnimatedValue | AnimatedValueXY,
  config: DecayAnimationConfig
) => CompositeAnimation;
declare const decay_2: typeof $$AnimatedImplementation.decay;
declare type decay_2 = typeof decay_2;
declare type DecayAnimationConfig = Readonly<
  Omit<
    AnimationConfig,
    keyof {
      deceleration?: number;
      velocity:
        | number
        | Readonly<{
            x: number;
            y: number;
          }>;
    }
  > & {
    deceleration?: number;
    velocity:
      | number
      | Readonly<{
          x: number;
          y: number;
        }>;
  }
>;
declare type DecelerationRateType = "fast" | "normal" | number;
declare type DefaultSectionT = {
  [key: string]: any;
  data: any;
};
declare type DefaultSectionT_2 = {
  [key: string]: any;
};
declare type DefaultTypes = boolean | number | ReadonlyArray<string> | string;
declare const delay: (time: number) => CompositeAnimation;
declare const delay_2: typeof $$AnimatedImplementation.delay;
declare type delay_2 = typeof delay_2;
declare interface DEPRECATED_RCTExport<T extends void = void> {
  readonly getConstants?: () => {};
}
declare type DeterminateProgressBarAndroidStyleAttrProp = {
  indeterminate: false;
  progress: number;
  styleAttr: "Horizontal";
};
declare const DevMenu_2: DevMenuStatic;
declare type DevMenuStatic = {
  show(): void;
};
declare let DevSettings_2: {
  addMenuItem(title: string, handler: () => unknown): void;
  onFastRefresh(): void;
  reload(reason?: string): void;
};
declare type DialogAction = string;
declare type DialogButtonKey = number;
declare type DialogOptions = {
  buttonNegative?: string;
  buttonNeutral?: string;
  buttonPositive?: string;
  cancelable?: boolean;
  items?: Array<string>;
  message?: string;
  title?: string;
};
declare const diffClamp: (
  a: AnimatedNode,
  min: number,
  max: number
) => AnimatedDiffClamp;
declare const diffClamp_2: typeof $$AnimatedImplementation.diffClamp;
declare type diffClamp_2 = typeof diffClamp_2;
declare type DirectEventHandler<T, PaperName extends never | string = never> = (
  event: NativeSyntheticEvent<T>
) => Promise<void> | void;
declare type DirectEventProps = Readonly<{
  onAccessibilityAction?:
    | ((event: AccessibilityActionEvent) => unknown)
    | undefined;
  onAccessibilityEscape?: (() => unknown) | undefined;
  onAccessibilityTap?: (() => unknown) | undefined;
  onLayout?: ((event: LayoutChangeEvent) => unknown) | undefined;
  onMagicTap?: (() => unknown) | undefined;
}>;
declare type DisplayModeType = symbol & {
  __DisplayModeType__: string;
};
declare const divide: (
  a: AnimatedNode | number,
  b: AnimatedNode | number
) => AnimatedDivision;
declare const divide_2: typeof $$AnimatedImplementation.divide;
declare type divide_2 = typeof divide_2;
declare class DOMRect extends DOMRectReadOnly {
  static fromRect(rect?: DOMRectInit | null | undefined): DOMRect;
  get height(): number;
  set height(height: null | number | undefined);
  get width(): number;
  set width(width: null | number | undefined);
  get x(): number;
  set x(x: null | number | undefined);
  get y(): number;
  set y(y: null | number | undefined);
}
declare interface DOMRectInit {
  height?: number | undefined;
  width?: number | undefined;
  x?: number | undefined;
  y?: number | undefined;
}
declare class DOMRectReadOnly {
  get bottom(): number;
  constructor(
    x: null | number | undefined,
    y: null | number | undefined,
    width: null | number | undefined,
    height: null | number | undefined
  );
  static fromRect(rect?: DOMRectInit | null | undefined): DOMRectReadOnly;
  get height(): number;
  get left(): number;
  get right(): number;
  toJSON(): {
    bottom: number;
    height: number;
    left: number;
    right: number;
    top: number;
    width: number;
    x: number;
    y: number;
  };
  get top(): number;
  get width(): number;
  get x(): number;
  get y(): number;
}
declare type Double = number;
declare class DrawerLayoutAndroid_2
  extends React.Component<DrawerLayoutAndroidProps, DrawerLayoutAndroidState>
  implements DrawerLayoutAndroidMethods
{
  blur(): void;
  closeDrawer(): void;
  focus(): void;
  measure(callback: MeasureOnSuccessCallback): void;
  measureInWindow(callback: MeasureInWindowOnSuccessCallback): void;
  measureLayout(
    relativeToNativeNode: number,
    onSuccess: MeasureLayoutOnSuccessCallback,
    onFail?: () => void
  ): void;
  openDrawer(): void;
  render(): React.ReactNode;
  setNativeProps(nativeProps: Object): void;
}
declare interface DrawerLayoutAndroidMethods {
  blur(): void;
  closeDrawer(): void;
  focus(): void;
  measure(callback: MeasureOnSuccessCallback): void;
  measureInWindow(callback: MeasureInWindowOnSuccessCallback): void;
  measureLayout(
    relativeToNativeNode: number,
    onSuccess: MeasureLayoutOnSuccessCallback,
    onFail?: () => void
  ): void;
  openDrawer(): void;
  setNativeProps(nativeProps: Object): void;
}
declare type DrawerLayoutAndroidState = {
  drawerOpened: boolean;
};
declare type DrawerStates = "Dragging" | "Idle" | "Settling";
declare const EasingStatic: {
  back(s?: number): EasingFunction;
  bezier(x1: number, y1: number, x2: number, y2: number): EasingFunction;
  bounce(t: number): number;
  circle(t: number): number;
  cubic(t: number): number;
  ease(t: number): number;
  elastic(bounciness?: number): EasingFunction;
  exp(t: number): number;
  in(easing: EasingFunction): EasingFunction;
  inOut(easing: EasingFunction): EasingFunction;
  linear(t: number): number;
  out(easing: EasingFunction): EasingFunction;
  poly(n: number): EasingFunction;
  quad(t: number): number;
  sin(t: number): number;
  step0(n: number): number;
  step1(n: number): number;
};
declare type EdgeInsetsOrSizeProp = RectOrSize;
declare type EdgeInsetsProp = Rect;
declare function endAsyncEvent(
  eventName: EventName,
  cookie: number,
  args?: EventArgs
): void;
declare type EndCallback = (result: EndResult) => void;
declare function endEvent(args?: EventArgs): void;
declare type EndResult = {
  finished: boolean;
  offset?: number;
  value?: number;
};
declare type EnterKeyHintType = "done" | "go" | "next" | "search" | "send";
declare type EnterKeyHintTypeAndroid = "previous";
declare type EnterKeyHintTypeIOS = "enter";
declare type ErrorHandler = (error: unknown, isFatal: boolean) => void;
declare const event: <T>(
  argMapping: ReadonlyArray<Mapping | null | undefined>,
  config: EventConfig<T>
) => any;
declare const event_2: typeof $$AnimatedImplementation.event;
declare type event_2 = typeof event_2;
declare type EventArgs =
  | null
  | undefined
  | {
      [$$Key$$: string]: string;
    };
declare type EventConfig<T> = {
  listener?: (($$PARAM_0$$: NativeSyntheticEvent<T>) => unknown) | undefined;
  platformConfig?: PlatformConfig;
  useNativeDriver: boolean;
};
declare type EventEmitter<T> = (
  handler: ($$PARAM_0$$: T) => Promise<void> | void
) => EventSubscription;
declare type EventHandlers = Readonly<{
  onBlur: (event: BlurEvent) => void;
  onClick: (event: GestureResponderEvent) => void;
  onFocus: (event: FocusEvent) => void;
  onMouseEnter?: (event: MouseEvent) => void;
  onMouseLeave?: (event: MouseEvent) => void;
  onPointerEnter?: (event: PointerEvent) => void;
  onPointerLeave?: (event: PointerEvent) => void;
  onResponderGrant: (event: GestureResponderEvent) => boolean | void;
  onResponderMove: (event: GestureResponderEvent) => void;
  onResponderRelease: (event: GestureResponderEvent) => void;
  onResponderTerminate: (event: GestureResponderEvent) => void;
  onResponderTerminationRequest: () => boolean;
  onStartShouldSetResponder: () => boolean;
}>;
declare type EventName = (() => string) | string;
declare type ExceptionData = {
  componentStack: string | undefined;
  extraData?: Object;
  id: number;
  isFatal: boolean;
  message: string;
  name: string | undefined;
  originalMessage: string | undefined;
  stack: Array<StackFrame>;
};
declare const exported: (
  props: Omit<
    ViewProps,
    keyof {
      ref?: React.Ref<React.ComponentRef<typeof View>>;
    }
  > & {
    ref?: React.Ref<React.ComponentRef<typeof View>>;
  }
) => React.ReactNode;
declare type ExtrapolateType = "clamp" | "extend" | "identity";
declare type Extras = {
  [key: string]: ExtraValue;
};
declare type ExtraValue = boolean | number | string;
declare type FetchResult = {
  NewData: "UIBackgroundFetchResultNewData";
  NoData: "UIBackgroundFetchResultNoData";
  ResultFailed: "UIBackgroundFetchResultFailed";
};
declare type FillRateHelper = typeof FillRateHelper_2;
declare class FillRateHelper_2 {
  activate(): void;
  static addListener(callback: ($$PARAM_0$$: FillRateInfo) => void): {
    remove: () => void;
  };
  computeBlankness(
    props: Omit<
      CellMetricProps,
      keyof {
        initialNumToRender?: number | undefined;
      }
    > & {
      initialNumToRender?: number | undefined;
    },
    cellsAroundViewport: {
      first: number;
      last: number;
    },
    scrollMetrics: {
      dOffset: number;
      offset: number;
      velocity: number;
      visibleLength: number;
    }
  ): number;
  constructor(listMetrics: ListMetricsAggregator);
  deactivateAndFlush(): void;
  enabled(): boolean;
  static setMinSampleCount(minSampleCount: number): void;
  static setSampleRate(sampleRate: number): void;
}
declare type FillRateInfo = Info;
declare type FlatListBaseProps<ItemT> = Omit<
  RequiredProps_3<ItemT>,
  keyof {} | keyof OptionalProps_3<ItemT>
> &
  Omit<OptionalProps_3<ItemT>, keyof {}> & {};
declare const flatten: typeof $$flattenStyle;
declare type flatten = typeof flatten;
declare type FlattenDepthLimiter = [void, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
declare function flattenStyle<
  TStyleProp extends ____DangerouslyImpreciseAnimatedStyleProp_Internal
>(
  style: null | TStyleProp | undefined
):
  | NonAnimatedNodeObject<____FlattenStyleProp_Internal<TStyleProp>>
  | null
  | undefined;
declare type Float = number;
declare type Fn<Args extends ReadonlyArray<unknown>, Return> = (
  ...$$REST$$: Args
) => Return;
declare type FocusEventProps = Readonly<{
  onBlur?: ((event: BlurEvent) => void) | undefined;
  onBlurCapture?: ((event: BlurEvent) => void) | undefined;
  onFocus?: ((event: FocusEvent) => void) | undefined;
  onFocusCapture?: ((event: FocusEvent) => void) | undefined;
}>;
declare function forkEvent(
  event: (AnimatedEvent | null | undefined) | (Function | null | undefined),
  listener: Function
): AnimatedEvent | Function;
declare const forkEvent_2: typeof $$AnimatedImplementation.forkEvent;
declare type forkEvent_2 = typeof forkEvent_2;
declare class FormData {
  append(key: string, value: FormDataValue): void;
  constructor();
  getAll(key: string): Array<FormDataValue>;
  getParts(): Array<FormDataPart>;
}
declare type FormDataPart =
  | {
      headers: Headers;
      string: string;
    }
  | {
      headers: Headers;
      name?: string;
      type?: string;
      uri: string;
    };
declare type FormDataValue =
  | string
  | {
      name?: string;
      type?: string;
      uri: string;
    };
declare type GestureResponderHandlerMethods = {
  onMoveShouldSetResponder: (event: GestureResponderEvent) => boolean;
  onMoveShouldSetResponderCapture: (event: GestureResponderEvent) => boolean;
  onResponderEnd: (event: GestureResponderEvent) => void;
  onResponderGrant: (event: GestureResponderEvent) => boolean;
  onResponderMove: (event: GestureResponderEvent) => void;
  onResponderReject: (event: GestureResponderEvent) => void;
  onResponderRelease: (event: GestureResponderEvent) => void;
  onResponderStart: (event: GestureResponderEvent) => void;
  onResponderTerminate: (event: GestureResponderEvent) => void;
  onResponderTerminationRequest: (event: GestureResponderEvent) => boolean;
  onStartShouldSetResponder: (event: GestureResponderEvent) => boolean;
  onStartShouldSetResponderCapture: (event: GestureResponderEvent) => boolean;
};
declare function get<T extends TurboModule>(name: string): null | T | undefined;
declare function getAppKeys(): ReadonlyArray<string>;
declare function getColorScheme(): ColorSchemeName | null | undefined;
declare function getEnforcing<T extends TurboModule>(name: string): T;
declare function getRegistry(): Registry;
declare function getRunnable(appKey: string): null | Runnable | undefined;
declare function getSectionKeys(): ReadonlyArray<string>;
declare function getSections(): Runnables;
declare const hairlineWidth: number;
declare type hairlineWidth = typeof hairlineWidth;
declare type Headers = {
  [name: string]: string;
};
declare class HTMLCollection<T> implements Iterable<T>, ArrayLike_2<T> {
  [index: number]: T;
  readonly length: number;
  item(index: number): null | T;
  namedItem(name: string): null | T;
  [Symbol.iterator](): Iterator<T>;
}
declare type I18nManagerConstants = {
  doLeftAndRightSwapInRTL: boolean;
  isRTL: boolean;
  localeIdentifier?: string | undefined;
};
declare interface IEventEmitter<
  TEventToArgsMap extends Readonly<Record<string, ReadonlyArray<UnsafeObject>>>
> {
  addListener<TEvent extends keyof TEventToArgsMap>(
    eventType: TEvent,
    listener: (...args: TEventToArgsMap[TEvent]) => unknown,
    context?: unknown
  ): EventSubscription;
  emit<TEvent extends keyof TEventToArgsMap>(
    eventType: TEvent,
    ...args: TEventToArgsMap[TEvent]
  ): void;
  listenerCount<TEvent extends keyof TEventToArgsMap>(
    eventType: TEvent
  ): number;
  removeAllListeners<TEvent extends keyof TEventToArgsMap>(
    eventType?: TEvent | undefined
  ): void;
}
declare interface ILogBox {
  addException(error: ExtendedExceptionData): void;
  addLog(log: LogData): void;
  clearAllLogs(): void;
  ignoreAllLogs(value?: boolean): void;
  ignoreLogs($$PARAM_0$$: ReadonlyArray<IgnorePattern>): void;
  install(): void;
  isInstalled(): boolean;
  uninstall(): void;
}
declare type ImageAndroid = AbstractImageAndroid & ImageComponentStaticsAndroid;
declare type ImageComponentStaticsAndroid = Readonly<
  Omit<
    ImageComponentStaticsIOS,
    keyof {
      abortPrefetch(requestId: number): void;
    }
  > & {
    abortPrefetch(requestId: number): void;
  }
>;
declare type ImageComponentStaticsIOS = Readonly<{
  getSize(uri: string): Promise<ImageSize>;
  getSize(
    uri: string,
    success: (width: number, height: number) => void,
    failure?: (error: unknown) => void
  ): void;
  getSizeWithHeaders(
    uri: string,
    headers: {
      [$$Key$$: string]: string;
    }
  ): Promise<ImageSize>;
  getSizeWithHeaders(
    uri: string,
    headers: {
      [$$Key$$: string]: string;
    },
    success: (width: number, height: number) => void,
    failure?: (error: unknown) => void
  ): void;
  prefetch(url: string): Promise<boolean>;
  prefetchWithMetadata(
    url: string,
    queryRootName: string,
    rootTag?: RootTag | undefined
  ): Promise<boolean>;
  queryCache(urls: Array<string>): Promise<{
    [url: string]: "disk" | "disk/memory" | "memory";
  }>;
  resolveAssetSource(source: ImageSource): ImageResolvedAssetSource | undefined;
}>;
declare type ImageErrorEventData = {
  error: string;
};
declare type ImageHostComponentProps = Readonly<
  Omit<
    ImageProps,
    | keyof {
        defaultSource?: (ImageSource | undefined) | (string | undefined);
        headers?:
          | undefined
          | {
              [$$Key$$: string]: string;
            };
        loadingIndicatorSrc?: string | undefined;
        shouldNotifyLoadEvents?: boolean;
        src?:
          | (
              | ReadonlyArray<
                  | Readonly<{
                      uri?: string | undefined;
                    }>
                  | undefined
                >
              | undefined
            )
          | (ResolvedAssetSource | undefined);
        style?: DangerouslyImpreciseStyle | ImageStyleProp;
        tintColor?: ColorValue;
      }
    | keyof ViewProps
  > &
    Omit<
      ViewProps,
      keyof {
        defaultSource?: (ImageSource | undefined) | (string | undefined);
        headers?:
          | undefined
          | {
              [$$Key$$: string]: string;
            };
        loadingIndicatorSrc?: string | undefined;
        shouldNotifyLoadEvents?: boolean;
        src?:
          | (
              | ReadonlyArray<
                  | Readonly<{
                      uri?: string | undefined;
                    }>
                  | undefined
                >
              | undefined
            )
          | (ResolvedAssetSource | undefined);
        style?: DangerouslyImpreciseStyle | ImageStyleProp;
        tintColor?: ColorValue;
      }
    > & {
      defaultSource?: (ImageSource | undefined) | (string | undefined);
      headers?:
        | undefined
        | {
            [$$Key$$: string]: string;
          };
      loadingIndicatorSrc?: string | undefined;
      shouldNotifyLoadEvents?: boolean;
      src?:
        | (
            | ReadonlyArray<
                | Readonly<{
                    uri?: string | undefined;
                  }>
                | undefined
              >
            | undefined
          )
        | (ResolvedAssetSource | undefined);
      style?: DangerouslyImpreciseStyle | ImageStyleProp;
      tintColor?: ColorValue;
    }
>;
declare type ImageIOS = AbstractImageIOS & ImageComponentStaticsIOS;
declare type ImageLoadEventData = {
  source: {
    height: number;
    uri: string;
    width: number;
  };
};
declare type ImageProgressEventDataIOS = {
  loaded: number;
  total: number;
};
declare type ImageResizeMode =
  | "center"
  | "contain"
  | "cover"
  | "none"
  | "repeat"
  | "stretch";
declare type ImageStyleProp = ____ImageStyleProp_Internal;
declare type ImageType = ImageAndroid | ImageIOS;
declare type ImageViewNativeComponent = typeof $$ImageViewNativeComponent;
declare const ImageViewNativeComponent_default: HostComponent<ImageHostComponentProps>;
declare type IndeterminateProgressBarAndroidStyleAttrProp = {
  indeterminate: true;
  styleAttr:
    | "Horizontal"
    | "Inverse"
    | "Large"
    | "LargeInverse"
    | "Normal"
    | "Small"
    | "SmallInverse";
};
declare type IndicatorSize = "large" | "small" | number;
declare class Info {
  any_blank_count: number;
  any_blank_ms: number;
  any_blank_speed_sum: number;
  mostly_blank_count: number;
  mostly_blank_ms: number;
  pixels_blank: number;
  pixels_sampled: number;
  pixels_scrolled: number;
  sample_count: number;
  total_time_spent: number;
}
declare type InnerViewInstance = React.ComponentRef<typeof View>;
declare const InputAccessoryView_2: React.ComponentType<InputAccessoryViewProps>;
declare type InputValue =
  | (ColorValue | RgbaAnimatedValue | RgbaValue)
  | null
  | undefined;
declare type InstanceHandle =
  | InternalInstanceHandle
  | ReactNativeDocumentElementInstanceHandle
  | ReactNativeDocumentInstanceHandle;
declare type Int32 = number;
declare const InteractionManager_2: typeof InteractionManagerImpl;
declare const InteractionManagerImpl: {
  Events: {
    interactionComplete: "interactionComplete";
    interactionStart: "interactionStart";
  };
  addListener: (
    eventType: string,
    listener: (...args: any) => unknown,
    context: unknown
  ) => EventSubscription;
  clearInteractionHandle(handle: Handle): void;
  createInteractionHandle(): Handle;
  runAfterInteractions(task: null | Task_2 | undefined): {
    cancel: () => void;
    then: <U>(
      onFulfill?:
        | (($$PARAM_0$$: void) => (Promise<U> | U) | undefined)
        | undefined,
      onReject?: ((error: unknown) => (Promise<U> | U) | undefined) | undefined
    ) => Promise<U>;
  };
  setDeadline(deadline: number): void;
};
declare type InternalInstanceHandle = symbol & {
  __InternalInstanceHandle__: string;
};
declare type InternalTextInput = (
  props: Omit<
    TextInputProps,
    keyof {
      ref?: React.Ref<TextInputInstance>;
    }
  > & {
    ref?: React.Ref<TextInputInstance>;
  }
) => React.ReactNode;
declare type InterpolationConfigType<OutputT extends number | string> =
  Readonly<
    Omit<
      AnimatedNodeConfig,
      keyof {
        extrapolate?: ExtrapolateType;
        extrapolateLeft?: ExtrapolateType;
        extrapolateRight?: ExtrapolateType;
        inputRange: ReadonlyArray<number>;
        outputRange: ReadonlyArray<OutputT>;
        easing?: (input: number) => number;
      }
    > & {
      extrapolate?: ExtrapolateType;
      extrapolateLeft?: ExtrapolateType;
      extrapolateRight?: ExtrapolateType;
      inputRange: ReadonlyArray<number>;
      outputRange: ReadonlyArray<OutputT>;
      easing?: (input: number) => number;
    }
  >;
declare type IOSPlatform = {
  OS: "ios";
  select: <T>(spec: PlatformSelectSpec<T>) => T;
  get constants(): {
    forceTouchAvailable: boolean;
    interfaceIdiom: string;
    isDisableAnimations?: boolean;
    isMacCatalyst?: boolean;
    isTesting: boolean;
    osVersion: string;
    reactNativeVersion: {
      major: number;
      minor: number;
      patch: number;
      prerelease: string | undefined;
    };
    systemName: string;
  };
  get isDisableAnimations(): boolean;
  get isMacCatalyst(): boolean;
  get isPad(): boolean;
  get isTesting(): boolean;
  get isTV(): boolean;
  get isVision(): boolean;
  get Version(): string;
};
declare type IOSProps = Readonly<{
  hasTVPreferredFocus?: boolean | undefined;
}>;
declare interface IPerformanceLogger {
  addTimespan(
    key: string,
    startTime: number,
    endTime: number,
    startExtras?: Extras,
    endExtras?: Extras
  ): void;
  append(logger: IPerformanceLogger): void;
  clear(): void;
  clearCompleted(): void;
  close(): void;
  currentTimestamp(): number;
  getExtras(): Readonly<{
    [key: string]: ExtraValue | undefined;
  }>;
  getPointExtras(): Readonly<{
    [key: string]: Extras | undefined;
  }>;
  getPoints(): Readonly<{
    [key: string]: number | undefined;
  }>;
  getTimespans(): Readonly<{
    [key: string]: Timespan | undefined;
  }>;
  hasTimespan(key: string): boolean;
  isClosed(): boolean;
  logEverything(): void;
  markPoint(key: string, timestamp?: number, extras?: Extras): void;
  removeExtra(key: string): ExtraValue | undefined;
  setExtra(key: string, value: ExtraValue): void;
  startTimespan(key: string, timestamp?: number, extras?: Extras): void;
  stopTimespan(key: string, timestamp?: number, extras?: Extras): void;
}
declare function isEnabled(): boolean;
declare type Item = any;
declare const Keyboard_2: KeyboardImpl;
declare type KeyboardAvoidingViewState = {
  bottom: number;
};
declare type KeyboardEventDefinitions = {
  keyboardDidChangeFrame: [KeyboardEvent];
  keyboardDidHide: [KeyboardEvent];
  keyboardDidShow: [KeyboardEvent];
  keyboardWillChangeFrame: [KeyboardEvent];
  keyboardWillHide: [KeyboardEvent];
  keyboardWillShow: [KeyboardEvent];
};
declare class KeyboardImpl {
  addListener<K extends keyof KeyboardEventDefinitions>(
    eventType: K,
    listener: (...$$REST$$: KeyboardEventDefinitions[K]) => unknown,
    context?: unknown
  ): EventSubscription;
  constructor();
  dismiss(): void;
  isVisible(): boolean;
  metrics(): KeyboardMetrics | null | undefined;
  removeAllListeners<K extends keyof KeyboardEventDefinitions>(
    eventType: K | null | undefined
  ): void;
  scheduleLayoutAnimation(event: KeyboardEvent): void;
}
declare type KeyboardType =
  | "decimal-pad"
  | "default"
  | "email-address"
  | "number-pad"
  | "numeric"
  | "phone-pad"
  | "url";
declare type KeyboardTypeAndroid = "visible-password";
declare type KeyboardTypeIOS =
  | "ascii-capable-number-pad"
  | "ascii-capable"
  | "name-phone-pad"
  | "numbers-and-punctuation"
  | "twitter"
  | "web-search";
declare function keyExtractor(item: any, index: number): string;
declare type KeysOfUnion<T> = T extends any ? keyof T : never;
declare const LayoutAnimation_2: {
  configureNext: typeof configureNext;
  create: typeof create;
  Presets: typeof Presets;
  Properties: LayoutAnimationProperties;
  setEnabled: typeof setEnabled;
  Types: LayoutAnimationTypes;
  easeInEaseOut: (onAnimationDidEnd?: OnAnimationDidEndCallback) => void;
  linear: (onAnimationDidEnd?: OnAnimationDidEndCallback) => void;
  spring: (onAnimationDidEnd?: OnAnimationDidEndCallback) => void;
  checkConfig(...args: Array<unknown>): void;
};
declare type LayoutAnimationConfig_2 = Readonly<{
  create?: LayoutAnimationAnim;
  delete?: LayoutAnimationAnim;
  duration: number;
  update?: LayoutAnimationAnim;
}>;
declare interface LegacyHostInstanceMethods {
  blur(): void;
  focus(): void;
  measure(callback: MeasureOnSuccessCallback): void;
  measureInWindow(callback: MeasureInWindowOnSuccessCallback): void;
  measureLayout(
    relativeToNativeNode: HostInstance | number,
    onSuccess: MeasureLayoutOnSuccessCallback,
    onFail?: () => void
  ): void;
  setNativeProps(nativeProps: {}): void;
}
declare type LinearGradientValue = {
  colorStops: ReadonlyArray<{
    color: ____ColorValue_Internal;
    positions?: ReadonlyArray<string>;
  }>;
  direction?: string;
  type: "linear-gradient";
};
declare const Linking_2: LinkingImpl;
declare type LinkingEventDefinitions = {
  url: [
    {
      url: string;
    }
  ];
};
declare class LinkingImpl extends NativeEventEmitter<LinkingEventDefinitions> {
  addEventListener<K extends keyof LinkingEventDefinitions>(
    eventType: K,
    listener: (...$$REST$$: LinkingEventDefinitions[K]) => unknown
  ): EventSubscription;
  canOpenURL(url: string): Promise<boolean>;
  constructor();
  getInitialURL(): Promise<null | string | undefined>;
  openSettings(): Promise<void>;
  openURL(url: string): Promise<void>;
  sendIntent(
    action: string,
    extras?: Array<{
      key: string;
      value: boolean | number | string;
    }>
  ): Promise<void>;
}
declare class ListMetricsAggregator {
  cartesianOffset(flowRelativeOffset: number): number;
  flowRelativeOffset(
    layout: LayoutRectangle,
    referenceContentLength?: null | number | undefined
  ): number;
  getAverageCellLength(): number;
  getCellMetrics(
    index: number,
    props: CellMetricProps
  ): CellMetrics | null | undefined;
  getCellMetricsApprox(index: number, props: CellMetricProps): CellMetrics;
  getCellOffsetApprox(index: number, props: CellMetricProps): number;
  getContentLength(): number;
  getHighestMeasuredCellIndex(): number;
  hasContentLength(): boolean;
  notifyCellLayout($$PARAM_0$$: {
    cellIndex: number;
    cellKey: string;
    layout: LayoutRectangle;
    orientation: ListOrientation;
  }): boolean;
  notifyCellUnmounted(cellKey: string): void;
  notifyListContentLayout($$PARAM_0$$: {
    layout: Readonly<{
      height: number;
      width: number;
    }>;
    orientation: ListOrientation;
  }): void;
}
declare type ListOrientation = {
  horizontal: boolean;
  rtl: boolean;
};
declare type LogLevel = "error" | "fatal" | "syntax" | "warn";
declare const loop: (
  animation: CompositeAnimation,
  $$PARAM_1$$?: LoopAnimationConfig
) => CompositeAnimation;
declare const loop_2: typeof $$AnimatedImplementation.loop;
declare type loop_2 = typeof loop_2;
declare type LoopAnimationConfig = {
  iterations: number;
  resetBeforeIteration?: boolean;
};
declare type MacOSPlatform = {
  OS: "macos";
  select: <T>(spec: PlatformSelectSpec<T>) => T;
  get constants(): {
    isTesting: boolean;
    osVersion: string;
    reactNativeVersion: {
      major: number;
      minor: number;
      patch: number;
      prerelease: number | undefined;
    };
    systemName: string;
  };
  get isDisableAnimations(): boolean;
  get isTesting(): boolean;
  get isTV(): boolean;
  get isVision(): boolean;
  get Version(): string;
};
declare type Mapping =
  | AnimatedValue
  | AnimatedValueXY
  | {
      [key: string]: Mapping;
    };
declare type MaximumOneOf<T extends {}> = {
  [K in keyof T]: { [P in keyof T]?: P extends K ? T[P] : never };
}[keyof { [K in keyof T]: { [P in keyof T]?: P extends K ? T[P] : never } }];
declare type MeasureInWindowOnSuccessCallback_2 = (
  x: number,
  y: number,
  width: number,
  height: number
) => void;
declare type MeasureLayoutOnSuccessCallback_2 = (
  left: number,
  top: number,
  width: number,
  height: number
) => void;
declare type MeasureOnSuccessCallback_2 = (
  x: number,
  y: number,
  width: number,
  height: number,
  pageX: number,
  pageY: number
) => void;
declare type MergeUnion<T> = { [K in KeysOfUnion<T>]?: ValueOfUnion<T, K> };
declare type Message = Readonly<{
  content: string;
  substitutions: ReadonlyArray<
    Readonly<{
      length: number;
      offset: number;
    }>
  >;
}>;
declare type ModalRefProps = Readonly<{
  ref?: React.Ref<PublicModalInstance>;
}>;
declare type Module = {};
declare const modulo: (a: AnimatedNode, modulus: number) => AnimatedModulo;
declare const modulo_2: typeof $$AnimatedImplementation.modulo;
declare type modulo_2 = typeof modulo_2;
declare type MouseEventProps = Readonly<{
  onMouseEnter?: ((event: MouseEvent) => void) | undefined;
  onMouseLeave?: ((event: MouseEvent) => void) | undefined;
}>;
declare const multiply: (
  a: AnimatedNode | number,
  b: AnimatedNode | number
) => AnimatedMultiplication;
declare const multiply_2: typeof $$AnimatedImplementation.multiply;
declare type multiply_2 = typeof multiply_2;
declare type NativeComponentType<T> = HostComponent<T>;
declare const NativeDeviceInfo: {
  getConstants(): DeviceInfoConstants;
};
declare interface NativeModule {
  addListener(eventType: string): void;
  removeListeners(count: number): void;
}
declare let NativeModules_2: {
  [moduleName: string]: any;
};
declare type NativeProps = Readonly<
  Omit<
    ViewProps,
    keyof {
      headers?:
        | undefined
        | {
            [$$Key$$: string]: string;
          };
      resizeMode?: ImageResizeMode | undefined;
      src?:
        | ReadonlyArray<
            | Readonly<{
                uri?: string | undefined;
              }>
            | undefined
          >
        | undefined;
      tintColor?: ColorValue | undefined;
    }
  > & {
    headers?:
      | undefined
      | {
          [$$Key$$: string]: string;
        };
    resizeMode?: ImageResizeMode | undefined;
    src?:
      | ReadonlyArray<
          | Readonly<{
              uri?: string | undefined;
            }>
          | undefined
        >
      | undefined;
    tintColor?: ColorValue | undefined;
  }
>;
declare type NativeProps_2 = Readonly<
  Omit<
    ViewProps,
    keyof {
      animating?: WithDefault<boolean, true>;
      color?: ColorValue | undefined;
      indeterminate: boolean;
      progress?: WithDefault<Double, 0>;
      styleAttr?: string;
      testID?: WithDefault<string, "">;
      typeAttr?: string;
    }
  > & {
    animating?: WithDefault<boolean, true>;
    color?: ColorValue | undefined;
    indeterminate: boolean;
    progress?: WithDefault<Double, 0>;
    styleAttr?: string;
    testID?: WithDefault<string, "">;
    typeAttr?: string;
  }
>;
declare type NativeProps_3 = Readonly<
  Omit<
    ViewProps,
    keyof {
      disabled?: WithDefault<boolean, false>;
      onChange?: BubblingEventHandler<SwitchChangeEvent_2> | undefined;
      onTintColor?: ColorValue | undefined;
      thumbColor?: ColorValue | undefined;
      thumbTintColor?: ColorValue | undefined;
      tintColor?: ColorValue | undefined;
      trackColorForFalse?: ColorValue | undefined;
      trackColorForTrue?: ColorValue | undefined;
      value?: WithDefault<boolean, false>;
    }
  > & {
    disabled?: WithDefault<boolean, false>;
    onChange?: BubblingEventHandler<SwitchChangeEvent_2> | undefined;
    onTintColor?: ColorValue | undefined;
    thumbColor?: ColorValue | undefined;
    thumbTintColor?: ColorValue | undefined;
    tintColor?: ColorValue | undefined;
    trackColorForFalse?: ColorValue | undefined;
    trackColorForTrue?: ColorValue | undefined;
    value?: WithDefault<boolean, false>;
  }
>;
declare type NativeProps_4 = Readonly<
  Omit<
    ViewProps,
    keyof {
      disabled?: WithDefault<boolean, false>;
      enabled?: WithDefault<boolean, true>;
      on?: WithDefault<boolean, false>;
      onChange?: BubblingEventHandler<SwitchChangeEvent_3>;
      thumbColor?: ColorValue | undefined;
      thumbTintColor?: ColorValue | undefined;
      trackColorForFalse?: ColorValue | undefined;
      trackColorForTrue?: ColorValue | undefined;
      trackTintColor?: ColorValue | undefined;
      value?: WithDefault<boolean, false>;
    }
  > & {
    disabled?: WithDefault<boolean, false>;
    enabled?: WithDefault<boolean, true>;
    on?: WithDefault<boolean, false>;
    onChange?: BubblingEventHandler<SwitchChangeEvent_3>;
    thumbColor?: ColorValue | undefined;
    thumbTintColor?: ColorValue | undefined;
    trackColorForFalse?: ColorValue | undefined;
    trackColorForTrue?: ColorValue | undefined;
    trackTintColor?: ColorValue | undefined;
    value?: WithDefault<boolean, false>;
  }
>;
declare type NativeResponseType = "base64" | "blob" | "text";
declare type NativeScrollPoint = Readonly<{
  x: number;
  y: number;
}>;
declare type NativeScrollRectangle = Readonly<{
  bottom: number;
  left: number;
  right: number;
  top: number;
}>;
declare type NativeScrollSize = Readonly<{
  height: number;
  width: number;
}>;
declare type NativeScrollVelocity = Readonly<{
  x: number;
  y: number;
}>;
declare const NativeText: HostComponent<NativeTextProps>;
declare type NativeText = typeof NativeText;
declare type NativeTextProps = Readonly<
  Omit<
    TextProps,
    keyof {
      isHighlighted?: boolean | undefined;
      isPressable?: boolean | undefined;
      onClick?: ((event: GestureResponderEvent) => unknown) | undefined;
      selectionColor?: ProcessedColorValue | undefined;
    }
  > & {
    isHighlighted?: boolean | undefined;
    isPressable?: boolean | undefined;
    onClick?: ((event: GestureResponderEvent) => unknown) | undefined;
    selectionColor?: ProcessedColorValue | undefined;
  }
>;
declare type NativeType = HostComponent<NativeProps_4>;
declare const NativeVirtualText: HostComponent<NativeTextProps>;
declare type NativeVirtualText = typeof NativeVirtualText;
declare class NodeList<T> implements Iterable<T>, ArrayLike_2<T> {
  [index: number]: T;
  readonly length: number;
  entries(): Iterator<[number, T]>;
  forEach<ThisType>(
    callbackFn: (value: T, index: number, array: NodeList<T>) => unknown,
    thisArg?: ThisType
  ): void;
  item(index: number): null | T;
  keys(): Iterator<number>;
  values(): Iterator<T>;
  [Symbol.iterator](): Iterator<T>;
}
declare type NonAnimatedNodeObject<TStyleProp> = TStyleProp extends AnimatedNode
  ? never
  : TStyleProp;
declare type NonAnimatedProps =
  | "accessibilityLabel"
  | "disabled"
  | "innerViewRef"
  | "ref"
  | "scrollViewRef"
  | "testID";
declare type Nullable = null | void;
declare type Omit_2<T, K> = T extends any ? Pick<T, Exclude<keyof T, K>> : T;
declare type OnAnimationDidEndCallback = () => void;
declare type OnAnimationDidFailCallback = () => void;
declare type OptionalPlatformSelectSpec<T> = { [key in PlatformOSType]?: T };
declare type OptionalProps = {
  CellRendererComponent?:
    | React.ComponentType<CellRendererProps<Item>>
    | undefined;
  debug?: boolean | undefined;
  disableVirtualization?: boolean | undefined;
  extraData?: any;
  horizontal?: boolean | undefined;
  initialNumToRender?: number | undefined;
  initialScrollIndex?: number | undefined;
  inverted?: boolean | undefined;
  ItemSeparatorComponent?: React.ComponentType<any> | undefined;
  keyExtractor?: ((item: Item, index: number) => string) | undefined;
  ListEmptyComponent?:
    | (React.ComponentType<any> | React.JSX.Element)
    | undefined;
  ListFooterComponent?:
    | (React.ComponentType<any> | React.JSX.Element)
    | undefined;
  ListFooterComponentStyle?: StyleProp<ViewStyle>;
  ListHeaderComponent?:
    | (React.ComponentType<any> | React.JSX.Element)
    | undefined;
  ListHeaderComponentStyle?: StyleProp<ViewStyle>;
  ListItemComponent?:
    | (React.ComponentType<any> | React.JSX.Element)
    | undefined;
  maxToRenderPerBatch?: number | undefined;
  onEndReached?: ((info: { distanceFromEnd: number }) => void) | undefined;
  onEndReachedThreshold?: number | undefined;
  onRefresh?: (() => void) | undefined;
  onScrollToIndexFailed?:
    | ((info: {
        averageItemLength: number;
        highestMeasuredFrameIndex: number;
        index: number;
      }) => void)
    | undefined;
  onStartReached?: ((info: { distanceFromStart: number }) => void) | undefined;
  onStartReachedThreshold?: number | undefined;
  onViewableItemsChanged?:
    | ((info: {
        changed: Array<ViewToken>;
        viewableItems: Array<ViewToken>;
      }) => void)
    | undefined;
  persistentScrollbar?: boolean | undefined;
  progressViewOffset?: number;
  refreshControl?: React.JSX.Element | undefined;
  refreshing?: boolean | undefined;
  removeClippedSubviews?: boolean;
  renderItem?: ListRenderItem<Item> | undefined;
  updateCellsBatchingPeriod?: number | undefined;
  viewabilityConfig?: ViewabilityConfig;
  viewabilityConfigCallbackPairs?: Array<ViewabilityConfigCallbackPair>;
  windowSize?: number | undefined;
  getItemLayout?: (
    data: any,
    index: number
  ) => {
    index: number;
    length: number;
    offset: number;
  };
  renderScrollComponent?: (props: ScrollViewProps) => React.JSX.Element;
};
declare type OptionalProps_2<ItemT, SectionT = DefaultSectionT> = {
  onEndReached?:
    | (($$PARAM_0$$: { distanceFromEnd: number }) => void)
    | undefined;
  renderSectionFooter?:
    | ((info: { section: SectionT }) => null | React.ReactNode)
    | undefined;
  renderSectionHeader?:
    | ((info: { section: SectionT }) => null | React.ReactNode)
    | undefined;
  SectionSeparatorComponent?: React.ComponentType<any> | undefined;
  stickySectionHeadersEnabled?: boolean;
  renderItem?: (info: {
    index: number;
    item: ItemT;
    section: SectionT;
    separators: {
      highlight: () => void;
      unhighlight: () => void;
      updateProps: (select: "leading" | "trailing", newProps: Object) => void;
    };
  }) => null | React.ReactNode;
};
declare type OptionalProps_3<ItemT> = {
  columnWrapperStyle?: ViewStyleProp;
  extraData?: any;
  fadingEdgeLength?:
    | (number | undefined)
    | {
        end: number;
        start: number;
      };
  horizontal?: boolean | undefined;
  initialNumToRender?: number | undefined;
  initialScrollIndex?: number | undefined;
  inverted?: boolean | undefined;
  keyExtractor?: ((item: ItemT, index: number) => string) | undefined;
  numColumns?: number;
  removeClippedSubviews?: boolean;
  renderItem?: ListRenderItem<ItemT> | undefined;
  strictMode?: boolean;
  getItemLayout?: (
    data: Readonly<ArrayLike<ItemT>> | undefined,
    index: number
  ) => {
    index: number;
    length: number;
    offset: number;
  };
};
declare type OptionalProps_4<ItemT, SectionT = DefaultSectionT_2> = {
  extraData?: any;
  initialNumToRender?: number | undefined;
  inverted?: boolean | undefined;
  keyExtractor?: ((item: ItemT, index: number) => string) | undefined;
  onEndReached?: ((info: { distanceFromEnd: number }) => void) | undefined;
  removeClippedSubviews?: boolean;
  renderItem?: SectionListRenderItem<ItemT, SectionT>;
};
declare type Options = Readonly<{
  excludedPlatforms?: ReadonlyArray<"android" | "iOS">;
  interfaceOnly?: boolean;
  paperComponentName?: string;
  paperComponentNameDeprecated?: string;
}>;
declare type Options_2<T = string> = Readonly<{
  supportedCommands: ReadonlyArray<T>;
}>;
declare type OrientationChangeEvent = Readonly<{
  orientation: "landscape" | "portrait";
}>;
declare const PanResponder_2: {
  create(config: PanResponderCallbacks): {
    panHandlers: GestureResponderHandlerMethods;
    getInteractionHandle: () => number | undefined;
  };
};
declare const parallel: (
  animations: Array<CompositeAnimation>,
  config?: null | ParallelConfig | undefined
) => CompositeAnimation;
declare const parallel_2: typeof $$AnimatedImplementation.parallel;
declare type parallel_2 = typeof parallel_2;
declare type ParallelConfig = {
  stopTogether?: boolean;
};
declare type PassiveCallback = (
  event: GestureResponderEvent,
  gestureState: PanResponderGestureState
) => unknown;
declare type PassThroughProps = Readonly<{
  passthroughAnimatedPropExplicitValues?: null | React.JSX.LibraryManagedAttributes<
    typeof View,
    React.ComponentProps<typeof View>
  >;
}>;
declare type PasswordRules = string;
declare class PermissionsAndroid_2 {
  PERMISSIONS: PermissionsType;
  RESULTS: Readonly<{
    DENIED: "denied";
    GRANTED: "granted";
    NEVER_ASK_AGAIN: "never_ask_again";
  }>;
  check(permission: Permission): Promise<boolean>;
  checkPermission(permission: Permission): Promise<boolean>;
  request(
    permission: Permission,
    rationale?: Rationale
  ): Promise<PermissionStatus>;
  requestMultiple(
    permissions: Array<Permission>
  ): Promise<{ [permission in Permission]: PermissionStatus }>;
  requestPermission(
    permission: Permission,
    rationale?: Rationale
  ): Promise<boolean>;
}
declare const PermissionsAndroidInstance: PermissionsAndroid_2;
declare type PermissionsType = Readonly<{
  ACCEPT_HANDOVER: "android.permission.ACCEPT_HANDOVER";
  ACCESS_BACKGROUND_LOCATION: "android.permission.ACCESS_BACKGROUND_LOCATION";
  ACCESS_COARSE_LOCATION: "android.permission.ACCESS_COARSE_LOCATION";
  ACCESS_FINE_LOCATION: "android.permission.ACCESS_FINE_LOCATION";
  ACCESS_MEDIA_LOCATION: "android.permission.ACCESS_MEDIA_LOCATION";
  ACTIVITY_RECOGNITION: "android.permission.ACTIVITY_RECOGNITION";
  ADD_VOICEMAIL: "com.android.voicemail.permission.ADD_VOICEMAIL";
  ANSWER_PHONE_CALLS: "android.permission.ANSWER_PHONE_CALLS";
  BLUETOOTH_ADVERTISE: "android.permission.BLUETOOTH_ADVERTISE";
  BLUETOOTH_CONNECT: "android.permission.BLUETOOTH_CONNECT";
  BLUETOOTH_SCAN: "android.permission.BLUETOOTH_SCAN";
  BODY_SENSORS: "android.permission.BODY_SENSORS";
  BODY_SENSORS_BACKGROUND: "android.permission.BODY_SENSORS_BACKGROUND";
  CALL_PHONE: "android.permission.CALL_PHONE";
  CAMERA: "android.permission.CAMERA";
  GET_ACCOUNTS: "android.permission.GET_ACCOUNTS";
  NEARBY_WIFI_DEVICES: "android.permission.NEARBY_WIFI_DEVICES";
  POST_NOTIFICATIONS: "android.permission.POST_NOTIFICATIONS";
  PROCESS_OUTGOING_CALLS: "android.permission.PROCESS_OUTGOING_CALLS";
  READ_CALENDAR: "android.permission.READ_CALENDAR";
  READ_CALL_LOG: "android.permission.READ_CALL_LOG";
  READ_CONTACTS: "android.permission.READ_CONTACTS";
  READ_EXTERNAL_STORAGE: "android.permission.READ_EXTERNAL_STORAGE";
  READ_MEDIA_AUDIO: "android.permission.READ_MEDIA_AUDIO";
  READ_MEDIA_IMAGES: "android.permission.READ_MEDIA_IMAGES";
  READ_MEDIA_VIDEO: "android.permission.READ_MEDIA_VIDEO";
  READ_MEDIA_VISUAL_USER_SELECTED: "android.permission.READ_MEDIA_VISUAL_USER_SELECTED";
  READ_PHONE_NUMBERS: "android.permission.READ_PHONE_NUMBERS";
  READ_PHONE_STATE: "android.permission.READ_PHONE_STATE";
  READ_SMS: "android.permission.READ_SMS";
  READ_VOICEMAIL: "com.android.voicemail.permission.READ_VOICEMAIL";
  RECEIVE_MMS: "android.permission.RECEIVE_MMS";
  RECEIVE_SMS: "android.permission.RECEIVE_SMS";
  RECEIVE_WAP_PUSH: "android.permission.RECEIVE_WAP_PUSH";
  RECORD_AUDIO: "android.permission.RECORD_AUDIO";
  SEND_SMS: "android.permission.SEND_SMS";
  USE_SIP: "android.permission.USE_SIP";
  UWB_RANGING: "android.permission.UWB_RANGING";
  WRITE_CALENDAR: "android.permission.WRITE_CALENDAR";
  WRITE_CALL_LOG: "android.permission.WRITE_CALL_LOG";
  WRITE_CONTACTS: "android.permission.WRITE_CONTACTS";
  WRITE_EXTERNAL_STORAGE: "android.permission.WRITE_EXTERNAL_STORAGE";
  WRITE_VOICEMAIL: "com.android.voicemail.permission.WRITE_VOICEMAIL";
}>;
declare type Platform_2 =
  | AndroidPlatform
  | IOSPlatform
  | MacOSPlatform
  | WebPlatform
  | WindowsPlatform;
declare type PlatformConfig = {};
declare type PointerEventProps = Readonly<{
  onClick?: ((event: PointerEvent) => void) | undefined;
  onClickCapture?: ((event: PointerEvent) => void) | undefined;
  onGotPointerCapture?: ((e: PointerEvent) => void) | undefined;
  onGotPointerCaptureCapture?: ((e: PointerEvent) => void) | undefined;
  onLostPointerCapture?: ((e: PointerEvent) => void) | undefined;
  onLostPointerCaptureCapture?: ((e: PointerEvent) => void) | undefined;
  onPointerCancel?: ((e: PointerEvent) => void) | undefined;
  onPointerCancelCapture?: ((e: PointerEvent) => void) | undefined;
  onPointerDown?: ((e: PointerEvent) => void) | undefined;
  onPointerDownCapture?: ((e: PointerEvent) => void) | undefined;
  onPointerEnter?: ((event: PointerEvent) => void) | undefined;
  onPointerEnterCapture?: ((event: PointerEvent) => void) | undefined;
  onPointerLeave?: ((event: PointerEvent) => void) | undefined;
  onPointerLeaveCapture?: ((event: PointerEvent) => void) | undefined;
  onPointerMove?: ((event: PointerEvent) => void) | undefined;
  onPointerMoveCapture?: ((event: PointerEvent) => void) | undefined;
  onPointerOut?: ((e: PointerEvent) => void) | undefined;
  onPointerOutCapture?: ((e: PointerEvent) => void) | undefined;
  onPointerOver?: ((e: PointerEvent) => void) | undefined;
  onPointerOverCapture?: ((e: PointerEvent) => void) | undefined;
  onPointerUp?: ((e: PointerEvent) => void) | undefined;
  onPointerUpCapture?: ((e: PointerEvent) => void) | undefined;
}>;
declare type PointerEventProps_2 = Readonly<{
  onPointerEnter?: (event: PointerEvent) => void;
  onPointerLeave?: (event: PointerEvent) => void;
  onPointerMove?: (event: PointerEvent) => void;
}>;
declare type PointProp = Readonly<{
  x: number;
  y: number;
}>;
declare type PresentLocalNotificationDetails = {
  alertAction?: string;
  alertBody: string;
  alertTitle?: string;
  applicationIconBadgeNumber?: number;
  category?: string;
  fireDate?: number;
  isSilent?: boolean;
  soundName?: string;
  userInfo?: Object;
};
declare const Presets: {
  easeInEaseOut: LayoutAnimationConfig;
  linear: LayoutAnimationConfig;
  spring: LayoutAnimationConfig;
};
declare class Pressability {
  configure(config: PressabilityConfig): void;
  constructor(config: PressabilityConfig);
  getEventHandlers(): EventHandlers;
  reset(): void;
  static setLongPressDeactivationDistance(distance: number): void;
}
declare type PressabilityConfig = Readonly<{
  android_disableSound?: boolean | undefined;
  blockNativeResponder?: boolean | undefined;
  cancelable?: boolean | undefined;
  delayHoverIn?: number | undefined;
  delayHoverOut?: number | undefined;
  delayLongPress?: number | undefined;
  delayPressIn?: number | undefined;
  delayPressOut?: number | undefined;
  disabled?: boolean | undefined;
  hitSlop?: RectOrSize | undefined;
  minPressDuration?: number | undefined;
  onBlur?: ((event: BlurEvent) => unknown) | undefined;
  onFocus?: ((event: FocusEvent) => unknown) | undefined;
  onHoverIn?: ((event: MouseEvent) => unknown) | undefined;
  onHoverOut?: ((event: MouseEvent) => unknown) | undefined;
  onLongPress?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPress?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPressIn?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPressMove?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPressOut?: ((event: GestureResponderEvent) => unknown) | undefined;
  pressRectOffset?: RectOrSize | undefined;
}>;
declare type PressableBaseProps = Readonly<{
  android_disableSound?: boolean | undefined;
  android_ripple?: PressableAndroidRippleConfig | undefined;
  cancelable?: boolean | undefined;
  children?:
    | ((state: PressableStateCallbackType) => React.ReactNode)
    | React.ReactNode;
  delayHoverIn?: number | undefined;
  delayHoverOut?: number | undefined;
  delayLongPress?: number | undefined;
  disabled?: boolean | undefined;
  hitSlop?: RectOrSize | undefined;
  onHoverIn?: ((event: MouseEvent) => unknown) | undefined;
  onHoverOut?: ((event: MouseEvent) => unknown) | undefined;
  onLayout?: ((event: LayoutChangeEvent) => unknown) | undefined;
  onLongPress?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPress?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPressIn?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPressMove?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPressOut?: ((event: GestureResponderEvent) => unknown) | undefined;
  pressRetentionOffset?: RectOrSize | undefined;
  style?:
    | ((state: PressableStateCallbackType) => ViewStyleProp_2)
    | ViewStyleProp_2;
  testID?: string | undefined;
  testOnly_pressed?: boolean | undefined;
  unstable_pressDelay?: number | undefined;
}>;
declare type PressRetentionOffset = Readonly<{
  bottom: number;
  left: number;
  right: number;
  top: number;
}>;
declare type Primitive = boolean | number | string | symbol | void;
declare function processColor_2(
  color?: (ColorValue | number) | null | undefined
): null | ProcessedColorValue | undefined;
declare let ProgressBarAndroid_2: (
  props: Omit_2<
    Omit_2<ProgressBarAndroidProps, never>,
    keyof {
      ref?: React.Ref<
        React.ComponentRef<ProgressBarAndroidNativeComponentType>
      >;
    }
  > & {
    ref?: React.Ref<React.ComponentRef<ProgressBarAndroidNativeComponentType>>;
  }
) => React.ReactNode;
declare type ProgressBarAndroidBaseProps = Readonly<{
  animating?: boolean | undefined;
  color?: ColorValue | undefined;
  testID?: string | undefined;
}>;
declare type ProgressBarAndroidNativeComponentType =
  typeof $$ProgressBarAndroidNativeComponent;
declare type PublicModalInstance = HostInstance;
declare interface PublicScrollViewInstance
  extends HostInstance,
    ScrollViewImperativeMethods {}
declare interface PushNotification {
  finish(result: string): void;
  getAlert(): (Object | undefined) | (string | undefined);
  getBadgeCount(): number | undefined;
  getCategory(): string | undefined;
  getContentAvailable(): ContentAvailable;
  getData(): Object | undefined;
  getMessage(): (Object | undefined) | (string | undefined);
  getSound(): string | undefined;
  getThreadID(): string | undefined;
}
declare type RadialExtent =
  | "closest-corner"
  | "closest-side"
  | "farthest-corner"
  | "farthest-side";
declare type RadialGradientPosition =
  | {
      bottom: number | string;
      left: number | string;
    }
  | {
      bottom: number | string;
      right: number | string;
    }
  | {
      left: number | string;
      top: number | string;
    }
  | {
      right: number | string;
      top: number | string;
    };
declare type RadialGradientShape = "circle" | "ellipse";
declare type RadialGradientSize =
  | RadialExtent
  | {
      x: number | string;
      y: number | string;
    };
declare type RadialGradientValue = {
  colorStops: ReadonlyArray<{
    color: ____ColorValue_Internal;
    positions?: ReadonlyArray<string>;
  }>;
  position: RadialGradientPosition;
  shape: RadialGradientShape;
  size: RadialGradientSize;
  type: "radial-gradient";
};
declare type RCTDeviceEventDefinitions = {
  [name: string]: Array<any>;
};
declare const RCTNativeAppEventEmitter: typeof DeviceEventEmitter;
declare const RCTNetworking: {
  abortRequest(requestId: number): void;
  addListener<K extends keyof RCTNetworkingEventDefinitions>(
    eventType: K,
    listener: (...$$REST$$: RCTNetworkingEventDefinitions[K]) => unknown,
    context?: unknown
  ): EventSubscription;
  clearCookies(callback: (result: boolean) => void): void;
  sendRequest(
    method: string,
    trackingName: string | void,
    url: string,
    headers: {},
    data: RequestBody,
    responseType: NativeResponseType,
    incrementalUpdates: boolean,
    timeout: number,
    callback: (requestId: number) => void,
    withCredentials: boolean
  ): void;
};
declare type RCTNetworkingEventDefinitions = Readonly<{
  didCompleteNetworkResponse: [[number, string, boolean]];
  didReceiveNetworkData: [[number, string]];
  didReceiveNetworkDataProgress: [[number, number, number]];
  didReceiveNetworkIncrementalData: [[number, string, number, number]];
  didReceiveNetworkResponse: [
    [
      number,
      number,
      (
        | undefined
        | {
            [$$Key$$: string]: string;
          }
      ),
      string | undefined
    ]
  ];
  didSendNetworkData: [[number, number, number]];
}>;
declare class ReactNativeDocument extends ReadOnlyNode {
  get childElementCount(): number;
  get children(): HTMLCollection<ReadOnlyElement>;
  constructor(
    rootTag: RootTag,
    instanceHandle: ReactNativeDocumentInstanceHandle
  );
  get documentElement(): ReactNativeElement;
  get firstElementChild(): null | ReadOnlyElement;
  get lastElementChild(): null | ReadOnlyElement;
  get nodeName(): string;
  get nodeType(): number;
  get nodeValue(): null;
  get textContent(): null;
}
declare type ReactNativeDocumentElementInstanceHandle = symbol & {
  __ReactNativeDocumentElementInstanceHandle__: string;
};
declare type ReactNativeDocumentInstanceHandle = symbol & {
  __ReactNativeDocumentInstanceHandle__: string;
};
declare class ReactNativeElement
  extends ReadOnlyElement
  implements NativeMethods
{
  blur(): void;
  constructor(
    tag: number,
    viewConfig: ViewConfig,
    instanceHandle: InstanceHandle,
    ownerDocument: ReactNativeDocument
  );
  focus(): void;
  measure(callback: MeasureOnSuccessCallback): void;
  measureInWindow(callback: MeasureInWindowOnSuccessCallback): void;
  measureLayout(
    relativeToNativeNode: HostInstance | number,
    onSuccess: MeasureLayoutOnSuccessCallback,
    onFail?: () => void
  ): void;
  get offsetHeight(): number;
  get offsetLeft(): number;
  get offsetParent(): null | ReadOnlyElement;
  get offsetTop(): number;
  get offsetWidth(): number;
  setNativeProps(nativeProps: {}): void;
}
declare class ReadOnlyCharacterData extends ReadOnlyNode {
  get data(): string;
  get length(): number;
  get nextElementSibling(): null | ReadOnlyElement;
  get nodeValue(): string;
  get previousElementSibling(): null | ReadOnlyElement;
  substringData(offset: number, count: number): string;
  get textContent(): string;
}
declare class ReadOnlyElement extends ReadOnlyNode {
  get childElementCount(): number;
  get children(): HTMLCollection<ReadOnlyElement>;
  get clientHeight(): number;
  get clientLeft(): number;
  get clientTop(): number;
  get clientWidth(): number;
  get firstElementChild(): null | ReadOnlyElement;
  getBoundingClientRect(): DOMRect;
  hasPointerCapture(pointerId: number): boolean;
  get id(): string;
  get lastElementChild(): null | ReadOnlyElement;
  get nextElementSibling(): null | ReadOnlyElement;
  get nodeName(): string;
  get nodeType(): number;
  get nodeValue(): null | string;
  set nodeValue(value: string);
  get previousElementSibling(): null | ReadOnlyElement;
  releasePointerCapture(pointerId: number): void;
  get scrollHeight(): number;
  get scrollLeft(): number;
  get scrollTop(): number;
  get scrollWidth(): number;
  setPointerCapture(pointerId: number): void;
  get tagName(): string;
  get textContent(): string;
}
declare class ReadOnlyNode {
  static ATTRIBUTE_NODE: number;
  static CDATA_SECTION_NODE: number;
  static COMMENT_NODE: number;
  static DOCUMENT_FRAGMENT_NODE: number;
  static DOCUMENT_NODE: number;
  static DOCUMENT_POSITION_CONTAINED_BY: number;
  static DOCUMENT_POSITION_CONTAINS: number;
  static DOCUMENT_POSITION_DISCONNECTED: number;
  static DOCUMENT_POSITION_FOLLOWING: number;
  static DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
  static DOCUMENT_POSITION_PRECEDING: number;
  static DOCUMENT_TYPE_NODE: number;
  static ELEMENT_NODE: number;
  static ENTITY_NODE: number;
  static ENTITY_REFERENCE_NODE: number;
  static NOTATION_NODE: number;
  static PROCESSING_INSTRUCTION_NODE: number;
  static TEXT_NODE: number;
  get childNodes(): NodeList<ReadOnlyNode>;
  compareDocumentPosition(otherNode: ReadOnlyNode): number;
  constructor(
    instanceHandle: InstanceHandle,
    ownerDocument: null | ReactNativeDocument
  );
  contains(otherNode: ReadOnlyNode): boolean;
  get firstChild(): null | ReadOnlyNode;
  getRootNode(): ReadOnlyNode;
  hasChildNodes(): boolean;
  get isConnected(): boolean;
  get lastChild(): null | ReadOnlyNode;
  get nextSibling(): null | ReadOnlyNode;
  get nodeName(): string;
  get nodeType(): number;
  get nodeValue(): null | string;
  get ownerDocument(): null | ReactNativeDocument;
  get parentElement(): null | ReadOnlyElement;
  get parentNode(): null | ReadOnlyNode;
  get previousSibling(): null | ReadOnlyNode;
  get textContent(): string;
}
declare class ReadOnlyText extends ReadOnlyCharacterData {
  get nodeName(): string;
  get nodeType(): number;
}
declare type Rect = Readonly<{
  bottom?: number | undefined;
  left?: number | undefined;
  right?: number | undefined;
  top?: number | undefined;
}>;
declare type RectOrSize = number | Rect;
declare type RefreshControlBaseProps = Readonly<{
  onRefresh?: (() => Promise<void> | void) | undefined;
  progressViewOffset?: number | undefined;
  refreshing: boolean;
}>;
declare type RegisterCallableModule = (
  name: string,
  moduleOrFactory: (($$PARAM_0$$: void) => Module) | Module
) => void;
declare const registerCallableModule_2: RegisterCallableModule;
declare function registerCancellableHeadlessTask(
  taskKey: string,
  taskProvider: TaskProvider,
  taskCancelProvider: TaskCancelProvider
): void;
declare function registerComponent(
  appKey: string,
  componentProvider: ComponentProvider,
  section?: boolean
): string;
declare function registerConfig(config: Array<AppConfig>): void;
declare function registerHeadlessTask(
  taskKey: string,
  taskProvider: TaskProvider
): void;
declare function registerRunnable(appKey: string, run: Runnable): string;
declare function registerSection(
  appKey: string,
  component: ComponentProvider
): void;
declare type RequestBody =
  | ArrayBuffer
  | ArrayBufferView
  | Blob
  | FormData
  | string
  | {
      uri: string;
    };
declare type RequiredProps = {
  data?: any;
  getItem: (data: any, index: number) => Item | undefined;
  getItemCount: (data: any) => number;
};
declare type RequiredProps_2<ItemT, SectionT = DefaultSectionT> = {
  sections: ReadonlyArray<SectionListData<ItemT, SectionT>>;
};
declare type RequiredProps_3<ItemT> = {
  data: Readonly<ArrayLike<ItemT>> | undefined;
};
declare type RequiredProps_4<ItemT, SectionT = DefaultSectionT_2> = {
  sections: ReadonlyArray<SectionListData<ItemT, SectionT>>;
};
declare const requireNativeComponent_2: <T extends {}>(
  uiViewClassName: string
) => HostComponent<T>;
declare type ResolvedAssetSource = {
  readonly height: number | undefined;
  readonly scale: number;
  readonly uri: string;
  readonly width: number | undefined;
};
declare type ReturnKeyType = "done" | "go" | "next" | "search" | "send";
declare type ReturnKeyTypeAndroid = "none" | "previous";
declare type ReturnKeyTypeIOS =
  | "default"
  | "emergency-call"
  | "google"
  | "join"
  | "route"
  | "yahoo";
declare type RgbaAnimatedValue = {
  readonly a: AnimatedValue;
  readonly b: AnimatedValue;
  readonly g: AnimatedValue;
  readonly r: AnimatedValue;
};
declare type RgbaValue = {
  readonly a: number;
  readonly b: number;
  readonly g: number;
  readonly r: number;
};
declare function runApplication(
  appKey: string,
  appParameters: AppParameters,
  displayMode?: number
): void;
declare type ScheduleLocalNotificationDetails = Omit<
  PresentLocalNotificationDetails,
  keyof {
    repeatInterval?: "day" | "hour" | "minute" | "month" | "week" | "year";
  }
> & {
  repeatInterval?: "day" | "hour" | "minute" | "month" | "week" | "year";
};
declare type ScrollViewBaseProps = Readonly<{
  children?: React.ReactNode;
  contentContainerStyle?: undefined | ViewStyleProp;
  contentOffset?: PointProp | undefined;
  decelerationRate?: DecelerationRateType | undefined;
  disableIntervalMomentum?: boolean | undefined;
  experimental_endDraggingSensitivityMultiplier?: number | undefined;
  horizontal?: boolean | undefined;
  innerViewRef?: React.Ref<InnerViewInstance>;
  invertStickyHeaders?: boolean | undefined;
  keyboardDismissMode?: ("interactive" | "none" | "on-drag") | undefined;
  keyboardShouldPersistTaps?:
    | ("always" | "handled" | "never" | false | true)
    | undefined;
  maintainVisibleContentPosition?:
    | Readonly<{
        autoscrollToTopThreshold?: number | undefined;
        minIndexForVisible: number;
      }>
    | undefined;
  onMomentumScrollBegin?: ((event: ScrollEvent) => void) | undefined;
  onMomentumScrollEnd?: ((event: ScrollEvent) => void) | undefined;
  onScroll?: ((event: ScrollEvent) => void) | undefined;
  onScrollBeginDrag?: ((event: ScrollEvent) => void) | undefined;
  onScrollEndDrag?: ((event: ScrollEvent) => void) | undefined;
  pagingEnabled?: boolean | undefined;
  refreshControl?: React.JSX.Element | undefined;
  removeClippedSubviews?: boolean | undefined;
  scrollEnabled?: boolean | undefined;
  scrollEventThrottle?: number | undefined;
  scrollViewRef?: React.Ref<PublicScrollViewInstance>;
  showsVerticalScrollIndicator?: boolean | undefined;
  snapToAlignment?: ("center" | "end" | "start") | undefined;
  snapToEnd?: boolean | undefined;
  snapToInterval?: number | undefined;
  snapToOffsets?: ReadonlyArray<number> | undefined;
  snapToStart?: boolean | undefined;
  StickyHeaderComponent?: StickyHeaderComponentType;
  stickyHeaderHiddenOnScroll?: boolean | undefined;
  stickyHeaderIndices?: ReadonlyArray<number> | undefined;
  onContentSizeChange?: (contentWidth: number, contentHeight: number) => void;
  onKeyboardDidHide?: (event: KeyboardEvent) => void;
  onKeyboardDidShow?: (event: KeyboardEvent) => void;
  onKeyboardWillHide?: (event: KeyboardEvent) => void;
  onKeyboardWillShow?: (event: KeyboardEvent) => void;
}>;
declare type ScrollViewComponentStatics = Readonly<{
  Context: typeof $$ScrollViewContext;
}>;
declare const ScrollViewContext: React.Context<Value>;
declare interface ScrollViewImperativeMethods {
  readonly flashScrollIndicators: () => void;
  readonly getInnerViewNode: () => number | undefined;
  readonly getInnerViewRef: () => InnerViewInstance | null;
  readonly getNativeScrollRef: () => HostInstance | null;
  readonly getScrollableNode: () => number | undefined;
  readonly getScrollResponder: () => ScrollResponderType;
  readonly scrollResponderScrollNativeHandleToKeyboard: (
    nodeHandle: HostInstance | number,
    additionalOffset?: number,
    preventNegativeScrollOffset?: boolean
  ) => void;
  readonly scrollResponderZoomTo: (
    rect: {
      animated?: boolean;
      height: number;
      width: number;
      x: number;
      y: number;
    },
    animated?: boolean
  ) => void;
  readonly scrollTo: (
    options?: number | ScrollViewScrollToOptions,
    deprecatedX?: number,
    deprecatedAnimated?: boolean
  ) => void;
  readonly scrollToEnd: (
    options?: ScrollViewScrollToOptions | undefined
  ) => void;
}
declare type ScrollViewNativeComponent = typeof $$ScrollViewNativeComponent;
declare const ScrollViewNativeComponent_default: HostComponent<ScrollViewNativeProps>;
declare type ScrollViewNativeProps = Readonly<
  Omit<
    ViewProps,
    keyof {
      alwaysBounceHorizontal?: boolean | undefined;
      alwaysBounceVertical?: boolean | undefined;
      automaticallyAdjustContentInsets?: boolean | undefined;
      automaticallyAdjustKeyboardInsets?: boolean | undefined;
      automaticallyAdjustsScrollIndicatorInsets?: boolean | undefined;
      bounces?: boolean | undefined;
      bouncesZoom?: boolean | undefined;
      canCancelContentTouches?: boolean | undefined;
      centerContent?: boolean | undefined;
      contentInset?: EdgeInsetsProp | undefined;
      contentInsetAdjustmentBehavior?:
        | ("always" | "automatic" | "never" | "scrollableAxes")
        | undefined;
      contentOffset?: PointProp | undefined;
      decelerationRate?: ("fast" | "normal" | number) | undefined;
      directionalLockEnabled?: boolean | undefined;
      disableIntervalMomentum?: boolean | undefined;
      endFillColor?: ColorValue | undefined;
      fadingEdgeLength?:
        | (number | undefined)
        | {
            end: number;
            start: number;
          };
      indicatorStyle?: ("black" | "default" | "white") | undefined;
      isInvertedVirtualizedList?: boolean | undefined;
      keyboardDismissMode?: ("interactive" | "none" | "on-drag") | undefined;
      maintainVisibleContentPosition?:
        | Readonly<{
            autoscrollToTopThreshold?: number | undefined;
            minIndexForVisible: number;
          }>
        | undefined;
      maximumZoomScale?: number | undefined;
      minimumZoomScale?: number | undefined;
      nestedScrollEnabled?: boolean | undefined;
      onMomentumScrollBegin?: ((event: ScrollEvent) => void) | undefined;
      onMomentumScrollEnd?: ((event: ScrollEvent) => void) | undefined;
      onResponderGrant?:
        | ((e: GestureResponderEvent) => boolean | void)
        | undefined;
      onScroll?: ((event: ScrollEvent) => void) | undefined;
      onScrollBeginDrag?: ((event: ScrollEvent) => void) | undefined;
      onScrollEndDrag?: ((event: ScrollEvent) => void) | undefined;
      overScrollMode?: ("always" | "auto" | "never") | undefined;
      pagingEnabled?: boolean | undefined;
      persistentScrollbar?: boolean | undefined;
      pinchGestureEnabled?: boolean | undefined;
      scrollEnabled?: boolean | undefined;
      scrollEventThrottle?: number | undefined;
      scrollIndicatorInsets?: EdgeInsetsProp | undefined;
      scrollPerfTag?: string | undefined;
      scrollsToTop?: boolean | undefined;
      scrollToOverflowEnabled?: boolean | undefined;
      sendMomentumEvents?: boolean | undefined;
      showsHorizontalScrollIndicator?: boolean | undefined;
      showsVerticalScrollIndicator?: boolean | undefined;
      snapToAlignment?: ("center" | "end" | "start") | undefined;
      snapToEnd?: boolean | undefined;
      snapToInterval?: number | undefined;
      snapToOffsets?: ReadonlyArray<number> | undefined;
      snapToStart?: boolean | undefined;
      zoomScale?: number | undefined;
      onScrollToTop?: (event: ScrollEvent) => void;
    }
  > & {
    alwaysBounceHorizontal?: boolean | undefined;
    alwaysBounceVertical?: boolean | undefined;
    automaticallyAdjustContentInsets?: boolean | undefined;
    automaticallyAdjustKeyboardInsets?: boolean | undefined;
    automaticallyAdjustsScrollIndicatorInsets?: boolean | undefined;
    bounces?: boolean | undefined;
    bouncesZoom?: boolean | undefined;
    canCancelContentTouches?: boolean | undefined;
    centerContent?: boolean | undefined;
    contentInset?: EdgeInsetsProp | undefined;
    contentInsetAdjustmentBehavior?:
      | ("always" | "automatic" | "never" | "scrollableAxes")
      | undefined;
    contentOffset?: PointProp | undefined;
    decelerationRate?: ("fast" | "normal" | number) | undefined;
    directionalLockEnabled?: boolean | undefined;
    disableIntervalMomentum?: boolean | undefined;
    endFillColor?: ColorValue | undefined;
    fadingEdgeLength?:
      | (number | undefined)
      | {
          end: number;
          start: number;
        };
    indicatorStyle?: ("black" | "default" | "white") | undefined;
    isInvertedVirtualizedList?: boolean | undefined;
    keyboardDismissMode?: ("interactive" | "none" | "on-drag") | undefined;
    maintainVisibleContentPosition?:
      | Readonly<{
          autoscrollToTopThreshold?: number | undefined;
          minIndexForVisible: number;
        }>
      | undefined;
    maximumZoomScale?: number | undefined;
    minimumZoomScale?: number | undefined;
    nestedScrollEnabled?: boolean | undefined;
    onMomentumScrollBegin?: ((event: ScrollEvent) => void) | undefined;
    onMomentumScrollEnd?: ((event: ScrollEvent) => void) | undefined;
    onResponderGrant?:
      | ((e: GestureResponderEvent) => boolean | void)
      | undefined;
    onScroll?: ((event: ScrollEvent) => void) | undefined;
    onScrollBeginDrag?: ((event: ScrollEvent) => void) | undefined;
    onScrollEndDrag?: ((event: ScrollEvent) => void) | undefined;
    overScrollMode?: ("always" | "auto" | "never") | undefined;
    pagingEnabled?: boolean | undefined;
    persistentScrollbar?: boolean | undefined;
    pinchGestureEnabled?: boolean | undefined;
    scrollEnabled?: boolean | undefined;
    scrollEventThrottle?: number | undefined;
    scrollIndicatorInsets?: EdgeInsetsProp | undefined;
    scrollPerfTag?: string | undefined;
    scrollsToTop?: boolean | undefined;
    scrollToOverflowEnabled?: boolean | undefined;
    sendMomentumEvents?: boolean | undefined;
    showsHorizontalScrollIndicator?: boolean | undefined;
    showsVerticalScrollIndicator?: boolean | undefined;
    snapToAlignment?: ("center" | "end" | "start") | undefined;
    snapToEnd?: boolean | undefined;
    snapToInterval?: number | undefined;
    snapToOffsets?: ReadonlyArray<number> | undefined;
    snapToStart?: boolean | undefined;
    zoomScale?: number | undefined;
    onScrollToTop?: (event: ScrollEvent) => void;
  }
>;
declare interface ScrollViewScrollToOptions {
  animated?: boolean;
  x?: number;
  y?: number;
}
declare type ScrollViewStickyHeaderProps = Readonly<{
  children?: React.ReactNode;
  hiddenOnScroll?: boolean | undefined;
  inverted: boolean | undefined;
  nativeID?: string | undefined;
  nextHeaderLayoutY: number | undefined;
  scrollAnimatedValue: Animated.Value;
  scrollViewHeight: number | undefined;
  onLayout: (event: LayoutChangeEvent) => void;
}>;
declare const ScrollViewWrapper: (
  props: Omit<
    ScrollViewProps,
    keyof {
      ref?: React.Ref<PublicScrollViewInstance>;
    }
  > & {
    ref?: React.Ref<PublicScrollViewInstance>;
  }
) => React.ReactNode;
declare type Selection = Readonly<{
  end: number;
  start: number;
}>;
declare const sequence: (
  animations: Array<CompositeAnimation>
) => CompositeAnimation;
declare const sequence_2: typeof $$AnimatedImplementation.sequence;
declare type sequence_2 = typeof sequence_2;
declare function setColorScheme(
  colorScheme: ColorSchemeName | null | undefined
): void;
declare function setComponentProviderInstrumentationHook(
  hook: ComponentProviderInstrumentationHook
): void;
declare function setEnabled(value: boolean): void;
declare function setEnabled_2(_doEnable: boolean): void;
declare function setRootViewStyleProvider(
  provider: RootViewStyleProvider
): void;
declare const setStyleAttributePreprocessor: (
  property: string,
  process: (nextProp: any) => any
) => void;
declare type setStyleAttributePreprocessor =
  typeof setStyleAttributePreprocessor;
declare function setSurfaceProps(
  appKey: string,
  appParameters: Object,
  displayMode?: number
): void;
declare let Settings_2: {
  clearWatch(watchId: number): void;
  get(key: string): any;
  set(settings: Object): void;
  watchKeys(keys: Array<string> | string, callback: () => void): number;
};
declare function setWrapperComponentProvider(
  provider: WrapperComponentProvider
): void;
declare interface Spec extends TurboModule {
  readonly getConstants: () => {
    readonly buttonClicked: DialogAction;
    readonly buttonNegative: DialogButtonKey;
    readonly buttonNeutral: DialogButtonKey;
    readonly buttonPositive: DialogButtonKey;
    readonly dismissed: DialogAction;
  };
  readonly showAlert: (
    config: DialogOptions,
    onError: (error: string) => void,
    onAction: (action: DialogAction, buttonKey?: DialogButtonKey) => void
  ) => void;
}
declare interface Spec_2 extends TurboModule {
  readonly blur?: (reactTag: number) => void;
  readonly clearJSResponder: () => void;
  readonly configureNextLayoutAnimation: (
    config: Object,
    callback: () => void,
    errorCallback: (error: Object) => void
  ) => void;
  readonly createView: (
    reactTag: number,
    viewName: string,
    rootTag: RootTag,
    props: Object
  ) => void;
  readonly dispatchViewManagerCommand: (
    reactTag: number,
    commandID: number,
    commandArgs?: Array<any>
  ) => void;
  readonly findSubviewIn: (
    reactTag: number,
    point: Array<number>,
    callback: (
      nativeViewTag: number,
      left: number,
      top: number,
      width: number,
      height: number
    ) => void
  ) => void;
  readonly focus?: (reactTag: number) => void;
  readonly getConstants: () => Object;
  readonly getConstantsForViewManager?: (
    viewManagerName: string
  ) => Object | undefined;
  readonly getDefaultEventTypes?: () => Array<string>;
  readonly lazilyLoadView?: (name: string) => Object;
  readonly manageChildren: (
    containerTag: number,
    moveFromIndices: Array<number>,
    moveToIndices: Array<number>,
    addChildReactTags: Array<number>,
    addAtIndices: Array<number>,
    removeAtIndices: Array<number>
  ) => void;
  readonly measure: (
    reactTag: number,
    callback: MeasureOnSuccessCallback_2
  ) => void;
  readonly measureInWindow: (
    reactTag: number,
    callback: MeasureInWindowOnSuccessCallback_2
  ) => void;
  readonly measureLayout: (
    reactTag: number,
    ancestorReactTag: number,
    errorCallback: (error: Object) => void,
    callback: MeasureLayoutOnSuccessCallback_2
  ) => void;
  readonly measureLayoutRelativeToParent: (
    reactTag: number,
    errorCallback: (error: Object) => void,
    callback: (left: number, top: number, width: number, height: number) => void
  ) => void;
  readonly sendAccessibilityEvent?: (
    reactTag: number,
    eventType: number
  ) => void;
  readonly setChildren: (
    containerTag: number,
    reactTags: Array<number>
  ) => void;
  readonly setJSResponder: (
    reactTag: number,
    blockNativeResponder: boolean
  ) => void;
  readonly setLayoutAnimationEnabledExperimental?: (enabled: boolean) => void;
  readonly updateView: (
    reactTag: number,
    viewName: string,
    props: Object
  ) => void;
  readonly viewIsDescendantOf: (
    reactTag: number,
    ancestorReactTag: number,
    callback: (result: Array<boolean>) => void
  ) => void;
}
declare const spring: (
  value: AnimatedColor | AnimatedValue | AnimatedValueXY,
  config: SpringAnimationConfig
) => CompositeAnimation;
declare const spring_2: typeof $$AnimatedImplementation.spring;
declare type spring_2 = typeof spring_2;
declare type SpringAnimationConfig = Readonly<
  Omit<
    AnimationConfig,
    keyof {
      bounciness?: number;
      damping?: number;
      delay?: number;
      friction?: number;
      mass?: number;
      overshootClamping?: boolean;
      restDisplacementThreshold?: number;
      restSpeedThreshold?: number;
      speed?: number;
      stiffness?: number;
      tension?: number;
      toValue:
        | AnimatedColor
        | AnimatedInterpolation<number>
        | AnimatedValue
        | AnimatedValueXY
        | number
        | {
            a: number;
            b: number;
            g: number;
            r: number;
          }
        | {
            x: number;
            y: number;
          };
      velocity?:
        | number
        | Readonly<{
            x: number;
            y: number;
          }>;
    }
  > & {
    bounciness?: number;
    damping?: number;
    delay?: number;
    friction?: number;
    mass?: number;
    overshootClamping?: boolean;
    restDisplacementThreshold?: number;
    restSpeedThreshold?: number;
    speed?: number;
    stiffness?: number;
    tension?: number;
    toValue:
      | AnimatedColor
      | AnimatedInterpolation<number>
      | AnimatedValue
      | AnimatedValueXY
      | number
      | {
          a: number;
          b: number;
          g: number;
          r: number;
        }
      | {
          x: number;
          y: number;
        };
    velocity?:
      | number
      | Readonly<{
          x: number;
          y: number;
        }>;
  }
>;
declare type StackFrame = {
  collapse?: boolean;
  column: number | undefined;
  file: string | undefined;
  lineNumber: number | undefined;
  methodName: string;
};
declare type StackProps = {
  backgroundColor:
    | undefined
    | {
        animated: boolean;
        value: StatusBarProps["backgroundColor"];
      };
  barStyle:
    | undefined
    | {
        animated: boolean;
        value: StatusBarProps["barStyle"];
      };
  hidden:
    | undefined
    | {
        animated: boolean;
        transition: StatusBarProps["showHideTransition"];
        value: boolean;
      };
  networkActivityIndicatorVisible: StatusBarProps["networkActivityIndicatorVisible"];
  translucent: StatusBarProps["translucent"];
};
declare const stagger: (
  time: number,
  animations: Array<CompositeAnimation>
) => CompositeAnimation;
declare const stagger_2: typeof $$AnimatedImplementation.stagger;
declare type stagger_2 = typeof stagger_2;
declare function startHeadlessTask(
  taskId: number,
  taskKey: string,
  data: any
): void;
declare type State = {
  cellsAroundViewport: {
    first: number;
    last: number;
  };
  firstVisibleItemKey: string | undefined;
  pendingScrollUpdateCount: number;
  renderMask: CellRenderMask;
};
declare const States: {
  ERROR: "ERROR";
  NOT_RESPONDER: "NOT_RESPONDER";
  RESPONDER_ACTIVE_LONG_PRESS_IN: "RESPONDER_ACTIVE_LONG_PRESS_IN";
  RESPONDER_ACTIVE_LONG_PRESS_OUT: "RESPONDER_ACTIVE_LONG_PRESS_OUT";
  RESPONDER_ACTIVE_PRESS_IN: "RESPONDER_ACTIVE_PRESS_IN";
  RESPONDER_ACTIVE_PRESS_OUT: "RESPONDER_ACTIVE_PRESS_OUT";
  RESPONDER_INACTIVE_PRESS_IN: "RESPONDER_INACTIVE_PRESS_IN";
  RESPONDER_INACTIVE_PRESS_OUT: "RESPONDER_INACTIVE_PRESS_OUT";
};
declare class StateSafePureComponent<
  Props,
  State extends {}
> extends React.PureComponent<Props, State> {
  constructor(props: Props);
  setState<K extends keyof State>(
    partialState:
      | (
          | ((
              $$PARAM_0$$: State,
              $$PARAM_1$$: Props
            ) => null | Pick<State, K> | undefined)
          | Pick<State, K>
        )
      | null
      | undefined,
    callback?: () => unknown
  ): void;
}
declare type StatusBarBaseProps = Readonly<{
  animated?: boolean | undefined;
  barStyle?: ("dark-content" | "default" | "light-content") | undefined;
  hidden?: boolean | undefined;
}>;
declare type StatusBarPropsAndroid = Readonly<{
  backgroundColor?: ColorValue | undefined;
  translucent?: boolean | undefined;
}>;
declare type StatusBarPropsIOS = Readonly<{
  networkActivityIndicatorVisible?: boolean | undefined;
  showHideTransition?: ("fade" | "none" | "slide") | undefined;
}>;
declare type StickyHeaderComponentType = (
  props: Omit<
    ScrollViewStickyHeaderProps,
    keyof {
      ref?: React.Ref<
        Readonly<{
          setNextHeaderY: ($$PARAM_0$$: number) => void;
        }>
      >;
    }
  > & {
    ref?: React.Ref<
      Readonly<{
        setNextHeaderY: ($$PARAM_0$$: number) => void;
      }>
    >;
  }
) => React.ReactNode;
declare const subtract: (
  a: AnimatedNode | number,
  b: AnimatedNode | number
) => AnimatedSubtraction;
declare const subtract_2: typeof $$AnimatedImplementation.subtract;
declare type subtract_2 = typeof subtract_2;
declare const Switch_2: (
  props: Omit<
    SwitchProps,
    keyof {
      ref?: React.Ref<SwitchRef>;
    }
  > & {
    ref?: React.Ref<SwitchRef>;
  }
) => React.ReactNode;
declare type SwitchChangeEvent_2 = Readonly<{
  target: Int32;
  value: boolean;
}>;
declare type SwitchChangeEvent_3 = Readonly<{
  target: Int32;
  value: boolean;
}>;
declare type SwitchChangeEventData = Readonly<{
  target: number;
  value: boolean;
}>;
declare type SwitchPropsBase = {
  disabled?: boolean | undefined;
  ios_backgroundColor?: ColorValue | undefined;
  onChange?: ((event: SwitchChangeEvent) => Promise<void> | void) | undefined;
  onValueChange?: ((value: boolean) => Promise<void> | void) | undefined;
  thumbColor?: ColorValue | undefined;
  trackColor?:
    | Readonly<{
        false?: ColorValue | undefined;
        true?: ColorValue | undefined;
      }>
    | undefined;
  value?: boolean | undefined;
};
declare type SwitchPropsIOS = {
  onTintColor?: ColorValue | undefined;
  thumbTintColor?: ColorValue | undefined;
  tintColor?: ColorValue | undefined;
};
declare type SwitchRef = React.ComponentRef<
  typeof $$AndroidSwitchNativeComponent | typeof $$SwitchNativeComponent
>;
declare type TargetEvent = Readonly<{
  target: number;
}>;
declare type Task = (taskData: any) => Promise<void>;
declare type Task_2 = (() => void) | PromiseTask | SimpleTask;
declare type TaskCanceller = () => void;
declare type TaskCancelProvider = () => TaskCanceller;
declare type TBackHandler = {
  addEventListener(
    eventName: BackPressEventName,
    handler: () => boolean | undefined
  ): {
    remove: () => void;
  };
  exitApp(): void;
};
declare type TextBaseProps = Readonly<{
  allowFontScaling?: boolean | undefined;
  android_hyphenationFrequency?: ("full" | "none" | "normal") | undefined;
  children?: React.ReactNode | undefined;
  ellipsizeMode?: ("clip" | "head" | "middle" | "tail") | undefined;
  id?: string;
  maxFontSizeMultiplier?: number | undefined;
  nativeID?: string | undefined;
  numberOfLines?: number | undefined;
  onAccessibilityAction?:
    | ((event: AccessibilityActionEvent) => unknown)
    | undefined;
  onLayout?: ((event: LayoutChangeEvent) => unknown) | undefined;
  onLongPress?: ((event: GestureResponderEvent) => unknown) | undefined;
  onMoveShouldSetResponder?: (() => boolean) | undefined;
  onPress?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPressIn?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPressOut?: ((event: GestureResponderEvent) => unknown) | undefined;
  onResponderGrant?: ((event: GestureResponderEvent) => void) | undefined;
  onResponderMove?: ((event: GestureResponderEvent) => void) | undefined;
  onResponderRelease?: ((event: GestureResponderEvent) => void) | undefined;
  onResponderTerminate?: ((event: GestureResponderEvent) => void) | undefined;
  onResponderTerminationRequest?: (() => boolean) | undefined;
  onStartShouldSetResponder?: (() => boolean) | undefined;
  onTextLayout?: ((event: TextLayoutEvent) => unknown) | undefined;
  pressRetentionOffset?: PressRetentionOffset | undefined;
  role?: Role | undefined;
  selectable?: boolean | undefined;
  style?: TextStyleProp | undefined;
  testID?: string | undefined;
}>;
declare type TextForwardRef = React.ComponentRef<
  typeof NativeText | typeof NativeVirtualText
>;
declare const TextImpl: (
  props: Omit<
    TextProps,
    keyof {
      ref?: React.Ref<TextForwardRef>;
    }
  > & {
    ref?: React.Ref<TextForwardRef>;
  }
) => React.ReactNode;
declare const TextInlineImage: HostComponent<NativeProps>;
declare type TextInlineImageNativeComponent =
  typeof $$TextInlineImageNativeComponent;
declare type TextInputBaseProps = Readonly<{
  allowFontScaling?: boolean | undefined;
  autoCapitalize?: AutoCapitalize | undefined;
  autoComplete?:
    | (
        | "additional-name"
        | "address-line1"
        | "address-line2"
        | "birthdate-day"
        | "birthdate-full"
        | "birthdate-month"
        | "birthdate-year"
        | "cc-csc"
        | "cc-exp-day"
        | "cc-exp-month"
        | "cc-exp-year"
        | "cc-exp"
        | "cc-family-name"
        | "cc-given-name"
        | "cc-middle-name"
        | "cc-name"
        | "cc-number"
        | "cc-type"
        | "country"
        | "current-password"
        | "email"
        | "family-name"
        | "gender"
        | "given-name"
        | "honorific-prefix"
        | "honorific-suffix"
        | "name-family"
        | "name-given"
        | "name-middle-initial"
        | "name-middle"
        | "name-prefix"
        | "name-suffix"
        | "name"
        | "new-password"
        | "nickname"
        | "off"
        | "one-time-code"
        | "organization-title"
        | "organization"
        | "password-new"
        | "password"
        | "postal-address-country"
        | "postal-address-extended-postal-code"
        | "postal-address-extended"
        | "postal-address-locality"
        | "postal-address-region"
        | "postal-address"
        | "postal-code"
        | "sms-otp"
        | "street-address"
        | "tel-country-code"
        | "tel-device"
        | "tel-national"
        | "tel"
        | "url"
        | "username-new"
        | "username"
      )
    | undefined;
  autoCorrect?: boolean | undefined;
  autoFocus?: boolean | undefined;
  blurOnSubmit?: boolean | undefined;
  caretHidden?: boolean | undefined;
  contextMenuHidden?: boolean | undefined;
  defaultValue?: string | undefined;
  editable?: boolean | undefined;
  enterKeyHint?: EnterKeyHintTypeOptions | undefined;
  experimental_acceptDragAndDropTypes?: ReadonlyArray<string> | undefined;
  forwardedRef?: React.Ref<TextInputInstance> | undefined;
  inputMode?: InputModeOptions | undefined;
  keyboardType?: KeyboardTypeOptions | undefined;
  maxFontSizeMultiplier?: number | undefined;
  maxLength?: number | undefined;
  multiline?: boolean | undefined;
  onBlur?: ((e: TextInputBlurEvent) => unknown) | undefined;
  onChange?: ((e: TextInputChangeEvent) => unknown) | undefined;
  onChangeText?: ((text: string) => unknown) | undefined;
  onContentSizeChange?:
    | ((e: TextInputContentSizeChangeEvent) => unknown)
    | undefined;
  onEndEditing?: ((e: TextInputEndEditingEvent) => unknown) | undefined;
  onFocus?: ((e: TextInputFocusEvent) => unknown) | undefined;
  onKeyPress?: ((e: TextInputKeyPressEvent) => unknown) | undefined;
  onPress?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPressIn?: ((event: GestureResponderEvent) => unknown) | undefined;
  onPressOut?: ((event: GestureResponderEvent) => unknown) | undefined;
  onScroll?: ((e: ScrollEvent) => unknown) | undefined;
  onSelectionChange?:
    | ((e: TextInputSelectionChangeEvent) => unknown)
    | undefined;
  onSubmitEditing?: ((e: TextInputSubmitEditingEvent) => unknown) | undefined;
  placeholder?: string | undefined;
  placeholderTextColor?: ColorValue | undefined;
  readOnly?: boolean | undefined;
  returnKeyType?: ReturnKeyTypeOptions | undefined;
  secureTextEntry?: boolean | undefined;
  selection?:
    | Readonly<{
        end?: number | undefined;
        start: number;
      }>
    | undefined;
  selectionColor?: ColorValue | undefined;
  selectTextOnFocus?: boolean | undefined;
  style?: TextStyleProp | undefined;
  submitBehavior?: SubmitBehavior | undefined;
  textAlign?: ("center" | "left" | "right") | undefined;
  value?: string | undefined;
}>;
declare type TextInputBlurEvent = BlurEvent;
declare type TextInputChangeEventData = Readonly<{
  eventCount: number;
  target: number;
  text: string;
}>;
declare type TextInputComponentStatics = Readonly<{
  State: Readonly<{
    blurTextInput: (textField: HostInstance | undefined) => void;
    currentlyFocusedField: () => number | undefined;
    currentlyFocusedInput: () => HostInstance | undefined;
    focusTextInput: (textField: HostInstance | undefined) => void;
  }>;
}>;
declare type TextInputContentSizeChangeEventData = Readonly<{
  contentSize: Readonly<{
    height: number;
    width: number;
  }>;
  target: number;
}>;
declare type TextInputEndEditingEventData = Readonly<
  Omit<
    TargetEvent,
    keyof {
      eventCount: number;
      text: string;
    }
  > & {
    eventCount: number;
    text: string;
  }
>;
declare interface TextInputInstance extends HostInstance {
  readonly clear: () => void;
  readonly getNativeRef: () => HostInstance | undefined;
  readonly isFocused: () => boolean;
  readonly setSelection: (start: number, end: number) => void;
}
declare type TextInputKeyPressEventData = Readonly<
  Omit<
    TargetEvent,
    keyof {
      eventCount: number;
      key: string;
      target?: number | undefined;
    }
  > & {
    eventCount: number;
    key: string;
    target?: number | undefined;
  }
>;
declare type TextInputSelectionChangeEventData = Readonly<
  Omit<
    TargetEvent,
    keyof {
      selection: Selection;
    }
  > & {
    selection: Selection;
  }
>;
declare type TextInputSubmitEditingEventData = Readonly<
  Omit<
    TargetEvent,
    keyof {
      eventCount: number;
      text: string;
    }
  > & {
    eventCount: number;
    text: string;
  }
>;
declare type TextInputType = InternalTextInput & TextInputComponentStatics;
declare type TextLayoutEventData = Readonly<{
  lines: Array<TextLayoutLine>;
}>;
declare type TextLayoutLine = Readonly<
  Omit<
    LayoutRectangle,
    keyof {
      ascender: number;
      capHeight: number;
      descender: number;
      text: string;
      xHeight: number;
    }
  > & {
    ascender: number;
    capHeight: number;
    descender: number;
    text: string;
    xHeight: number;
  }
>;
declare type TextPropsAndroid = {
  adjustsFontSizeToFit?: boolean | undefined;
  dataDetectorType?:
    | ("all" | "email" | "link" | "none" | "phoneNumber")
    | undefined;
  disabled?: boolean | undefined;
  minimumFontScale?: number | undefined;
  selectionColor?: ColorValue | undefined;
  textBreakStrategy?: ("balanced" | "highQuality" | "simple") | undefined;
};
declare type TextPropsIOS = {
  adjustsFontSizeToFit?: boolean | undefined;
  dynamicTypeRamp?:
    | (
        | "body"
        | "callout"
        | "caption1"
        | "caption2"
        | "footnote"
        | "headline"
        | "largeTitle"
        | "subheadline"
        | "title1"
        | "title2"
        | "title3"
      )
    | undefined;
  lineBreakStrategyIOS?:
    | ("hangul-word" | "none" | "push-out" | "standard")
    | undefined;
  suppressHighlighting?: boolean | undefined;
};
declare type TextStyleProp = ____TextStyleProp_Internal;
declare type Timespan = {
  endExtras?: Extras;
  endTime?: number;
  startExtras?: Extras;
  startTime: number;
  totalTime?: number;
};
declare const timing: (
  value: AnimatedColor | AnimatedValue | AnimatedValueXY,
  config: TimingAnimationConfig
) => CompositeAnimation;
declare const timing_2: typeof $$AnimatedImplementation.timing;
declare type timing_2 = typeof timing_2;
declare type TimingAnimationConfig = Readonly<
  Omit<
    AnimationConfig,
    keyof {
      delay?: number;
      duration?: number;
      toValue:
        | AnimatedColor
        | AnimatedInterpolation<number>
        | AnimatedValue
        | AnimatedValueXY
        | number
        | Readonly<{
            x: number;
            y: number;
          }>
        | RgbaValue;
      easing?: (value: number) => number;
    }
  > & {
    delay?: number;
    duration?: number;
    toValue:
      | AnimatedColor
      | AnimatedInterpolation<number>
      | AnimatedValue
      | AnimatedValueXY
      | number
      | Readonly<{
          x: number;
          y: number;
        }>
      | RgbaValue;
    easing?: (value: number) => number;
  }
>;
declare const ToastAndroid_2: {
  BOTTOM: number;
  CENTER: number;
  LONG: number;
  SHORT: number;
  TOP: number;
  show: (message: string, duration: number) => void;
  showWithGravity: (message: string, duration: number, gravity: number) => void;
  showWithGravityAndOffset: (
    message: string,
    duration: number,
    gravity: number,
    xOffset: number,
    yOffset: number
  ) => void;
};
declare const Touchable_2:
  | typeof TouchableNativeFeedback
  | typeof TouchableOpacity;
declare const Touchable_3: (
  props: Omit<
    TouchableOpacityProps,
    keyof {
      ref?: React.Ref<React.ComponentRef<typeof Animated.View>>;
    }
  > & {
    ref?: React.Ref<React.ComponentRef<typeof Animated.View>>;
  }
) => React.ReactNode;
declare const TouchableHighlight_2: (
  props: Omit<
    Readonly<Omit<TouchableHighlightProps, "hostRef">>,
    keyof {
      ref?: React.Ref<React.ComponentRef<typeof View>>;
    }
  > & {
    ref?: React.Ref<React.ComponentRef<typeof View>>;
  }
) => React.ReactNode;
declare type TouchableHighlightBaseProps = Readonly<{
  activeOpacity?: number | undefined;
  hostRef?: React.Ref<React.ComponentRef<typeof View>>;
  onHideUnderlay?: (() => void) | undefined;
  onShowUnderlay?: (() => void) | undefined;
  style?: undefined | ViewStyleProp;
  testOnly_pressed?: boolean | undefined;
  underlayColor?: ColorValue | undefined;
}>;
declare const TouchableImpl: {
  Mixin: typeof TouchableMixinImpl;
  renderDebugView: ($$PARAM_0$$: {
    color: ColorValue;
    hitSlop?: EdgeInsetsProp;
  }) => null | React.ReactNode;
};
declare const TouchableMixinImpl: {
  withoutDefaultFocusAndBlur: {};
  componentDidMount: () => void;
  componentWillUnmount: () => void;
  touchableGetInitialState: () => {
    touchable: {
      responderID: GestureResponderEvent["currentTarget"] | undefined;
      touchState: TouchableState | undefined;
    };
  };
  touchableHandleBlur: (e: BlurEvent) => void;
  touchableHandleFocus: (e: FocusEvent) => void;
  touchableHandleResponderGrant: (e: GestureResponderEvent) => void;
  touchableHandleResponderMove: (e: GestureResponderEvent) => void;
  touchableHandleResponderRelease: (e: GestureResponderEvent) => void;
  touchableHandleResponderTerminate: (e: GestureResponderEvent) => void;
  touchableHandleResponderTerminationRequest: () => any;
  touchableHandleStartShouldSetResponder: () => any;
  touchableLongPressCancelsPress: () => boolean;
};
declare type TouchableNativeFeedbackState = Readonly<{
  pressability: Pressability;
}>;
declare type TouchableOpacityBaseProps = Readonly<{
  activeOpacity?: number | undefined;
  hostRef?: React.Ref<React.ComponentRef<typeof Animated.View>> | undefined;
  style?: Animated.WithAnimatedValue<ViewStyleProp> | undefined;
}>;
declare type TouchableState =
  | typeof States.ERROR
  | typeof States.NOT_RESPONDER
  | typeof States.RESPONDER_ACTIVE_LONG_PRESS_IN
  | typeof States.RESPONDER_ACTIVE_LONG_PRESS_OUT
  | typeof States.RESPONDER_ACTIVE_PRESS_IN
  | typeof States.RESPONDER_ACTIVE_PRESS_OUT
  | typeof States.RESPONDER_INACTIVE_PRESS_IN
  | typeof States.RESPONDER_INACTIVE_PRESS_OUT;
declare type TouchableWithoutFeedbackPropsAndroid = {
  touchSoundDisabled?: boolean | undefined;
};
declare type TouchableWithoutFeedbackPropsIOS = {};
declare type TouchEventProps = Readonly<{
  onTouchCancel?: ((e: GestureResponderEvent) => void) | undefined;
  onTouchCancelCapture?: ((e: GestureResponderEvent) => void) | undefined;
  onTouchEnd?: ((e: GestureResponderEvent) => void) | undefined;
  onTouchEndCapture?: ((e: GestureResponderEvent) => void) | undefined;
  onTouchMove?: ((e: GestureResponderEvent) => void) | undefined;
  onTouchMoveCapture?: ((e: GestureResponderEvent) => void) | undefined;
  onTouchStart?: ((e: GestureResponderEvent) => void) | undefined;
  onTouchStartCapture?: ((e: GestureResponderEvent) => void) | undefined;
}>;
declare type TVProps = {
  hasTVPreferredFocus?: boolean | undefined;
  nextFocusDown?: number | undefined;
  nextFocusForward?: number | undefined;
  nextFocusLeft?: number | undefined;
  nextFocusRight?: number | undefined;
  nextFocusUp?: number | undefined;
};
declare type TVProps_2 = Readonly<{
  hasTVPreferredFocus?: boolean | undefined;
  nextFocusDown?: number | undefined;
  nextFocusForward?: number | undefined;
  nextFocusLeft?: number | undefined;
  nextFocusRight?: number | undefined;
  nextFocusUp?: number | undefined;
}>;
declare const UIManager_2: UIManagerJSInterface;
declare interface UIManagerJSInterface extends Spec_2 {
  readonly getViewManagerConfig: (viewManagerName: string) => Object;
  readonly hasViewManagerConfig: (viewManagerName: string) => boolean;
}
declare function unforkEvent(
  event: (AnimatedEvent | null | undefined) | (Function | null | undefined),
  listener: Function
): void;
declare const unforkEvent_2: typeof $$AnimatedImplementation.unforkEvent;
declare type unforkEvent_2 = typeof unforkEvent_2;
declare function unmountApplicationComponentAtRootTag(rootTag: RootTag): void;
declare type UnsafeMixed = unknown;
declare type UnsafeObject = Object;
declare type UnsafeObject_2 = Object;
declare type UnsafeObject_3 = Object;
declare const UTFSequence_2: {
  BOM: string;
  BULLET: string;
  BULLET_SP: string;
  MDASH: string;
  MDASH_SP: string;
  MIDDOT: string;
  MIDDOT_KATAKANA: string;
  MIDDOT_SP: string;
  NBSP: string;
  NDASH: string;
  NDASH_SP: string;
  NEWLINE: string;
  PIZZA: string;
  TRIANGLE_LEFT: string;
  TRIANGLE_RIGHT: string;
};
declare type Value = null | {
  horizontal: boolean;
};
declare type ValueOfUnion<T, K> = T extends any
  ? K extends keyof T
    ? T[K]
    : never
  : never;
declare type ValueXYListenerCallback = (value: {
  x: number;
  y: number;
}) => unknown;
declare const Vibration_2: {
  cancel: () => void;
  vibrate: (pattern?: Array<number> | number, repeat?: boolean) => void;
};
declare type ViewabilityConfig = Readonly<{
  itemVisiblePercentThreshold?: number;
  minimumViewTime?: number;
  viewAreaCoveragePercentThreshold?: number;
  waitForInteraction?: boolean;
}>;
declare type ViewabilityConfigCallbackPair = {
  viewabilityConfig: ViewabilityConfig;
  onViewableItemsChanged: (info: {
    changed: Array<ViewToken>;
    viewableItems: Array<ViewToken>;
  }) => void;
};
declare type ViewabilityHelper = typeof ViewabilityHelper_2;
declare class ViewabilityHelper_2 {
  computeViewableItems(
    props: CellMetricProps,
    scrollOffset: number,
    viewportHeight: number,
    listMetrics: ListMetricsAggregator,
    renderRange?: {
      first: number;
      last: number;
    }
  ): Array<number>;
  constructor(config?: ViewabilityConfig);
  dispose(): void;
  onUpdate(
    props: CellMetricProps,
    scrollOffset: number,
    viewportHeight: number,
    listMetrics: ListMetricsAggregator,
    createViewToken: (
      index: number,
      isViewable: boolean,
      props: CellMetricProps
    ) => ViewToken,
    onViewableItemsChanged: ($$PARAM_0$$: {
      changed: Array<ViewToken>;
      viewableItems: Array<ViewToken>;
    }) => void,
    renderRange?: {
      first: number;
      last: number;
    }
  ): void;
  recordInteraction(): void;
  resetViewableIndices(): void;
}
declare type ViewBaseProps = Readonly<{
  children?: React.ReactNode;
  collapsable?: boolean | undefined;
  collapsableChildren?: boolean | undefined;
  hitSlop?: EdgeInsetsOrSizeProp | undefined;
  id?: string;
  nativeID?: string | undefined;
  needsOffscreenAlphaCompositing?: boolean | undefined;
  pointerEvents?: ("auto" | "box-none" | "box-only" | "none") | undefined;
  removeClippedSubviews?: boolean | undefined;
  style?: undefined | ViewStyleProp;
  testID?: string | undefined;
}>;
declare type ViewConfig = Readonly<{
  baseModuleName?: string | undefined;
  bubblingEventTypes?: Readonly<{
    [eventName: string]: Readonly<{
      phasedRegistrationNames: Readonly<{
        bubbled: string;
        captured: string;
        skipBubbling?: boolean | undefined;
      }>;
    }>;
  }>;
  Commands?: Readonly<{
    [commandName: string]: number;
  }>;
  Constants?: Readonly<{
    [name: string]: unknown;
  }>;
  directEventTypes?: Readonly<{
    [eventName: string]: Readonly<{
      registrationName: string;
    }>;
  }>;
  Manager?: string;
  NativeProps?: Readonly<{
    [propName: string]: string;
  }>;
  supportsRawText?: boolean;
  uiViewClassName: string;
  validAttributes: AttributeConfiguration;
}>;
declare const ViewNativeComponent: HostComponent<ViewProps>;
declare type ViewStyleProp = ____ViewStyleProp_Internal;
declare type ViewStyleProp_2 = React.JSX.LibraryManagedAttributes<
  typeof View,
  React.ComponentProps<typeof View>
>["style"];
declare type ViewToken = {
  index: number | undefined;
  isViewable: boolean;
  item: any;
  key: string;
  section?: any;
};
declare const VirtualizedList_2: typeof $$index.VirtualizedList;
declare type VirtualizedList_3 = typeof VirtualizedList_4;
declare class VirtualizedList_4 extends StateSafePureComponent<
  VirtualizedListProps,
  State
> {
  static contextType: typeof VirtualizedListContext;
  state: State;
  componentDidMount(): void;
  componentDidUpdate(prevProps: VirtualizedListProps): void;
  componentWillUnmount(): void;
  constructor(props: VirtualizedListProps);
  flashScrollIndicators(): void;
  static getDerivedStateFromProps(
    newProps: VirtualizedListProps,
    prevState: State
  ): State;
  getScrollableNode(): null | number | undefined;
  getScrollRef(): null | React.ComponentRef<typeof ScrollView> | undefined;
  getScrollResponder(): null | ScrollResponderType | undefined;
  hasMore(): boolean;
  measureLayoutRelativeToContainingList(): void;
  recordInteraction(): void;
  render(): React.ReactNode;
  scrollToEnd(
    params?:
      | null
      | undefined
      | {
          animated?: boolean | undefined;
        }
  ): void;
  scrollToIndex(params: {
    animated?: boolean | undefined;
    index: number;
    viewOffset?: number;
    viewPosition?: number;
  }): any;
  scrollToItem(params: {
    animated?: boolean | undefined;
    item: Item;
    viewOffset?: number;
    viewPosition?: number;
  }): void;
  scrollToOffset(params: {
    animated?: boolean | undefined;
    offset: number;
  }): void;
  setNativeProps(props: Object): void;
  unstable_onMomentumScrollBegin(e: ScrollEvent): void;
  unstable_onMomentumScrollEnd(e: ScrollEvent): void;
  unstable_onScroll(e: Object): void;
  unstable_onScrollBeginDrag(e: ScrollEvent): void;
  unstable_onScrollEndDrag(e: ScrollEvent): void;
}
declare type VirtualizedList_5 = typeof VirtualizedList_4;
declare const VirtualizedList_6: VirtualizedListType;
declare const VirtualizedListContext: React.Context<Context | null | undefined>;
declare type VirtualizedListContext = typeof VirtualizedListContext;
declare type VirtualizedListContextResetter =
  typeof VirtualizedListContextResetter_2;
declare function VirtualizedListContextResetter_2($$PARAM_0$$: {
  children: React.ReactNode;
}): React.ReactNode;
declare type VirtualizedListProps_2 = React.JSX.LibraryManagedAttributes<
  typeof VirtualizedList_2,
  React.ComponentProps<typeof VirtualizedList_2>
>;
declare type VirtualizedListType = typeof $$index.VirtualizedList;
declare const VirtualizedSectionList_2: VirtualizedSectionListType;
declare const VirtualizedSectionListComponent: <
  ItemT,
  SectionT extends SectionBase<ItemT, DefaultSectionT> = DefaultSectionT
>(
  props: Omit<
    VirtualizedSectionListProps<ItemT, SectionT>,
    keyof {
      ref: React.Ref<{
        getListRef(): undefined | VirtualizedList_4;
        scrollToLocation(params: ScrollToLocationParamsType): void;
      }>;
    }
  > & {
    ref: React.Ref<{
      getListRef(): undefined | VirtualizedList_4;
      scrollToLocation(params: ScrollToLocationParamsType): void;
    }>;
  }
) => React.ReactNode;
declare type VirtualizedSectionListType = typeof $$index.VirtualizedSectionList;
declare type WebPlatform = {
  OS: "web";
  select: <T>(spec: PlatformSelectSpec<T>) => T;
  get constants(): {
    reactNativeVersion: {
      major: number;
      minor: number;
      patch: number;
      prerelease: string | undefined;
    };
  };
  get isDisableAnimations(): boolean;
  get isTesting(): boolean;
  get isTV(): boolean;
  get Version(): void;
};
declare type WindowsPlatform = {
  OS: "windows";
  select: <T>(spec: PlatformSelectSpec<T>) => T;
  get constants(): {
    isDisableAnimations?: boolean;
    isTesting: boolean;
    osVersion: number;
    reactNativeVersion: {
      major: number;
      minor: number;
      patch: number;
      prerelease: string | undefined;
    };
    reactNativeWindowsVersion: {
      major: number;
      minor: number;
      patch: number;
    };
  };
  get isDisableAnimations(): boolean;
  get isTesting(): boolean;
  get isTV(): boolean;
  get Version(): number;
};
declare type WithAnimatedValue<T> = T extends Builtin | Nullable
  ? T
  : T extends Primitive
  ?
      | AnimatedAddition
      | AnimatedDiffClamp
      | AnimatedDivision
      | AnimatedInterpolation<number | string>
      | AnimatedInterpolation<number>
      | AnimatedInterpolation<string>
      | AnimatedModulo
      | AnimatedMultiplication
      | AnimatedNode
      | AnimatedSubtraction
      | AnimatedValue
      | T
  : T extends ReadonlyArray<infer P>
  ? ReadonlyArray<WithAnimatedValue<P>>
  : T extends {}
  ? { readonly [K in keyof T]: WithAnimatedValue<T[K]> }
  : T;
declare type WithDefault<
  Type extends DefaultTypes,
  Value extends (null | Type | undefined) | string
> = null | Type | undefined;
declare function Wrapper(
  $$PARAM_0$$: Omit<ModalRefProps, keyof {} | keyof ModalProps> &
    Omit<ModalProps, keyof {}> & {}
): React.ReactNode;


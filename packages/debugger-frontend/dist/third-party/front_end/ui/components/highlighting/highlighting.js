var t={cssText:`:root::highlight(search-highlight){background-color:var(--sys-color-yellow-outline)}\n/*# sourceURL=${import.meta.resolve("./highlighting.css")} */\n`};const e=new CSSStyleSheet;e.replaceSync(t.cssText);class i{root;#t=0;#e;#i;constructor(t){this.root=t,this.#e=document.createTreeWalker(t,NodeFilter.SHOW_TEXT),this.#i=!this.#e.firstChild()}#h(){return this.#t+=this.#e.currentNode.textContent?.length??0,this.#i=!this.#e.nextNode(),!this.#i}#r(t){if(t<this.#t||this.#i)return null;for(;t>this.#t+(this.#e.currentNode.textContent?.length??0);)if(!this.#h())return null;return this.#e.currentNode}nextRange(t,e){if(e<=0||this.#i)return null;const i=this.#r(t);if(!i)return null;const h=t-this.#t,r=this.#r(t+e);if(!r)return null;const s=t+e-this.#t,o=new Range;return o.setStart(i,h),o.setEnd(r,s),o}}const h="search-highlight";let r;class s{#s=new Highlight;constructor(){document.adoptedStyleSheets.push(e),CSS.highlights.set(h,this.#s)}static instance(t={forceNew:null}){const{forceNew:e}=t;return r&&!e||(r=new s),r}addHighlights(t){t.forEach(this.addHighlight.bind(this))}removeHighlights(t){t.forEach(this.removeHighlight.bind(this))}addHighlight(t){this.#s.add(t)}removeHighlight(t){this.#s.delete(t)}highlightOrderedTextRanges(t,e){const h=new i(t),r=e.map((t=>h.nextRange(t.offset,t.length))).filter((t=>null!==t&&!t.collapsed));return this.addHighlights(r),r}}var o=Object.freeze({__proto__:null,HIGHLIGHT_REGISTRY:h,HighlightManager:s,RangeWalker:i});export{o as HighlightManager};

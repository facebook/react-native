import*as e from"../../models/heap_snapshot_model/heap_snapshot_model.js";import*as t from"../../core/i18n/i18n.js";import*as s from"../../core/platform/platform.js";import*as n from"../../models/text_utils/text_utils.js";class i{#e;#t;#s;#n;#i;#o;#r;constructor(e,t){this.#e=e.strings,this.#t=1,this.#s=[],this.#n={},this.#i={},this.#o={},this.#r=null,this.#a(e),this.#d(e,t)}#a(e){const t=this.#e,s=e.snapshot.meta.trace_function_info_fields,n=s.indexOf("name"),i=s.indexOf("script_name"),o=s.indexOf("script_id"),r=s.indexOf("line"),d=s.indexOf("column"),h=s.length,l=e.trace_function_infos,c=l.length,u=this.#s=new Array(c/h);let g=0;for(let e=0;e<c;e+=h)u[g++]=new a(t[l[e+n]],t[l[e+i]],l[e+o],l[e+r],l[e+d])}#d(e,t){const s=e.trace_tree,n=this.#s,i=this.#i,r=e.snapshot.meta.trace_node_fields,a=r.indexOf("id"),d=r.indexOf("function_info_index"),h=r.indexOf("count"),l=r.indexOf("size"),c=r.indexOf("children"),u=r.length;return function e(s,r,g){const p=n[s[r+d]],f=s[r+a],I=t[f],m=I?I.count:0,x=I?I.size:0,y=new o(f,p,s[r+h],s[r+l],m,x,g);i[f]=y,p.addTraceTopNode(y);const N=s[r+c];for(let t=0;t<N.length;t+=u)y.children.push(e(N,t,y));return y}(s,0,null)}serializeTraceTops(){if(this.#r)return this.#r;const e=this.#r=[],t=this.#s;for(let s=0;s<t.length;s++){const n=t[s];if(0===n.totalCount)continue;const i=this.#t++,o=0===s;e.push(this.#h(i,n,n.totalCount,n.totalSize,n.totalLiveCount,n.totalLiveSize,!o)),this.#o[i]=n}return e.sort((function(e,t){return t.size-e.size})),e}serializeCallers(t){let s=this.#l(t);const n=[];for(;1===s.callers().length;)s=s.callers()[0],n.push(this.#c(s));const i=[],o=s.callers();for(let e=0;e<o.length;e++)i.push(this.#c(o[e]));return new e.HeapSnapshotModel.AllocationNodeCallers(n,i)}serializeAllocationStack(t){let s=this.#i[t];const n=[];for(;s;){const t=s.functionInfo;n.push(new e.HeapSnapshotModel.AllocationStackFrame(t.functionName,t.scriptName,t.scriptId,t.line,t.column)),s=s.parent}return n}traceIds(e){return this.#l(e).traceTopIds}#l(e){let t=this.#n[e];if(!t){t=this.#o[e].bottomUpRoot(),delete this.#o[e],this.#n[e]=t}return t}#c(e){const t=this.#t++;return this.#n[t]=e,this.#h(t,e.functionInfo,e.allocationCount,e.allocationSize,e.liveCount,e.liveSize,e.hasCallers())}#h(t,s,n,i,o,r,a){return new e.HeapSnapshotModel.SerializedAllocationNode(t,s.functionName,s.scriptName,s.scriptId,s.line,s.column,n,i,o,r,a)}}class o{id;functionInfo;allocationCount;allocationSize;liveCount;liveSize;parent;children;constructor(e,t,s,n,i,o,r){this.id=e,this.functionInfo=t,this.allocationCount=s,this.allocationSize=n,this.liveCount=i,this.liveSize=o,this.parent=r,this.children=[]}}class r{functionInfo;allocationCount;allocationSize;liveCount;liveSize;traceTopIds;#u;constructor(e){this.functionInfo=e,this.allocationCount=0,this.allocationSize=0,this.liveCount=0,this.liveSize=0,this.traceTopIds=[],this.#u=[]}addCaller(e){const t=e.functionInfo;let s;for(let e=0;e<this.#u.length;e++){const n=this.#u[e];if(n.functionInfo===t){s=n;break}}return s||(s=new r(t),this.#u.push(s)),s}callers(){return this.#u}hasCallers(){return this.#u.length>0}}class a{functionName;scriptName;scriptId;line;column;totalCount;totalSize;totalLiveCount;totalLiveSize;#r;#g;constructor(e,t,s,n,i){this.functionName=e,this.scriptName=t,this.scriptId=s,this.line=n,this.column=i,this.totalCount=0,this.totalSize=0,this.totalLiveCount=0,this.totalLiveSize=0,this.#r=[]}addTraceTopNode(e){0!==e.allocationCount&&(this.#r.push(e),this.totalCount+=e.allocationCount,this.totalSize+=e.allocationSize,this.totalLiveCount+=e.liveCount,this.totalLiveSize+=e.liveSize)}bottomUpRoot(){return this.#r.length?(this.#g||this.#p(),this.#g):null}#p(){this.#g=new r(this);for(let e=0;e<this.#r.length;e++){let t=this.#r[e],s=this.#g;const n=t.allocationCount,i=t.allocationSize,o=t.liveCount,r=t.liveSize,a=t.id;for(;s.allocationCount+=n,s.allocationSize+=i,s.liveCount+=o,s.liveSize+=r,s.traceTopIds.push(a),t=t.parent,null!==t;)s=s.addCaller(t)}}}var d=Object.freeze({__proto__:null,AllocationProfile:i,BottomUpAllocationNode:r,FunctionAllocationInfo:a,TopDownAllocationNode:o});class h{snapshot;edges;edgeIndex;constructor(e,t){this.snapshot=e,this.edges=e.containmentEdges,this.edgeIndex=t||0}clone(){return new h(this.snapshot,this.edgeIndex)}hasStringName(){throw new Error("Not implemented")}name(){throw new Error("Not implemented")}node(){return this.snapshot.createNode(this.nodeIndex())}nodeIndex(){if(void 0===this.snapshot.edgeToNodeOffset)throw new Error("edgeToNodeOffset is undefined");return this.edges.getValue(this.edgeIndex+this.snapshot.edgeToNodeOffset)}toString(){return"HeapSnapshotEdge: "+this.name()}type(){return this.snapshot.edgeTypes[this.rawType()]}itemIndex(){return this.edgeIndex}serialize(){return new e.HeapSnapshotModel.Edge(this.name(),this.node().serialize(),this.type(),this.edgeIndex)}rawType(){if(void 0===this.snapshot.edgeTypeOffset)throw new Error("edgeTypeOffset is undefined");return this.edges.getValue(this.edgeIndex+this.snapshot.edgeTypeOffset)}isInternal(){throw new Error("Not implemented")}isInvisible(){throw new Error("Not implemented")}isWeak(){throw new Error("Not implemented")}getValueForSorting(e){throw new Error("Not implemented")}nameIndex(){throw new Error("Not implemented")}}class l{#f;constructor(e){this.#f=e.createNode()}itemForIndex(e){return this.#f.nodeIndex=e,this.#f}}class c{#I;constructor(e){this.#I=e.createEdge(0)}itemForIndex(e){return this.#I.edgeIndex=e,this.#I}}class u{#m;constructor(e){this.#m=e.createRetainingEdge(0)}itemForIndex(e){return this.#m.setRetainerIndex(e),this.#m}}class g{#x;edge;constructor(e){this.#x=e,this.edge=e.snapshot.createEdge(e.edgeIndexesStart())}hasNext(){return this.edge.edgeIndex<this.#x.edgeIndexesEnd()}item(){return this.edge}next(){if(void 0===this.edge.snapshot.edgeFieldsCount)throw new Error("edgeFieldsCount is undefined");this.edge.edgeIndex+=this.edge.snapshot.edgeFieldsCount}}class p{snapshot;#y;#N;#S;#w;#T;constructor(e,t){this.snapshot=e,this.setRetainerIndex(t)}clone(){return new p(this.snapshot,this.retainerIndex())}hasStringName(){return this.edge().hasStringName()}name(){return this.edge().name()}nameIndex(){return this.edge().nameIndex()}node(){return this.nodeInternal()}nodeIndex(){if(void 0===this.#S)throw new Error("retainingNodeIndex is undefined");return this.#S}retainerIndex(){return this.#y}setRetainerIndex(e){if(e!==this.#y){if(!this.snapshot.retainingEdges||!this.snapshot.retainingNodes)throw new Error("Snapshot does not contain retaining edges or retaining nodes");this.#y=e,this.#N=this.snapshot.retainingEdges[e],this.#S=this.snapshot.retainingNodes[e],this.#w=null,this.#T=null}}set edgeIndex(e){this.setRetainerIndex(e)}nodeInternal(){return this.#T||(this.#T=this.snapshot.createNode(this.#S)),this.#T}edge(){return this.#w||(this.#w=this.snapshot.createEdge(this.#N)),this.#w}toString(){return this.edge().toString()}itemIndex(){return this.#y}serialize(){const t=this.node(),s=t.serialize();return s.distance=this.#C(),s.ignored=this.snapshot.isNodeIgnoredInRetainersView(t.nodeIndex),new e.HeapSnapshotModel.Edge(this.name(),s,this.type(),this.#N)}type(){return this.edge().type()}isInternal(){return this.edge().isInternal()}getValueForSorting(e){if("!edgeDistance"===e)return this.#C();throw new Error("Invalid field name")}#C(){return this.snapshot.isEdgeIgnoredInRetainersView(this.#N)?e.HeapSnapshotModel.baseUnreachableDistance:this.node().distanceForRetainersView()}}class f{#O;retainer;constructor(e){const t=e.snapshot,s=e.ordinal();if(!t.firstRetainerIndex)throw new Error("Snapshot does not contain firstRetainerIndex");const n=t.firstRetainerIndex[s];this.#O=t.firstRetainerIndex[s+1],this.retainer=t.createRetainingEdge(n)}hasNext(){return this.retainer.retainerIndex()<this.#O}item(){return this.retainer}next(){this.retainer.setRetainerIndex(this.retainer.retainerIndex()+1)}}class I{snapshot;nodeIndex;constructor(e,t){this.snapshot=e,this.nodeIndex=t||0}distance(){return this.snapshot.nodeDistances[this.nodeIndex/this.snapshot.nodeFieldCount]}distanceForRetainersView(){return this.snapshot.getDistanceForRetainersView(this.nodeIndex)}className(){return this.snapshot.strings[this.classIndex()]}classIndex(){return this.#E()>>>O}classKeyInternal(){if(this.rawType()!==this.snapshot.nodeObjectType)return this.classIndex();const e=this.snapshot.getLocation(this.nodeIndex);return e?`${e.scriptId},${e.lineNumber},${e.columnNumber},${this.className()}`:this.classIndex()}setClassIndex(e){let t=this.#E();if(t&=C,t|=e<<O,this.#b(t),this.classIndex()!==e)throw new Error("String index overflow")}dominatorIndex(){const e=this.snapshot.nodeFieldCount;return this.snapshot.dominatorsTree[this.nodeIndex/this.snapshot.nodeFieldCount]*e}edges(){return new g(this)}edgesCount(){return(this.edgeIndexesEnd()-this.edgeIndexesStart())/this.snapshot.edgeFieldsCount}id(){throw new Error("Not implemented")}rawName(){return this.snapshot.strings[this.rawNameIndex()]}isRoot(){return this.nodeIndex===this.snapshot.rootNodeIndex}isUserRoot(){throw new Error("Not implemented")}isHidden(){throw new Error("Not implemented")}isArray(){throw new Error("Not implemented")}isSynthetic(){throw new Error("Not implemented")}isDocumentDOMTreesRoot(){throw new Error("Not implemented")}name(){return this.rawName()}retainedSize(){return this.snapshot.retainedSizes[this.ordinal()]}retainers(){return new f(this)}retainersCount(){const e=this.snapshot,t=this.ordinal();return e.firstRetainerIndex[t+1]-e.firstRetainerIndex[t]}selfSize(){const e=this.snapshot;return e.nodes.getValue(this.nodeIndex+e.nodeSelfSizeOffset)}type(){return this.snapshot.nodeTypes[this.rawType()]}traceNodeId(){const e=this.snapshot;return e.nodes.getValue(this.nodeIndex+e.nodeTraceNodeIdOffset)}itemIndex(){return this.nodeIndex}serialize(){return new e.HeapSnapshotModel.Node(this.id(),this.name(),this.distance(),this.nodeIndex,this.retainedSize(),this.selfSize(),this.type())}rawNameIndex(){const e=this.snapshot;return e.nodes.getValue(this.nodeIndex+e.nodeNameOffset)}edgeIndexesStart(){return this.snapshot.firstEdgeIndexes[this.ordinal()]}edgeIndexesEnd(){return this.snapshot.firstEdgeIndexes[this.ordinal()+1]}ordinal(){return this.nodeIndex/this.snapshot.nodeFieldCount}nextNodeIndex(){return this.nodeIndex+this.snapshot.nodeFieldCount}rawType(){const e=this.snapshot;return e.nodes.getValue(this.nodeIndex+e.nodeTypeOffset)}isFlatConsString(){if(this.rawType()!==this.snapshot.nodeConsStringType)return!1;for(let e=this.edges();e.hasNext();e.next()){const t=e.edge;if(!t.isInternal())continue;const s=t.name();if(("first"===s||"second"===s)&&""===t.node().name())return!0}return!1}#E(){const{snapshot:e,nodeIndex:t}=this,s=e.nodeDetachednessAndClassIndexOffset;return-1!==s?e.nodes.getValue(t+s):e.detachednessAndClassIndexArray[t/e.nodeFieldCount]}#b(e){const{snapshot:t,nodeIndex:s}=this,n=t.nodeDetachednessAndClassIndexOffset;-1!==n?t.nodes.setValue(s+n,e):t.detachednessAndClassIndexArray[s/t.nodeFieldCount]=e}detachedness(){return this.#E()&C}setDetachedness(e){let t=this.#E();t&=~C,t|=e,this.#b(t)}}class m{node;#F;constructor(e){this.node=e,this.#F=e.snapshot.nodes.length}hasNext(){return this.node.nodeIndex<this.#F}item(){return this.node}next(){this.node.nodeIndex=this.node.nextNodeIndex()}}class x{#A;#v;#D;constructor(e,t){this.#A=e,this.#v=t,this.#D=0}hasNext(){return this.#D<this.#v.length}item(){const e=this.#v[this.#D];return this.#A.itemForIndex(e)}next(){++this.#D}}class y{#z;#R;constructor(e,t){this.#z=e,this.#R=t,this.skipFilteredItems()}hasNext(){return this.#z.hasNext()}item(){return this.#z.item()}next(){this.#z.next(),this.skipFilteredItems()}skipFilteredItems(){for(;this.#z.hasNext()&&this.#R&&!this.#R(this.#z.item());)this.#z.next()}}class N{#_;constructor(e){this.#_=e}updateStatus(e){this.sendUpdateEvent(t.i18n.serializeUIString(e))}updateProgress(e,s,n){const i=(100*(n?s/n:0)).toFixed(0);this.sendUpdateEvent(t.i18n.serializeUIString(e,{PH1:i}))}reportProblem(t){this.#_&&this.#_.sendEvent(e.HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot,t)}sendUpdateEvent(t){this.#_&&this.#_.sendEvent(e.HeapSnapshotModel.HeapSnapshotProgressEvent.Update,t)}}function S(e,t){e.length>100||e.push(t)}function w(e,t){t.postMessage({problemReport:e})}class T{argsStep1;argsStep2;argsStep3;constructor(e){const{promise:t,resolve:s}=Promise.withResolvers();this.argsStep1=t;const{promise:n,resolve:i}=Promise.withResolvers();this.argsStep2=n;const{promise:o,resolve:r}=Promise.withResolvers();this.argsStep3=o,e.onmessage=e=>{const t=e.data;switch(t.step){case 1:s(t.args);break;case 2:i(t.args);break;case 3:r(t.args)}},this.initialize(e)}async getNodeSelfSizes(){return(await this.argsStep3).nodeSelfSizes}async initialize(e){try{const t=await this.argsStep1,n=E.buildRetainers(t),i=await this.argsStep2,o={...i,...t,...n,essentialEdges:s.TypedArrayUtilities.createBitVector(i.essentialEdgesBuffer),port:e,nodeSelfSizesPromise:this.getNodeSelfSizes()},r=await E.calculateDominatorsAndRetainedSizes(o),a=E.buildDominatedNodes({...o,...r}),d={...n,...r,...a};e.postMessage({resultsFromSecondWorker:d},{transfer:[d.dominatorsTree.buffer,d.firstRetainerIndex.buffer,d.retainedSizes.buffer,d.retainingEdges.buffer,d.retainingNodes.buffer,d.dominatedNodes.buffer,d.firstDominatedNodeIndex.buffer]})}catch(t){e.postMessage({error:t+"\n"+t?.stack})}}}const C=3,O=2;class E{nodes;containmentEdges;#k;#V;#j=null;strings;#M;#P;#H=-5;rootNodeIndexInternal=0;#U={};#B;#L={};#W={};profile;nodeTypeOffset;nodeNameOffset;nodeIdOffset;nodeSelfSizeOffset;#J;nodeTraceNodeIdOffset;nodeFieldCount;nodeTypes;nodeArrayType;nodeHiddenType;nodeObjectType;nodeNativeType;nodeStringType;nodeConsStringType;nodeSlicedStringType;nodeCodeType;nodeSyntheticType;nodeClosureType;nodeRegExpType;edgeFieldsCount;edgeTypeOffset;edgeNameOffset;edgeToNodeOffset;edgeTypes;edgeElementType;edgeHiddenType;edgeInternalType;edgeShortcutType;edgeWeakType;edgeInvisibleType;edgePropertyType;#K;#$;#Q;#q;#G;nodeCount;#X;retainedSizes;firstEdgeIndexes;retainingNodes;retainingEdges;firstRetainerIndex;nodeDistances;firstDominatedNodeIndex;dominatedNodes;dominatorsTree;#Y;nodeDetachednessAndClassIndexOffset;#Z;#ee=new Set;#te=new Set;#se;#ne;detachednessAndClassIndexArray;#ie=new Map;#oe;constructor(e,t){this.nodes=e.nodes,this.containmentEdges=e.edges,this.#k=e.snapshot.meta,this.#V=e.samples,this.strings=e.strings,this.#M=e.locations,this.#P=t,e.snapshot.root_index&&(this.rootNodeIndexInternal=e.snapshot.root_index),this.profile=e,this.#ne=s.TypedArrayUtilities.createBitVector(this.strings.length)}async initialize(e){const t=this.#k;this.nodeTypeOffset=t.node_fields.indexOf("type"),this.nodeNameOffset=t.node_fields.indexOf("name"),this.nodeIdOffset=t.node_fields.indexOf("id"),this.nodeSelfSizeOffset=t.node_fields.indexOf("self_size"),this.#J=t.node_fields.indexOf("edge_count"),this.nodeTraceNodeIdOffset=t.node_fields.indexOf("trace_node_id"),this.nodeDetachednessAndClassIndexOffset=t.node_fields.indexOf("detachedness"),this.nodeFieldCount=t.node_fields.length,this.nodeTypes=t.node_types[this.nodeTypeOffset],this.nodeArrayType=this.nodeTypes.indexOf("array"),this.nodeHiddenType=this.nodeTypes.indexOf("hidden"),this.nodeObjectType=this.nodeTypes.indexOf("object"),this.nodeNativeType=this.nodeTypes.indexOf("native"),this.nodeStringType=this.nodeTypes.indexOf("string"),this.nodeConsStringType=this.nodeTypes.indexOf("concatenated string"),this.nodeSlicedStringType=this.nodeTypes.indexOf("sliced string"),this.nodeCodeType=this.nodeTypes.indexOf("code"),this.nodeSyntheticType=this.nodeTypes.indexOf("synthetic"),this.nodeClosureType=this.nodeTypes.indexOf("closure"),this.nodeRegExpType=this.nodeTypes.indexOf("regexp"),this.edgeFieldsCount=t.edge_fields.length,this.edgeTypeOffset=t.edge_fields.indexOf("type"),this.edgeNameOffset=t.edge_fields.indexOf("name_or_index"),this.edgeToNodeOffset=t.edge_fields.indexOf("to_node"),this.edgeTypes=t.edge_types[this.edgeTypeOffset],this.edgeTypes.push("invisible"),this.edgeElementType=this.edgeTypes.indexOf("element"),this.edgeHiddenType=this.edgeTypes.indexOf("hidden"),this.edgeInternalType=this.edgeTypes.indexOf("internal"),this.edgeShortcutType=this.edgeTypes.indexOf("shortcut"),this.edgeWeakType=this.edgeTypes.indexOf("weak"),this.edgeInvisibleType=this.edgeTypes.indexOf("invisible"),this.edgePropertyType=this.edgeTypes.indexOf("property");const s=t.location_fields||[];this.#K=s.indexOf("object_index"),this.#$=s.indexOf("script_id"),this.#Q=s.indexOf("line"),this.#q=s.indexOf("column"),this.#G=s.length,this.nodeCount=this.nodes.length/this.nodeFieldCount,this.#X=this.containmentEdges.length/this.edgeFieldsCount,this.#P.updateStatus("Building edge indexes…"),this.firstEdgeIndexes=new Uint32Array(this.nodeCount+1),this.buildEdgeIndexes(),this.#P.updateStatus("Building retainers…");const n=this.startInitStep1InSecondThread(e);if(this.#P.updateStatus("Propagating DOM state…"),this.propagateDOMState(),this.#P.updateStatus("Calculating node flags…"),this.calculateFlags(),this.#P.updateStatus("Building dominated nodes…"),this.startInitStep2InSecondThread(e),this.#P.updateStatus("Calculating shallow sizes…"),this.calculateShallowSizes(),this.#P.updateStatus("Calculating retained sizes…"),this.startInitStep3InSecondThread(e),this.#P.updateStatus("Calculating distances…"),this.nodeDistances=new Int32Array(this.nodeCount),this.calculateDistances(!1),this.#P.updateStatus("Calculating object names…"),this.calculateObjectNames(),this.applyInterfaceDefinitions(this.inferInterfaceDefinitions()),this.#P.updateStatus("Calculating samples…"),this.buildSamples(),this.#P.updateStatus("Building locations…"),this.buildLocationMap(),this.#P.updateStatus("Calculating retained sizes…"),await this.installResultsFromSecondThread(n),this.#P.updateStatus("Calculating statistics…"),this.calculateStatistics(),this.profile.snapshot.trace_function_count){this.#P.updateStatus("Building allocation statistics…");const e=this.nodes.length,t=this.nodeFieldCount,s=this.rootNode(),n={};for(let i=0;i<e;i+=t){s.nodeIndex=i;const e=s.traceNodeId();let t=n[e];t||(n[e]=t={count:0,size:0,ids:[]}),t.count++,t.size+=s.selfSize(),t.ids.push(s.id())}this.#Y=new i(this.profile,n)}this.#P.updateStatus("Finished processing.")}startInitStep1InSecondThread(e){const t=new Promise(((t,s)=>{e.onmessage=e=>{const n=e.data;if(n?.problemReport){const e=n.problemReport;console.warn(function(e,t){const s=e.rootNode();return t.map((e=>"string"==typeof e?e:(s.nodeIndex=e,`${s.name()} @${s.id()}`))).join("\n  ")}(this,e))}else if(n?.resultsFromSecondWorker){const e=n.resultsFromSecondWorker;t(e)}else n?.error&&s(n.error)}})),s=this.#X,{containmentEdges:n,edgeToNodeOffset:i,edgeFieldsCount:o,nodeFieldCount:r}=this,a=new Uint32Array(s);for(let e=0;e<s;++e){const t=n.getValue(e*o+i);if(t%r)throw new Error("Invalid toNodeIndex "+t);a[e]=t/r}const d={edgeToNodeOrdinals:a,firstEdgeIndexes:this.firstEdgeIndexes,nodeCount:this.nodeCount,edgeFieldsCount:this.edgeFieldsCount,nodeFieldCount:this.nodeFieldCount};return e.postMessage({step:1,args:d},[a.buffer]),t}startInitStep2InSecondThread(e){const t=this.rootNodeIndexInternal/this.nodeFieldCount,s=this.initEssentialEdges(),n={rootNodeOrdinal:t,essentialEdgesBuffer:s.buffer};e.postMessage({step:2,args:n},[s.buffer])}startInitStep3InSecondThread(e){const{nodes:t,nodeFieldCount:s,nodeSelfSizeOffset:n,nodeCount:i}=this,o=new Uint32Array(i);for(let e=0;e<i;++e)o[e]=t.getValue(e*s+n);const r={nodeSelfSizes:o};e.postMessage({step:3,args:r},[o.buffer])}async installResultsFromSecondThread(e){const t=await e;this.dominatedNodes=t.dominatedNodes,this.dominatorsTree=t.dominatorsTree,this.firstDominatedNodeIndex=t.firstDominatedNodeIndex,this.firstRetainerIndex=t.firstRetainerIndex,this.retainedSizes=t.retainedSizes,this.retainingEdges=t.retainingEdges,this.retainingNodes=t.retainingNodes}buildEdgeIndexes(){const e=this.nodes,t=this.nodeCount,s=this.firstEdgeIndexes,n=this.nodeFieldCount,i=this.edgeFieldsCount,o=this.#J;s[t]=this.containmentEdges.length;for(let r=0,a=0;r<t;++r)s[r]=a,a+=e.getValue(r*n+o)*i}static buildRetainers(e){const{edgeToNodeOrdinals:t,firstEdgeIndexes:s,nodeCount:n,edgeFieldsCount:i,nodeFieldCount:o}=e,r=t.length,a=new Uint32Array(r),d=new Uint32Array(r),h=new Uint32Array(n+1);for(let e=0;e<r;++e){++h[t[e]]}for(let e=0,t=0;e<n;e++){const s=h[e];h[e]=t,a[t]=s,t+=s}h[n]=a.length;let l=s[0];for(let e=0;e<n;++e){const n=l;l=s[e+1];const r=e*o;for(let e=n;e<l;e+=i){const s=h[t[e/i]],n=s+--a[s];a[n]=r,d[n]=e}}return{retainingNodes:a,retainingEdges:d,firstRetainerIndex:h}}allNodes(){return new m(this.rootNode())}rootNode(){return this.createNode(this.rootNodeIndexInternal)}get rootNodeIndex(){return this.rootNodeIndexInternal}get totalSize(){return this.rootNode().retainedSize()+(this.profile.snapshot.extra_native_bytes??0)}createFilter(e){const{minNodeId:t,maxNodeId:s,allocationNodeId:n,filterName:i}=e;let o;if("number"==typeof n){if(o=this.createAllocationStackFilter(n),!o)throw new Error("Unable to create filter");o.key="AllocationNodeId: "+n}else"number"==typeof t&&"number"==typeof s?(o=this.createNodeIdFilter(t,s),o.key="NodeIdRange: "+t+".."+s):void 0!==i&&(o=this.createNamedFilter(i),o.key="NamedFilter: "+i);return o}search(e,t){const n=e.query;const i=e.isRegex?new RegExp(n):s.StringUtilities.createPlainTextSearchRegex(n,"i");const o=e.isRegex||!e.caseSensitive,r=o?function(e,t,s){return i.test(t)&&e.add(s),e}:function(e,t,s){return-1!==t.indexOf(n)&&e.add(s),e},a=this.strings.reduce(r,new Set),d=this.createFilter(t),h=[],l=this.nodes.length,c=this.nodes,u=this.nodeNameOffset,g=this.nodeIdOffset,p=this.nodeFieldCount,f=this.rootNode();for(let e=0;e<l;e+=p){if(f.nodeIndex=e,d&&!d(f))continue;if(0===f.selfSize())continue;const t=f.name();t===f.rawName()?a.has(c.getValue(e+u))&&h.push(c.getValue(e+g)):(o?i.test(t):-1!==t.indexOf(n))&&h.push(c.getValue(e+g))}return h}aggregatesWithFilter(e){const t=this.createFilter(e),s=t?t.key:"allObjects";return this.getAggregatesByClassKey(!1,s,t)}createNodeIdFilter(e,t){return function(s){const n=s.id();return n>e&&n<=t}}createAllocationStackFilter(e){if(!this.#Y)throw new Error("No Allocation Profile provided");const t=this.#Y.traceIds(e);if(!t.length)return;const s={};for(let e=0;e<t.length;e++)s[t[e]]=!0;return function(e){return Boolean(s[e.traceNodeId()])}}createNamedFilter(e){const t=s.TypedArrayUtilities.createBitVector(this.nodeCount),n=e=>{const s=e.nodeIndex/this.nodeFieldCount;return t.getBit(s)},i=e=>{const s=new Int32Array(this.nodeCount);for(let e=0;e<this.nodeCount;++e)s[e]=this.#H;const n=new Uint32Array(this.nodeCount);s[this.rootNode().ordinal()]=0,n[0]=this.rootNode().nodeIndex;this.bfs(n,1,s,e);for(let e=0;e<this.nodeCount;++e)s[e]!==this.#H&&t.setBit(e)},o=()=>{for(let e=0;e<this.nodeCount;++e)this.nodeDistances[e]===this.#H&&t.setBit(e)};switch(e){case"objectsRetainedByDetachedDomNodes":return i(((e,t)=>2!==t.node().detachedness())),o(),e=>!n(e);case"objectsRetainedByConsole":return i(((e,t)=>!(e.isSynthetic()&&t.hasStringName()&&t.name().endsWith(" / DevTools console")))),o(),e=>!n(e);case"duplicatedStrings":{const e=new Map,s=this.createNode(0);for(let n=0;n<this.nodeCount;++n){s.nodeIndex=n*this.nodeFieldCount;const i=s.rawType();if(i===this.nodeStringType||i===this.nodeConsStringType){if(s.isFlatConsString())continue;const n=s.name(),i=e.get(n);void 0===i?e.set(n,s.nodeIndex):(t.setBit(i/this.nodeFieldCount),t.setBit(s.nodeIndex/this.nodeFieldCount))}}return n}}throw new Error("Invalid filter name")}getAggregatesByClassKey(e,t,s){let n;if(t&&this.#L[t])n=this.#L[t];else{const e=this.buildAggregates(s);this.calculateClassesRetainedSize(e,s),n=Object.create(null);for(const[t,s]of e.entries()){n[this.classKeyFromClassKeyInternal(t)]=s}t&&(this.#L[t]=n)}return!e||t&&this.#W[t]||(this.sortAggregateIndexes(n),t&&(this.#W[t]=e)),n}allocationTracesTops(){return this.#Y.serializeTraceTops()}allocationNodeCallers(e){return this.#Y.serializeCallers(e)}allocationStack(e){const t=this.createNode(e).traceNodeId();return t?this.#Y.serializeAllocationStack(t):null}aggregatesForDiff(e){if(this.#B?.interfaceDefinitions===e)return this.#B.aggregates;const t=this.#oe;this.applyInterfaceDefinitions(JSON.parse(e));const s=this.getAggregatesByClassKey(!0,"allObjects");this.applyInterfaceDefinitions(t??[]);const n={},i=this.createNode();for(const e in s){const t=s[e].idxs,o=new Array(t.length),r=new Array(t.length);for(let e=0;e<t.length;e++)i.nodeIndex=t[e],o[e]=i.id(),r[e]=i.selfSize();n[e]={name:i.className(),indexes:t,ids:o,selfSizes:r}}return this.#B={interfaceDefinitions:e,aggregates:n},n}isUserRoot(e){return!0}calculateShallowSizes(){}calculateDistances(t,s){const n=this.nodeCount;if(t){const e=s;s=(t,s)=>!this.#ee.has(s.nodeIndex())&&(!e||e(t,s)),void 0===this.#se&&(this.#se=new Int32Array(n))}const i=t?this.#se:this.nodeDistances,o=this.#H;for(let e=0;e<n;++e)i[e]=o;const r=new Uint32Array(this.nodeCount);let a=0;for(let e=this.rootNode().edges();e.hasNext();e.next()){const t=e.edge.node();this.isUserRoot(t)&&(i[t.ordinal()]=1,r[a++]=t.nodeIndex)}this.bfs(r,a,i,s),i[this.rootNode().ordinal()]=a>0?e.HeapSnapshotModel.baseSystemDistance:0,r[0]=this.rootNode().nodeIndex,a=1,this.bfs(r,a,i,s)}bfs(e,t,s,n){const i=this.edgeFieldsCount,o=this.nodeFieldCount,r=this.containmentEdges,a=this.firstEdgeIndexes,d=this.edgeToNodeOffset,h=this.edgeTypeOffset,l=this.nodeCount,c=this.edgeWeakType,u=this.#H;let g=0;const p=this.createEdge(0),f=this.createNode(0);for(;g<t;){const l=e[g++],I=l/o,m=s[I]+1,x=a[I],y=a[I+1];f.nodeIndex=l;for(let a=x;a<y;a+=i){if(r.getValue(a+h)===c)continue;const i=r.getValue(a+d),l=i/o;s[l]===u&&(p.edgeIndex=a,n&&!n(f,p)||(s[l]=m,e[t++]=i))}}if(t>l)throw new Error("BFS failed. Nodes to visit ("+t+") is more than nodes count ("+l+")")}buildAggregates(e){const t=new Map,s=this.nodes,n=s.length,i=this.nodeFieldCount,o=this.nodeSelfSizeOffset,r=this.rootNode(),a=this.nodeDistances;for(let d=0;d<n;d+=i){if(r.nodeIndex=d,e&&!e(r))continue;const n=s.getValue(d+o);if(!n)continue;const h=r.classKeyInternal(),l=a[d/i];let c=t.get(h);c?(c.distance=Math.min(c.distance,l),++c.count,c.self+=n,c.idxs.push(d)):(c={count:1,distance:l,self:n,maxRet:0,name:r.className(),idxs:[d]},t.set(h,c))}for(const e of t.values())e.idxs=e.idxs.slice();return t}calculateClassesRetainedSize(e,t){const s=this.rootNodeIndexInternal,n=this.createNode(s),i=[s],o=[-1],r=[],a=new Map,d=this.nodeFieldCount,h=this.dominatedNodes,l=this.firstDominatedNodeIndex;for(;i.length;){const s=i.pop();n.nodeIndex=s;let c=n.classKeyInternal();const u=Boolean(a.get(c)),g=s/d,p=l[g],f=l[g+1];u||t&&!t(n)||!n.selfSize()||(e.get(c).maxRet+=n.retainedSize(),p!==f&&(a.set(c,!0),o.push(i.length),r.push(c)));for(let e=p;e<f;e++)i.push(h[e]);const I=i.length;for(;o[o.length-1]===I;)o.pop(),c=r.pop(),a.set(c,!1)}}sortAggregateIndexes(e){const t=this.createNode(),s=this.createNode();for(const n in e)e[n].idxs.sort(((e,n)=>(t.nodeIndex=e,s.nodeIndex=n,t.id()<s.id()?-1:1)))}tryParseWeakMapEdgeName(e){if(this.#ne.getBit(e))return;const t=this.strings[e].match(/^\d+(?<duplicatedPart> \/ part of key \(.*? @\d+\) -> value \(.*? @\d+\) pair in WeakMap \(table @(?<tableId>\d+)\))$/);if(t)return t.groups;this.#ne.setBit(e)}computeIsEssentialEdge(e,t,s){const n=this.containmentEdges.getValue(t+this.edgeTypeOffset);if(n===this.edgeInternalType){const s=this.containmentEdges.getValue(t+this.edgeNameOffset),n=this.tryParseWeakMapEdgeName(s);if(n){if(this.nodes.getValue(e+this.nodeIdOffset)===parseInt(n.tableId,10))return!1}}if(n===this.edgeWeakType)return!1;const i=this.containmentEdges.getValue(t+this.edgeToNodeOffset);if(e===i)return!1;if(e!==this.rootNodeIndex){if(n===this.edgeShortcutType)return!1;const t=s?s.map:null,o=s?s.flag:0,r=e/this.nodeFieldCount,a=i/this.nodeFieldCount,d=!t||t[r]&o;if((!t||t[a]&o)&&!d)return!1}return!0}initEssentialEdges(){const e=s.TypedArrayUtilities.createBitVector(this.#X),{nodes:t,nodeFieldCount:n,edgeFieldsCount:i}=this,o=this.userObjectsMapAndFlag(),r=t.length,a=this.createNode(0);for(let t=0;t<r;t+=n){a.nodeIndex=t;const s=a.edgeIndexesEnd();for(let n=a.edgeIndexesStart();n<s;n+=i)this.computeIsEssentialEdge(t,n,o)&&e.setBit(n/i)}return e}static hasOnlyWeakRetainers(e,t){const{retainingEdges:s,edgeFieldsCount:n,firstRetainerIndex:i,essentialEdges:o}=e,r=i[t],a=i[t+1];for(let e=r;e<a;++e){const t=s[e];if(o.getBit(t/n))return!1}return!0}static async calculateDominatorsAndRetainedSizes(e){const{nodeCount:t,firstEdgeIndexes:s,edgeFieldsCount:n,nodeFieldCount:i,firstRetainerIndex:o,retainingEdges:r,retainingNodes:a,edgeToNodeOrdinals:d,rootNodeOrdinal:h,essentialEdges:l,nodeSelfSizesPromise:c,port:u}=e;function g(e){return l.getBit(e/n)}const p=t+1,f=new Uint32Array(p),I=new Uint32Array(p),m=new Uint32Array(p),x=new Uint32Array(p),y=new Uint32Array(p),N=new Array(p);let T=0;const C=new Uint32Array(p),O=e=>{const t=e-1;C[t]=s[t];let i=e;for(;0!==i;){0===y[i]&&(y[i]=++T,m[T]=x[i]=i);let e=f[i];const t=i-1;for(;C[t]<s[t+1];C[t]+=n){const o=C[t];if(!g(o))continue;const r=d[o/n],a=r+1;if(0===y[a]){f[a]=i,C[r]=s[r],e=a;break}}i=e}},b=new Uint32Array(p),F=e=>0===I[e]?e:((e=>{let t=0;for(;0!==I[I[e]];)b[++t]=e,e=I[e];for(;t>0;){const e=b[t--];y[x[I[e]]]<y[x[e]]&&(x[e]=x[I[e]]),I[e]=I[I[e]]}})(e),x[e]),A=(e,t)=>{I[t]=e},v=h+1;T=0;const D=new Uint32Array(p);if(O(v),T<t){const s=[`Heap snapshot: ${t-T} nodes are unreachable from the root.`];S(s,"The following nodes have only weak retainers:");for(let n=1;n<=t;n++){const t=n-1;0===y[n]&&E.hasOnlyWeakRetainers(e,t)&&(S(s,t*i),f[n]=v,O(n))}w(s,u)}if(T<t){const e=[`Heap snapshot: Still found ${t-T} unreachable nodes:`];for(let s=1;s<=t;s++)if(0===y[s]){S(e,(s-1)*i),f[s]=v,y[s]=++T,m[T]=x[s]=s}w(e,u)}for(let e=T;e>=2;--e){const t=m[e],s=t-1;let n=!0;for(let e=o[s];e<o[s+1];e++){if(!g(r[e]))continue;n=!1;const s=F(a[e]/i+1);y[s]<y[t]&&(y[t]=y[s])}if(n&&(y[t]=y[v]),void 0===N[m[y[t]]]&&(N[m[y[t]]]=new Set),N[m[y[t]]].add(t),A(f[t],t),void 0!==N[f[t]]){for(const e of N[f[t]]){const s=F(e);D[e]=y[s]<y[e]?s:f[t]}N[f[t]].clear()}}D[0]=D[v]=v;for(let e=2;e<=T;e++){const t=m[e];D[t]!==m[y[t]]&&(D[t]=D[D[t]])}const z=new Uint32Array(t),R=new Float64Array(t),_=await c;for(let e=0;e<t;e++)z[e]=D[e+1]-1,R[e]=_[e];for(let e=T;e>1;e--){const t=m[e]-1;R[z[t]]+=R[t]}return{dominatorsTree:z,retainedSizes:R}}static buildDominatedNodes(e){const{nodeCount:t,dominatorsTree:s,rootNodeOrdinal:n,nodeFieldCount:i}=e,o=new Uint32Array(t+1),r=new Uint32Array(t-1);let a=0,d=t;if(n===a)a=1;else{if(n!==d-1)throw new Error("Root node is expected to be either first or last");d-=1}for(let e=a;e<d;++e)++o[s[e]];let h=0;for(let e=0,s=t;e<s;++e){const t=r[h]=o[e];o[e]=h,h+=t}o[t]=r.length;for(let e=a;e<d;++e){let t=o[s[e]];t+=--r[t],r[t]=e*i}return{firstDominatedNodeIndex:o,dominatedNodes:r}}calculateObjectNames(){const{nodes:e,nodeCount:t,nodeNameOffset:s,nodeNativeType:n,nodeHiddenType:i,nodeObjectType:o,nodeCodeType:r,nodeClosureType:a,nodeRegExpType:d}=this;-1===this.nodeDetachednessAndClassIndexOffset&&(this.detachednessAndClassIndexArray=new Uint32Array(t));const h=new Map,l=e=>{let t=h.get(e);return void 0===t&&(t=this.addString(e),h.set(e,t)),t},c=l("(system)"),u=l("(compiled code)"),g=l("Function"),p=l("RegExp");function f(t){switch(t.rawType()){case i:return c;case o:case n:{let n=t.rawName();if(n.startsWith("<")){const e=n.indexOf(" ");return-1!==e&&(n=n.substring(0,e)+">"),l(n)}if(n.startsWith("Detached <")){const e=n.indexOf(" ",10);return-1!==e&&(n=n.substring(0,e)+">"),l(n)}return e.getValue(t.nodeIndex+s)}case r:return u;case a:return g;case d:return p;default:return l("("+t.type()+")")}}const I=this.createNode(0);for(let e=0;e<t;++e)I.setClassIndex(f(I)),I.nodeIndex=I.nextNodeIndex()}interfaceDefinitions(){return JSON.stringify(this.#oe??[])}isPlainJSObject(e){return e.rawType()===this.nodeObjectType&&"Object"===e.rawName()}inferInterfaceDefinitions(){const{edgePropertyType:e}=this,t=new Map;let s=0;for(let n=this.allNodes();n.hasNext();n.next()){const i=n.item();if(!this.isPlainJSObject(i))continue;++s;let o="{";const r=[];for(let t=i.edges();t.hasNext();t.next()){const s=t.item(),n=s.name();if(s.rawType()!==e||"__proto__"===n)continue;const i=D.formatPropertyName(n);if(o.length>1&&o.length+i.length>120)break;1!==o.length&&(o+=", "),o+=i,r.push(n)}if(0===r.length)continue;o+="}";const a=t.get(o);a?++a.count:t.set(o,{name:o,properties:r,count:1})}const n=Array.from(t.values());n.sort(((e,t)=>t.count-e.count));const i=[],o=Math.max(2,s/1e3);for(let e=0;e<n.length;++e){const t=n[e];if(t.count<o)break;i.push(t)}return i}applyInterfaceDefinitions(e){const{edgePropertyType:t}=this;function s(e,t){return!t||e.propertyCount>t.propertyCount?e:t.propertyCount>e.propertyCount?t:e.index<=t.index?e:t}this.#oe=e,this.#L={},this.#W={};const n={next:new Map,matchInfo:null,greatestNext:null};for(let t=0;t<e.length;++t){const s=e[t],i=s.properties.toSorted();let o=n;for(const e of i){const t=o.next;let s=t.get(e);s||(s={next:new Map,matchInfo:null,greatestNext:null},t.set(e,s),(null===o.greatestNext||o.greatestNext<e)&&(o.greatestNext=e)),o=s}o.matchInfo||(o.matchInfo={name:s.name,propertyCount:i.length,index:t})}const i={name:"Object",propertyCount:0,index:1/0};for(let e=this.allNodes();e.hasNext();e.next()){const o=e.item();if(!this.isPlainJSObject(o))continue;const r=[];for(let e=o.edges();e.hasNext();e.next()){const s=e.item();s.rawType()===t&&r.push(s.name())}r.sort();const a=new Set;a.add(n);let d=s(i,n.matchInfo);for(const e of r)for(const t of Array.from(a.keys())){(null===t.greatestNext||e>=t.greatestNext)&&a.delete(t);const n=t.next.get(e);n&&(a.add(n),d=s(d,n.matchInfo))}let h=d===i?o.rawNameIndex():this.#ie.get(d.name);void 0===h&&(h=this.addString(d.name),this.#ie.set(d.name,h)),o.setClassIndex(h)}}iterateFilteredChildren(e,t,s){const n=this.firstEdgeIndexes[e],i=this.firstEdgeIndexes[e+1];for(let e=n;e<i;e+=this.edgeFieldsCount){const n=this.containmentEdges.getValue(e+this.edgeToNodeOffset)/this.nodeFieldCount;t(this.containmentEdges.getValue(e+this.edgeTypeOffset))&&s(n)}}addString(e){return this.strings.push(e),this.strings.length-1}propagateDOMState(){if(-1===this.nodeDetachednessAndClassIndexOffset)return;console.time("propagateDOMState");const e=new Uint8Array(this.nodeCount),t=[],s=[],n=new Map,i=this.createNode(0),o=function(o,r,a){if(e[r])return;const d=r*o.nodeFieldCount;o.nodes.getValue(d+o.nodeTypeOffset)===o.nodeNativeType?(i.nodeIndex=d,i.setDetachedness(a),1===a?t.push(r):2===a&&(!function(e,t){const s=e.nodes.getValue(t+e.nodeNameOffset);let i=n.get(s);void 0===i&&(i=e.addString("Detached "+e.strings[s]),n.set(s,i)),e.nodes.setValue(t+e.nodeNameOffset,i)}(o,d),s.push(r)),e[r]=1):e[r]=1},r=function(e,t,s){e.iterateFilteredChildren(t,(t=>![e.edgeHiddenType,e.edgeInvisibleType,e.edgeWeakType].includes(t)),(t=>o(e,t,s)))};for(let e=0;e<this.nodeCount;++e){i.nodeIndex=e*this.nodeFieldCount;const t=i.detachedness();0!==t&&o(this,e,t)}for(;0!==t.length;){r(this,t.pop(),1)}for(;0!==s.length;){const e=s.pop();i.nodeIndex=e*this.nodeFieldCount;1!==i.detachedness()&&r(this,e,2)}console.timeEnd("propagateDOMState")}buildSamples(){const t=this.#V;if(!t?.length)return;const n=t.length/2,i=new Array(n),o=new Array(n),r=new Array(n),a=this.#k.sample_fields.indexOf("timestamp_us"),d=this.#k.sample_fields.indexOf("last_assigned_id");for(let e=0;e<n;e++)i[e]=0,o[e]=t[2*e+a]/1e3,r[e]=t[2*e+d];const h=this.nodes.length,l=this.nodeFieldCount,c=this.rootNode();for(let e=0;e<h;e+=l){c.nodeIndex=e;const t=c.id();if(t%2==0)continue;const o=s.ArrayUtilities.lowerBound(r,t,s.ArrayUtilities.DEFAULT_COMPARATOR);o!==n&&(i[o]+=c.selfSize())}this.#j=new e.HeapSnapshotModel.Samples(o,r,i)}buildLocationMap(){const t=new Map,s=this.#M;for(let n=0;n<s.length;n+=this.#G){const i=s[n+this.#K],o=s[n+this.#$],r=s[n+this.#Q],a=s[n+this.#q];t.set(i,new e.HeapSnapshotModel.Location(o,r,a))}this.#Z=t}getLocation(e){return this.#Z.get(e)||null}getSamples(){return this.#j}calculateFlags(){throw new Error("Not implemented")}calculateStatistics(){throw new Error("Not implemented")}userObjectsMapAndFlag(){throw new Error("Not implemented")}calculateSnapshotDiff(t,s){let n=this.#U[t];if(n)return n;n={};const i=this.getAggregatesByClassKey(!0,"allObjects");for(const e in s){const t=s[e],o=this.calculateDiffForClass(t,i[e]);o&&(n[e]=o)}const o=new e.HeapSnapshotModel.AggregateForDiff;for(const e in i){if(e in s)continue;const t=this.calculateDiffForClass(o,i[e]);t&&(n[e]=t)}return this.#U[t]=n,n}calculateDiffForClass(t,s){const n=t.ids,i=t.indexes,o=t.selfSizes,r=s?s.idxs:[];let a=0,d=0;const h=n.length,l=r.length,c=new e.HeapSnapshotModel.Diff(s?s.name:t.name),u=this.createNode(r[d]);for(;a<h&&d<l;){const e=n[a];e<u.id()?(c.deletedIndexes.push(i[a]),c.removedCount++,c.removedSize+=o[a],++a):e>u.id()?(c.addedIndexes.push(r[d]),c.addedCount++,c.addedSize+=u.selfSize(),u.nodeIndex=r[++d]):(++a,u.nodeIndex=r[++d])}for(;a<h;)c.deletedIndexes.push(i[a]),c.removedCount++,c.removedSize+=o[a],++a;for(;d<l;)c.addedIndexes.push(r[d]),c.addedCount++,c.addedSize+=u.selfSize(),u.nodeIndex=r[++d];return c.countDelta=c.addedCount-c.removedCount,c.sizeDelta=c.addedSize-c.removedSize,c.addedCount||c.removedCount?c:null}nodeForSnapshotObjectId(e){for(let t=this.allNodes();t.hasNext();t.next())if(t.node.id()===e)return t.node;return null}classKeyFromClassKeyInternal(e){return"number"==typeof e?","+this.strings[e]:e}nodeClassKey(e){const t=this.nodeForSnapshotObjectId(e);return t?this.classKeyFromClassKeyInternal(t.classKeyInternal()):null}idsOfObjectsWithName(e){const t=[];for(let s=this.allNodes();s.hasNext();s.next())s.item().name()===e&&t.push(s.item().id());return t}createEdgesProvider(e){const t=this.createNode(e),s=this.containmentEdgesFilter(),n=new c(this);return new F(this,s,t.edges(),n)}createEdgesProviderForTest(e,t){const s=this.createNode(e),n=new c(this);return new F(this,t,s.edges(),n)}retainingEdgesFilter(){return null}containmentEdgesFilter(){return null}createRetainingEdgesProvider(e){const t=this.createNode(e),s=this.retainingEdgesFilter(),n=new u(this);return new F(this,s,t.retainers(),n)}createAddedNodesProvider(e,t){const s=this.#U[e][t];return new A(this,s.addedIndexes)}createDeletedNodesProvider(e){return new A(this,e)}createNodesProviderForClass(e,t){return new A(this,this.aggregatesWithFilter(t)[e].idxs)}maxJsNodeId(){const e=this.nodeFieldCount,t=this.nodes,s=t.length;let n=0;for(let i=this.nodeIdOffset;i<s;i+=e){const e=t.getValue(i);e%2!=0&&(n<e&&(n=e))}return n}updateStaticData(){return new e.HeapSnapshotModel.StaticData(this.nodeCount,this.rootNodeIndexInternal,this.totalSize,this.maxJsNodeId())}ignoreNodeInRetainersView(e){this.#ee.add(e),this.calculateDistances(!0),this.#re()}unignoreNodeInRetainersView(e){this.#ee.delete(e),0===this.#ee.size?this.#se=void 0:this.calculateDistances(!0),this.#re()}unignoreAllNodesInRetainersView(){this.#ee.clear(),this.#se=void 0,this.#re()}#re(){const e=this.#se;if(this.#te.clear(),void 0===e)return;const t=new s.MapUtilities.Multimap,n=this.#H,{nodeCount:i,nodeFieldCount:o}=this,r=this.createNode(0);for(let s=0;s<i;++s)if(e[s]===n){r.nodeIndex=s*o;for(let e=r.edges();e.hasNext();e.next()){const s=e.edge;if(!s.isInternal())continue;const n=this.tryParseWeakMapEdgeName(s.nameIndex());n&&t.set(s.nodeIndex(),n.duplicatedPart)}}for(const e of t.keys()){r.nodeIndex=e;for(let s=r.retainers();s.hasNext();s.next()){const n=s.item();if(!n.isInternal())continue;const i=this.tryParseWeakMapEdgeName(n.nameIndex());if(i&&t.hasValue(e,i.duplicatedPart)){const e=this.retainingEdges[n.itemIndex()];this.#te.add(e)}}}}areNodesIgnoredInRetainersView(){return this.#ee.size>0}getDistanceForRetainersView(t){const s=t/this.nodeFieldCount,n=(this.#se??this.nodeDistances)[s];return n===this.#H?Math.max(0,this.nodeDistances[s])+e.HeapSnapshotModel.baseUnreachableDistance:n}isNodeIgnoredInRetainersView(e){return this.#ee.has(e)}isEdgeIgnoredInRetainersView(e){return this.#te.has(e)}}class b{iterator;#ae;#de;iterationOrder;currentComparator;#he;#le;constructor(e,t){this.iterator=e,this.#ae=t,this.#de=!e.hasNext(),this.iterationOrder=null,this.currentComparator=null,this.#he=0,this.#le=0}createIterationOrder(){if(!this.iterationOrder){this.iterationOrder=[];for(let e=this.iterator;e.hasNext();e.next())this.iterationOrder.push(e.item().itemIndex())}}isEmpty(){return this.#de}serializeItemsRange(t,s){if(this.createIterationOrder(),t>s)throw new Error("Start position > end position: "+t+" > "+s);if(!this.iterationOrder)throw new Error("Iteration order undefined");if(s>this.iterationOrder.length&&(s=this.iterationOrder.length),this.#he<s&&t<this.iterationOrder.length-this.#le&&this.currentComparator){const e=this.currentComparator;this.sort(e,this.#he,this.iterationOrder.length-1-this.#le,t,s-1),t<=this.#he&&(this.#he=s),s>=this.iterationOrder.length-this.#le&&(this.#le=this.iterationOrder.length-t)}let n=t;const i=s-t,o=new Array(i);for(let e=0;e<i;++e){const t=this.iterationOrder[n++],s=this.#ae.itemForIndex(t);o[e]=s.serialize()}return new e.HeapSnapshotModel.ItemsRange(t,s,this.iterationOrder.length,o)}sortAndRewind(e){this.currentComparator=e,this.#he=0,this.#le=0}}class F extends b{snapshot;constructor(e,t,s,n){super(t?new y(s,t):s,n),this.snapshot=e}sort(e,t,n,i,o){const r=e.fieldName1,a=e.fieldName2,d=e.ascending1,h=e.ascending2,l=this.iterator.item().clone(),c=l.clone(),u=this.snapshot.createNode(),g=this.snapshot.createNode();function p(e,t,s,n){l.edgeIndex=s,c.edgeIndex=n;let i=0;if("!edgeName"===e){if("__proto__"===c.name())return-1;if("__proto__"===l.name())return 1;i=l.hasStringName()===c.hasStringName()?l.name()<c.name()?-1:l.name()>c.name()?1:0:l.hasStringName()?-1:1}else i=l.getValueForSorting(e)-c.getValueForSorting(e);return t?i:-i}function f(e,t,s,n){l.edgeIndex=s,u.nodeIndex=l.nodeIndex();const i=u[e]();c.edgeIndex=n,g.nodeIndex=c.nodeIndex();const o=g[e](),r=i<o?-1:i>o?1:0;return t?r:-r}if(!this.iterationOrder)throw new Error("Iteration order not defined");function I(e){return e.startsWith("!edge")}I(r)?I(a)?s.ArrayUtilities.sortRange(this.iterationOrder,(function(e,t){let s=p(r,d,e,t);return 0===s&&(s=p(a,h,e,t)),0===s?e-t:s}),t,n,i,o):s.ArrayUtilities.sortRange(this.iterationOrder,(function(e,t){let s=p(r,d,e,t);return 0===s&&(s=f(a,h,e,t)),0===s?e-t:s}),t,n,i,o):I(a)?s.ArrayUtilities.sortRange(this.iterationOrder,(function(e,t){let s=f(r,d,e,t);return 0===s&&(s=p(a,h,e,t)),0===s?e-t:s}),t,n,i,o):s.ArrayUtilities.sortRange(this.iterationOrder,(function(e,t){let s=f(r,d,e,t);return 0===s&&(s=f(a,h,e,t)),0===s?e-t:s}),t,n,i,o)}}class A extends b{snapshot;constructor(e,t){const s=new l(e);super(new x(s,t),s),this.snapshot=e}nodePosition(e){this.createIterationOrder();const t=this.snapshot.createNode();let s=0;if(!this.iterationOrder)throw new Error("Iteration order not defined");for(;s<this.iterationOrder.length&&(t.nodeIndex=this.iterationOrder[s],t.id()!==e);s++);if(s===this.iterationOrder.length)return-1;const n=this.iterationOrder[s];let i=0;const o=this.currentComparator,r=this.buildCompareFunction(o);for(let e=0;e<this.iterationOrder.length;e++)r(this.iterationOrder[e],n)<0&&++i;return i}buildCompareFunction(e){const t=this.snapshot.createNode(),s=this.snapshot.createNode(),n=t[e.fieldName1],i=t[e.fieldName2],o=e.ascending1?1:-1,r=e.ascending2?1:-1;function a(e,n){const i=e.call(t),o=e.call(s);return i<o?-n:i>o?n:0}return function(e,d){t.nodeIndex=e,s.nodeIndex=d;let h=a(n,o);return 0===h&&(h=a(i,r)),h||e-d}}sort(e,t,n,i,o){if(!this.iterationOrder)throw new Error("Iteration order not defined");s.ArrayUtilities.sortRange(this.iterationOrder,this.buildCompareFunction(e),t,n,i,o)}}class v extends E{nodeFlags;flags;#ce;constructor(e,t){super(e,t),this.nodeFlags={canBeQueried:1,detachedDOMTreeNode:2,pageObject:4}}createNode(e){return new D(this,void 0===e?-1:e)}createEdge(e){return new z(this,e)}createRetainingEdge(e){return new R(this,e)}containmentEdgesFilter(){return e=>!e.isInvisible()}retainingEdgesFilter(){const e=this.containmentEdgesFilter();return function(t){return e(t)&&!t.node().isRoot()&&!t.isWeak()}}calculateFlags(){this.flags=new Uint8Array(this.nodeCount),this.markDetachedDOMTreeNodes(),this.markQueriableHeapObjects(),this.markPageOwnedNodes()}#ue(){for(let e=this.rootNode().edges();e.hasNext();e.next())if(this.isUserRoot(e.edge.node()))return!0;return!1}calculateShallowSizes(){if(!this.#ue())return;const{nodeCount:e,nodes:t,nodeFieldCount:s,nodeSelfSizeOffset:n}=this,i=4294967295,o=4294967294;if(e>=o)throw new Error("Too many nodes for calculateShallowSizes");const r=new Uint32Array(e),a=[],d=this.createNode(0);for(let t=0;t<e;++t)d.isHidden()||d.isArray()||d.isNative()&&"system / ExternalStringData"===d.rawName()?r[t]=i:(r[t]=t,a.push(t)),d.nodeIndex=d.nextNodeIndex();for(;0!==a.length;){const e=a.pop(),t=r[e];d.nodeIndex=e*s;for(let e=d.edges();e.hasNext();e.next()){const n=e.edge;if(n.isWeak())continue;const d=n.nodeIndex()/s;switch(r[d]){case i:r[d]=t,a.push(d);break;case d:case t:case o:break;default:r[d]=o,a.push(d)}}}for(let a=0;a<e;++a){const e=r[a];switch(e){case i:case o:case a:break;default:{const i=a*s,o=e*s;if(d.nodeIndex=o,d.isSynthetic()||d.isRoot())break;const r=t.getValue(i+n);t.setValue(i+n,0),t.setValue(o+n,t.getValue(o+n)+r);break}}}}calculateDistances(e){const t=new Set,s=this;super.calculateDistances(e,(function(e,n){if(e.isHidden()&&"sloppy_function_map"===n.name()&&"system / NativeContext"===e.rawName())return!1;if(e.isArray()&&"(map descriptors)"===e.rawName()){const e=parseInt(n.name(),10);return e<2||e%3!=1}if(n.isInternal()){const e=s.tryParseWeakMapEdgeName(n.nameIndex());if(e&&!t.delete(e.duplicatedPart))return t.add(e.duplicatedPart),!1}return!0}))}isUserRoot(e){return e.isUserRoot()||e.isDocumentDOMTreesRoot()}userObjectsMapAndFlag(){return{map:this.flags,flag:this.nodeFlags.pageObject}}flagsOfNode(e){return this.flags[e.nodeIndex/this.nodeFieldCount]}markDetachedDOMTreeNodes(){const e=this.nodes,t=e.length,s=this.nodeFieldCount,n=this.nodeNativeType,i=this.nodeTypeOffset,o=this.nodeFlags.detachedDOMTreeNode,r=this.rootNode();for(let a=0,d=0;a<t;a+=s,d++){e.getValue(a+i)===n&&(r.nodeIndex=a,r.name().startsWith("Detached ")&&(this.flags[d]|=o))}}markQueriableHeapObjects(){const e=this.nodeFlags.canBeQueried,t=this.edgeHiddenType,s=this.edgeInternalType,n=this.edgeInvisibleType,i=this.edgeWeakType,o=this.edgeToNodeOffset,r=this.edgeTypeOffset,a=this.edgeFieldsCount,d=this.containmentEdges,h=this.nodeFieldCount,l=this.firstEdgeIndexes,c=this.flags,u=[];for(let e=this.rootNode().edges();e.hasNext();e.next())e.edge.node().isUserRoot()&&u.push(e.edge.node().nodeIndex/h);for(;u.length;){const g=u.pop();if(c[g]&e)continue;c[g]|=e;const p=l[g],f=l[g+1];for(let l=p;l<f;l+=a){const a=d.getValue(l+o)/h;if(c[a]&e)continue;const g=d.getValue(l+r);g!==t&&g!==n&&g!==s&&g!==i&&u.push(a)}}}markPageOwnedNodes(){const e=this.edgeShortcutType,t=this.edgeElementType,s=this.edgeToNodeOffset,n=this.edgeTypeOffset,i=this.edgeFieldsCount,o=this.edgeWeakType,r=this.firstEdgeIndexes,a=this.containmentEdges,d=this.nodeFieldCount,h=this.nodeCount,l=this.flags,c=this.nodeFlags.pageObject,u=new Uint32Array(h);let g=0;const p=this.rootNodeIndexInternal/d,f=this.rootNode();for(let o=r[p],h=r[p+1];o<h;o+=i){const i=a.getValue(o+n),r=a.getValue(o+s);if(i===t){if(f.nodeIndex=r,!f.isDocumentDOMTreesRoot())continue}else if(i!==e)continue;const h=r/d;u[g++]=h,l[h]|=c}for(;g;){const e=u[--g],t=r[e],h=r[e+1];for(let e=t;e<h;e+=i){const t=a.getValue(e+s)/d;if(l[t]&c)continue;a.getValue(e+n)!==o&&(u[g++]=t,l[t]|=c)}}}calculateStatistics(){const e=this.nodeFieldCount,t=this.nodes,s=t.length,n=this.nodeTypeOffset,i=this.nodeSelfSizeOffset,o=this.nodeNativeType,r=this.nodeCodeType,a=this.nodeConsStringType,d=this.nodeSlicedStringType,h=this.nodeHiddenType,l=this.nodeStringType;let c=this.profile.snapshot.extra_native_bytes??0,u=0,g=0,p=0,f=0,I=0;const m=this.rootNode();for(let x=0;x<s;x+=e){const e=t.getValue(x+i),s=t.getValue(x+n);s!==h?(m.nodeIndex=x,s===o?(c+=e,"system / JSArrayBufferData"===m.rawName()&&(u+=e)):s===r?g+=e:s===a||s===d||s===l?p+=e:"Array"===m.rawName()&&(f+=this.calculateArraySize(m))):I+=e}this.#ce={total:this.totalSize,native:{total:c,typedArrays:u},v8heap:{total:this.totalSize-c,code:g,jsArrays:f,strings:p,system:I}}}calculateArraySize(e){let t=e.selfSize();const s=e.edgeIndexesStart(),n=e.edgeIndexesEnd(),i=this.containmentEdges,o=this.strings,r=this.edgeToNodeOffset,a=this.edgeTypeOffset,d=this.edgeNameOffset,h=this.edgeFieldsCount,l=this.edgeInternalType;for(let c=s;c<n;c+=h){if(i.getValue(c+a)!==l)continue;if("elements"!==o[i.getValue(c+d)])continue;const s=i.getValue(c+r);e.nodeIndex=s,1===e.retainersCount()&&(t+=e.selfSize());break}return t}getStatistics(){return this.#ce}}class D extends I{constructor(e,t){super(e,t)}canBeQueried(){const e=this.snapshot,t=e.flagsOfNode(this);return Boolean(t&e.nodeFlags.canBeQueried)}name(){const e=this.snapshot;return this.rawType()===e.nodeConsStringType?this.consStringName():this.rawType()===e.nodeObjectType&&"Object"===this.rawName()?this.#ge():this.rawName()}consStringName(){const e=this.snapshot,t=e.nodeConsStringType,s=e.edgeInternalType,n=e.edgeFieldsCount,i=e.edgeToNodeOffset,o=e.edgeTypeOffset,r=e.edgeNameOffset,a=e.strings,d=e.containmentEdges,h=e.firstEdgeIndexes,l=e.nodeFieldCount,c=e.nodeTypeOffset,u=e.nodeNameOffset,g=e.nodes,p=[];p.push(this.nodeIndex);let f="";for(;p.length&&f.length<1024;){const e=p.pop();if(g.getValue(e+c)!==t){f+=a[g.getValue(e+u)];continue}const I=e/l,m=h[I],x=h[I+1];let y=0,N=0;for(let e=m;e<x&&(!y||!N);e+=n){if(d.getValue(e+o)===s){const t=a[d.getValue(e+r)];"first"===t?y=d.getValue(e+i):"second"===t&&(N=d.getValue(e+i))}}p.push(N),p.push(y)}return f}#ge(){const e=this.snapshot,{edgeFieldsCount:t,edgePropertyType:s}=e,n=e.createEdge(0);let i="{",o="}",r=this.edgeIndexesStart(),a=this.edgeIndexesEnd()-t,d=!1;for(;r<=a;){if(n.edgeIndex=d?a:r,n.rawType()!==s||"__proto__"===n.name()){d?a-=t:r+=t;continue}const e=D.formatPropertyName(n.name());if(i.length>1&&i.length+o.length+e.length>100)break;d?(a-=t,o.length>1&&(o=", "+o),o=e+o):(r+=t,i.length>1&&(i+=", "),i+=e),d=!d}return r<=a&&(i+=", ..."),o.length>1&&(i+=", "),i+o}static formatPropertyName(e){return/[,'"{}]/.test(e)&&(e=(e=JSON.stringify({[e]:0})).substring(1,e.length-3)),e}id(){const e=this.snapshot;return e.nodes.getValue(this.nodeIndex+e.nodeIdOffset)}isHidden(){return this.rawType()===this.snapshot.nodeHiddenType}isArray(){return this.rawType()===this.snapshot.nodeArrayType}isSynthetic(){return this.rawType()===this.snapshot.nodeSyntheticType}isNative(){return this.rawType()===this.snapshot.nodeNativeType}isUserRoot(){return!this.isSynthetic()}isDocumentDOMTreesRoot(){return this.isSynthetic()&&"(Document DOM trees)"===this.rawName()}serialize(){const e=super.serialize(),t=this.snapshot,s=t.flagsOfNode(this);return s&t.nodeFlags.canBeQueried&&(e.canBeQueried=!0),s&t.nodeFlags.detachedDOMTreeNode&&(e.detachedDOMTreeNode=!0),e}}class z extends h{constructor(e,t){super(e,t)}clone(){const e=this.snapshot;return new z(e,this.edgeIndex)}hasStringName(){return this.isShortcut()?isNaN(parseInt(this.nameInternal(),10)):this.hasStringNameInternal()}isElement(){return this.rawType()===this.snapshot.edgeElementType}isHidden(){return this.rawType()===this.snapshot.edgeHiddenType}isWeak(){return this.rawType()===this.snapshot.edgeWeakType}isInternal(){return this.rawType()===this.snapshot.edgeInternalType}isInvisible(){return this.rawType()===this.snapshot.edgeInvisibleType}isShortcut(){return this.rawType()===this.snapshot.edgeShortcutType}name(){const e=this.nameInternal();if(!this.isShortcut())return String(e);const t=parseInt(e,10);return String(isNaN(t)?e:t)}toString(){const e=this.name();switch(this.type()){case"context":return"->"+e;case"element":return"["+e+"]";case"weak":return"[["+e+"]]";case"property":return-1===e.indexOf(" ")?"."+e:'["'+e+'"]';case"shortcut":return"string"==typeof e?-1===e.indexOf(" ")?"."+e:'["'+e+'"]':"["+e+"]";case"internal":case"hidden":case"invisible":return"{"+e+"}"}return"?"+e+"?"}hasStringNameInternal(){const e=this.rawType(),t=this.snapshot;return e!==t.edgeElementType&&e!==t.edgeHiddenType}nameInternal(){return this.hasStringNameInternal()?this.snapshot.strings[this.nameOrIndex()]:this.nameOrIndex()}nameOrIndex(){return this.edges.getValue(this.edgeIndex+this.snapshot.edgeNameOffset)}rawType(){return this.edges.getValue(this.edgeIndex+this.snapshot.edgeTypeOffset)}nameIndex(){if(!this.hasStringNameInternal())throw new Error("Edge does not have string name");return this.nameOrIndex()}}class R extends p{constructor(e,t){super(e,t)}clone(){const e=this.snapshot;return new R(e,this.retainerIndex())}isHidden(){return this.edge().isHidden()}isInvisible(){return this.edge().isInvisible()}isShortcut(){return this.edge().isShortcut()}isWeak(){return this.edge().isWeak()}}var _=Object.freeze({__proto__:null,HeapSnapshot:E,HeapSnapshotEdge:h,HeapSnapshotEdgeIndexProvider:c,HeapSnapshotEdgeIterator:g,HeapSnapshotEdgesProvider:F,HeapSnapshotFilteredIterator:y,HeapSnapshotIndexRangeIterator:x,HeapSnapshotItemProvider:b,HeapSnapshotNode:I,HeapSnapshotNodeIndexProvider:l,HeapSnapshotNodeIterator:m,HeapSnapshotNodesProvider:A,HeapSnapshotProgress:N,HeapSnapshotRetainerEdge:p,HeapSnapshotRetainerEdgeIndexProvider:u,HeapSnapshotRetainerEdgeIterator:f,JSHeapSnapshot:v,JSHeapSnapshotEdge:z,JSHeapSnapshotNode:D,JSHeapSnapshotRetainerEdge:R,SecondaryInitManager:T,createJSHeapSnapshotForTesting:async function(e){const t=new v(e,new N),s=new MessageChannel;return new T(s.port2),await t.initialize(s.port1),t}});class k{#P;#pe;#fe;#Ie;#me;#xe;#ye;#Ne="";parsingComplete;constructor(e){this.#Se(),this.#P=new N(e),this.#pe=[],this.#fe=null,this.#Ie=!1,this.parsingComplete=this.#we()}dispose(){this.#Se()}#Se(){this.#Ne="",this.#me=void 0}close(){this.#Ie=!0,this.#fe&&this.#fe("")}async buildSnapshot(e){await this.parsingComplete,this.#me=this.#me||{},this.#P.updateStatus("Processing snapshot…");const t=new v(this.#me,this.#P);return await t.initialize(e),this.#Se(),t}#Te(){let e=0;const t="0".charCodeAt(0),s="9".charCodeAt(0),n="]".charCodeAt(0),i=this.#Ne.length;for(;;){for(;e<i;){const i=this.#Ne.charCodeAt(e);if(t<=i&&i<=s)break;if(i===n)return this.#Ne=this.#Ne.slice(e+1),!1;++e}if(e===i)return this.#Ne="",!0;let o=0;const r=e;for(;e<i;){const n=this.#Ne.charCodeAt(e);if(t>n||n>s)break;o*=10,o+=n-t,++e}if(e===i)return this.#Ne=this.#Ne.slice(r),!0;if(!this.#xe)throw new Error("Array not instantiated");this.#xe.setValue(this.#ye++,o)}}#Ce(){this.#P.updateStatus("Parsing strings…");const e=this.#Ne.lastIndexOf("]");if(-1===e)throw new Error("Incomplete JSON");if(this.#Ne=this.#Ne.slice(0,e+1),!this.#me)throw new Error("No snapshot in parseStringsArray");this.#me.strings=JSON.parse(this.#Ne)}write(e){this.#pe.push(e),this.#fe&&(this.#fe(this.#pe.shift()),this.#fe=null)}#Oe(){if(this.#pe.length>0)return Promise.resolve(this.#pe.shift());const{promise:e,resolve:t}=Promise.withResolvers();return this.#fe=t,e}async#Ee(e,t){for(;;){const s=this.#Ne.indexOf(e,t||0);if(-1!==s)return s;t=this.#Ne.length-e.length+1,this.#Ne+=await this.#Oe()}}async#be(e,t,n){const i=await this.#Ee(e),o=await this.#Ee("[",i);for(this.#Ne=this.#Ne.slice(o+1),this.#xe=void 0===n?s.TypedArrayUtilities.createExpandableBigUint32Array():s.TypedArrayUtilities.createFixedBigUint32Array(n),this.#ye=0;this.#Te();)n?this.#P.updateProgress(t,this.#ye,this.#xe.length):this.#P.updateStatus(t),this.#Ne+=await this.#Oe();const r=this.#xe;return this.#xe=null,r}async#we(){const e='"snapshot"',t=await this.#Ee(e);if(-1===t)throw new Error("Snapshot token not found");this.#P.updateStatus("Loading snapshot info…");const s=this.#Ne.slice(t+10+1);let i=!1;const o=new n.TextUtils.BalancedJSONTokenizer((e=>{this.#Ne=o.remainder(),i=!0,this.#me=this.#me||{},this.#me.snapshot=JSON.parse(e)}));for(o.write(s);!i;)o.write(await this.#Oe());this.#me=this.#me||{};const r=await this.#be('"nodes"',"Loading nodes… {PH1}%",this.#me.snapshot.meta.node_fields.length*this.#me.snapshot.node_count);this.#me.nodes=r;const a=await this.#be('"edges"',"Loading edges… {PH1}%",this.#me.snapshot.meta.edge_fields.length*this.#me.snapshot.edge_count);if(this.#me.edges=a,this.#me.snapshot.trace_function_count){const e=await this.#be('"trace_function_infos"',"Loading allocation traces… {PH1}%",this.#me.snapshot.meta.trace_function_info_fields.length*this.#me.snapshot.trace_function_count);this.#me.trace_function_infos=e.asUint32ArrayOrFail();const t=await this.#Ee(":"),s=await this.#Ee('"',t),n=this.#Ne.indexOf("["),i=this.#Ne.lastIndexOf("]",s);this.#me.trace_tree=JSON.parse(this.#Ne.substring(n,i+1)),this.#Ne=this.#Ne.slice(i+1)}if(this.#me.snapshot.meta.sample_fields){const e=await this.#be('"samples"',"Loading samples…");this.#me.samples=e.asArrayOrFail()}if(this.#me.snapshot.meta.location_fields){const e=await this.#be('"locations"',"Loading locations…");this.#me.locations=e.asArrayOrFail()}else this.#me.locations=[];this.#P.updateStatus("Loading strings…");const d=await this.#Ee('"strings"'),h=await this.#Ee("[",d);for(this.#Ne=this.#Ne.slice(h);this.#pe.length>0||!this.#Ie;)this.#Ne+=await this.#Oe();this.#Ce()}}var V=Object.freeze({__proto__:null,HeapSnapshotLoader:k});var j=Object.freeze({__proto__:null,HeapSnapshotWorkerDispatcher:class{#Fe;#Ae;constructor(e){this.#Fe=[],this.#Ae=e}sendEvent(e,t){this.#Ae({eventName:e,data:t})}async dispatchMessage({data:t,ports:s}){const n={callId:t.callId,result:null,error:void 0,errorCallStack:void 0,errorMethodName:void 0};try{switch(t.disposition){case"createLoader":this.#Fe[t.objectId]=new k(this);break;case"dispose":delete this.#Fe[t.objectId];break;case"getter":{const e=this.#Fe[t.objectId][t.methodName];n.result=e;break}case"factory":{const e=this.#Fe[t.objectId],i=t.methodArguments.slice();i.push(...s);const o=await e[t.methodName].apply(e,i);o&&(this.#Fe[t.newObjectId]=o),n.result=Boolean(o);break}case"method":{const e=this.#Fe[t.objectId];n.result=e[t.methodName].apply(e,t.methodArguments);break}case"evaluateForTest":try{globalThis.HeapSnapshotWorker={AllocationProfile:d,HeapSnapshot:_,HeapSnapshotLoader:V},globalThis.HeapSnapshotModel=e,n.result=await self.eval(t.source)}catch(e){n.result=e.toString()}break;case"setupForSecondaryInit":this.#Fe[t.objectId]=new T(s[0])}}catch(e){n.error=e.toString(),n.errorCallStack=e.stack,t.methodName&&(n.errorMethodName=t.methodName)}this.#Ae(n)}}});export{d as AllocationProfile,_ as HeapSnapshot,V as HeapSnapshotLoader,j as HeapSnapshotWorkerDispatcher};

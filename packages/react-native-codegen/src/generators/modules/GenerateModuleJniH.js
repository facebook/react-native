/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict
 * @format
 */

'use strict';

import type {SchemaType} from '../../CodegenSchema';

const {getModules} = require('./Utils');

type FilesOutput = Map<string, string>;

const ModuleClassDeclarationTemplate = ({
  hasteModuleName,
}: $ReadOnly<{hasteModuleName: string}>) => {
  return `/**
 * JNI C++ class for module '${hasteModuleName}'
 */
class JSI_EXPORT ${hasteModuleName}SpecJSI : public JavaTurboModule {
public:
  ${hasteModuleName}SpecJSI(const JavaTurboModule::InitParams &params);
};
`;
};

const HeaderFileTemplate = ({
  modules,
  libraryName,
}: $ReadOnly<{modules: string, libraryName: string}>) => {
  return `
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * ${'@'}generated by codegen project: GenerateModuleJniH.js
 */

#pragma once

#include <ReactCommon/JavaTurboModule.h>
#include <ReactCommon/TurboModule.h>
#include <jsi/jsi.h>

namespace facebook::react {

${modules}

JSI_EXPORT
std::shared_ptr<TurboModule> ${libraryName}_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params);

} // namespace facebook::react
`;
};

const ReactNativeFlagsTemplate = () => {
  return `
# React Native specific compiler flags
# This CMake file exposes the React Native Flags that all the libraries should use when
# compiling a module that will end up inside libreactnative.so

SET(reactnative_FLAGS
        -Wall
        -Werror
        -fexceptions
        -frtti
        -std=c++20
        -DFOLLY_NO_CONFIG=1
        -DLOG_TAG=\"ReactNative\"
)

# This function can be used to configure the reactnative flags for a specific target in
# a convenient way. The usage is:
#
# target_compile_reactnative_options(target_name scope)
#
# scope is either PUBLIC, PRIVATE or INTERFACE

function(target_compile_reactnative_options target_name scope)
  target_compile_options(\${target_name} \${scope} \${reactnative_FLAGS})
  # TODO T228344694 improve this so that it works for all platforms
  if(ANDROID)
    target_compile_definitions(\${target_name} \${scope} RN_SERIALIZABLE_STATE)
  endif()
endfunction()
`;
};
const AdditionalSetupTemplate = () => {
  return `

SET(reactnative_FLAGS
        -Wall
        -Werror
        -fexceptions
        -frtti
        -std=c++20
        -DFOLLY_NO_CONFIG=1
        -DLOG_TAG=\"ReactNative\"
)

SET(folly_FLAGS
        -DFOLLY_NO_CONFIG=1
        -DFOLLY_HAVE_CLOCK_GETTIME=1
        -DFOLLY_USE_LIBCPP=1
        -DFOLLY_CFG_NO_COROUTINES=1
        -DFOLLY_MOBILE=1
        -DFOLLY_HAVE_RECVMMSG=1
        -DFOLLY_HAVE_PTHREAD=1
        # Once we target android-23 above, we can comment
        # the following line. NDK uses GNU style stderror_r() after API 23.
        -DFOLLY_HAVE_XSI_STRERROR_R=1
        )

add_compile_options(\${folly_FLAGS})

find_package(fbjni REQUIRED CONFIG)
find_package(ReactAndroid REQUIRED CONFIG)

add_library(jsi ALIAS ReactAndroid::jsi)
add_library(reactnative ALIAS ReactAndroid::reactnative)
add_library(fbjni ALIAS fbjni::fbjni)

`;
};
// Note: this CMakeLists.txt template includes dependencies for both NativeModule and components.
const CMakeListsTemplate = ({
  libraryName,
  targetName,
}: $ReadOnly<{libraryName: string, targetName: string}>) => {
  return `# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

cmake_minimum_required(VERSION 3.13)
set(CMAKE_VERBOSE_MAKEFILE on)

${targetName !== 'rncore' ? ReactNativeFlagsTemplate() + AdditionalSetupTemplate() : ''}

file(GLOB react_codegen_SRCS CONFIGURE_DEPENDS *.cpp react/renderer/components/${libraryName}/*.cpp)

add_library(
  react_codegen_${targetName}
  ${targetName !== 'rncore' ? 'SHARED' : 'OBJECT'}
  \${react_codegen_SRCS}
)

target_include_directories(react_codegen_${targetName} PUBLIC . react/renderer/components/${libraryName})

target_link_libraries(
  react_codegen_${targetName}
  fbjni
  jsi
  # We need to link different libraries based on whether we are building rncore or not, that's necessary
  # because we want to break a circular dependency between react_codegen_rncore and reactnative
  ${
    targetName !== 'rncore'
      ? 'reactnative'
      : 'folly_runtime glog react_debug react_nativemodule_core react_renderer_componentregistry react_renderer_core react_renderer_debug react_renderer_graphics react_renderer_imagemanager react_renderer_mapbuffer react_utils rrc_image rrc_view turbomodulejsijni yoga'
  }
)

target_compile_reactnative_options(react_codegen_${targetName} PRIVATE)
`;
};

module.exports = {
  generate(
    libraryName: string,
    schema: SchemaType,
    packageName?: string,
    assumeNonnull: boolean = false,
    headerPrefix?: string,
  ): FilesOutput {
    const nativeModules = getModules(schema);
    const modules = Object.keys(nativeModules)
      .filter(hasteModuleName => {
        const module = nativeModules[hasteModuleName];
        return !(
          module.excludedPlatforms != null &&
          module.excludedPlatforms.includes('android')
        );
      })
      .sort()
      .map(hasteModuleName => ModuleClassDeclarationTemplate({hasteModuleName}))
      .join('\n');

    const fileName = `${libraryName}.h`;
    const replacedTemplate = HeaderFileTemplate({
      modules: modules,
      libraryName: libraryName.replace(/-/g, '_'),
    });
    // Use rncore as target name for backwards compat
    const targetName =
      libraryName === 'FBReactNativeSpec' ? 'rncore' : libraryName;
    return new Map([
      [`jni/${fileName}`, replacedTemplate],
      ['jni/CMakeLists.txt', CMakeListsTemplate({libraryName, targetName})],
    ]);
  },
};

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`GenerateModuleH can generate a header file NativeModule specs 1`] = `
"/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


template <typename T>
class JSI_EXPORT NativeArrayTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeArrayTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeArrayTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getReadOnlyArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getReadOnlyArray};
    methodMap_[\\"getArrayWithAlias\\"] = MethodMetadata {.argCount = 2, .invoker = __getArrayWithAlias};
  }
  
private:
  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArray,  static_cast<NativeArrayTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getReadOnlyArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getReadOnlyArray) == 2,
      \\"Expected getReadOnlyArray(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getReadOnlyArray,  static_cast<NativeArrayTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getArrayWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArrayWithAlias) == 3,
      \\"Expected getArrayWithAlias(...) to have 3 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArrayWithAlias,  static_cast<NativeArrayTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt),
      count <= 1 ? throw jsi::JSError(rt, \\"Expected argument in position 1 to be passed\\") : args[1].asObject(rt).asArray(rt));
  }
};


template <typename T>
class JSI_EXPORT NativeBooleanTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeBooleanTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeBooleanTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getBoolean\\"] = MethodMetadata {.argCount = 1, .invoker = __getBoolean};
    methodMap_[\\"getBooleanWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getBooleanWithAlias};
  }
  
private:
  static jsi::Value __getBoolean(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBoolean) == 2,
      \\"Expected getBoolean(...) to have 2 parameters\\");
    return bridging::callFromJs<bool>(rt, &T::getBoolean,  static_cast<NativeBooleanTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asBool());
  }

  static jsi::Value __getBooleanWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBooleanWithAlias) == 2,
      \\"Expected getBooleanWithAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<bool>(rt, &T::getBooleanWithAlias,  static_cast<NativeBooleanTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asBool());
  }
};


template <typename T>
class JSI_EXPORT NativeCallbackTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeCallbackTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeCallbackTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithCallbackWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallbackWithAlias};
  }
  
private:
  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeCallbackTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithCallbackWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallbackWithAlias) == 2,
      \\"Expected getValueWithCallbackWithAlias(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallbackWithAlias,  static_cast<NativeCallbackTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


#pragma mark - NativeEnumTurboModuleStatusLowerCaseEnum

enum class NativeEnumTurboModuleStatusLowerCaseEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusLowerCaseEnum> {
  static NativeEnumTurboModuleStatusLowerCaseEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"active\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Active;
    } else if (value == \\"paused\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Paused;
    } else if (value == \\"off\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value in NativeEnumTurboModuleStatusLowerCaseEnum\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusLowerCaseEnum value) {
    if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Active) {
      return bridging::toJs(rt, \\"active\\");
    } else if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Paused) {
      return bridging::toJs(rt, \\"paused\\");
    } else if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Off) {
      return bridging::toJs(rt, \\"off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value in NativeEnumTurboModuleStatusLowerCaseEnum\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusNumEnum

enum class NativeEnumTurboModuleStatusNumEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusNumEnum> {
  static NativeEnumTurboModuleStatusNumEnum fromJs(jsi::Runtime &rt, const jsi::Value &rawValue) {
    double value = (double)rawValue.asNumber();
    if (value == 2) {
      return NativeEnumTurboModuleStatusNumEnum::Active;
    } else if (value == 1) {
      return NativeEnumTurboModuleStatusNumEnum::Paused;
    } else if (value == 0) {
      return NativeEnumTurboModuleStatusNumEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value in NativeEnumTurboModuleStatusNumEnum\\");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusNumEnum value) {
    if (value == NativeEnumTurboModuleStatusNumEnum::Active) {
      return bridging::toJs(rt, 2);
    } else if (value == NativeEnumTurboModuleStatusNumEnum::Paused) {
      return bridging::toJs(rt, 1);
    } else if (value == NativeEnumTurboModuleStatusNumEnum::Off) {
      return bridging::toJs(rt, 0);
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value in NativeEnumTurboModuleStatusNumEnum\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusRegularEnum

enum class NativeEnumTurboModuleStatusRegularEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusRegularEnum> {
  static NativeEnumTurboModuleStatusRegularEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"Active\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Active;
    } else if (value == \\"Paused\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Paused;
    } else if (value == \\"Off\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value in NativeEnumTurboModuleStatusRegularEnum\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusRegularEnum value) {
    if (value == NativeEnumTurboModuleStatusRegularEnum::Active) {
      return bridging::toJs(rt, \\"Active\\");
    } else if (value == NativeEnumTurboModuleStatusRegularEnum::Paused) {
      return bridging::toJs(rt, \\"Paused\\");
    } else if (value == NativeEnumTurboModuleStatusRegularEnum::Off) {
      return bridging::toJs(rt, \\"Off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value in NativeEnumTurboModuleStatusRegularEnum\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusStrEnum

enum class NativeEnumTurboModuleStatusStrEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusStrEnum> {
  static NativeEnumTurboModuleStatusStrEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"active\\") {
      return NativeEnumTurboModuleStatusStrEnum::Active;
    } else if (value == \\"paused\\") {
      return NativeEnumTurboModuleStatusStrEnum::Paused;
    } else if (value == \\"off\\") {
      return NativeEnumTurboModuleStatusStrEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value in NativeEnumTurboModuleStatusStrEnum\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusStrEnum value) {
    if (value == NativeEnumTurboModuleStatusStrEnum::Active) {
      return bridging::toJs(rt, \\"active\\");
    } else if (value == NativeEnumTurboModuleStatusStrEnum::Paused) {
      return bridging::toJs(rt, \\"paused\\");
    } else if (value == NativeEnumTurboModuleStatusStrEnum::Off) {
      return bridging::toJs(rt, \\"off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value in NativeEnumTurboModuleStatusStrEnum\\");
    }
  }
};
#pragma mark - NativeEnumTurboModuleStateType

template <typename P0>
struct NativeEnumTurboModuleStateType {
  P0 state;
  bool operator==(const NativeEnumTurboModuleStateType &other) const {
    return state == other.state;
  }
};

template <typename T>
struct NativeEnumTurboModuleStateTypeBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.state)>(rt, value.getProperty(rt, \\"state\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, decltype(types.state) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
    return result;
  }
};



#pragma mark - NativeEnumTurboModuleStateTypeWithEnums

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeEnumTurboModuleStateTypeWithEnums {
  P0 state;
  P1 regular;
  P2 str;
  P3 num;
  P4 lowerCase;
  bool operator==(const NativeEnumTurboModuleStateTypeWithEnums &other) const {
    return state == other.state && regular == other.regular && str == other.str && num == other.num && lowerCase == other.lowerCase;
  }
};

template <typename T>
struct NativeEnumTurboModuleStateTypeWithEnumsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.state)>(rt, value.getProperty(rt, \\"state\\"), jsInvoker),
      bridging::fromJs<decltype(types.regular)>(rt, value.getProperty(rt, \\"regular\\"), jsInvoker),
      bridging::fromJs<decltype(types.str)>(rt, value.getProperty(rt, \\"str\\"), jsInvoker),
      bridging::fromJs<decltype(types.num)>(rt, value.getProperty(rt, \\"num\\"), jsInvoker),
      bridging::fromJs<decltype(types.lowerCase)>(rt, value.getProperty(rt, \\"lowerCase\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, decltype(types.state) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String regularToJs(jsi::Runtime &rt, decltype(types.regular) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String strToJs(jsi::Runtime &rt, decltype(types.str) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Value numToJs(jsi::Runtime &rt, decltype(types.num) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String lowerCaseToJs(jsi::Runtime &rt, decltype(types.lowerCase) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
    result.setProperty(rt, \\"regular\\", bridging::toJs(rt, value.regular, jsInvoker));
    result.setProperty(rt, \\"str\\", bridging::toJs(rt, value.str, jsInvoker));
    result.setProperty(rt, \\"num\\", bridging::toJs(rt, value.num, jsInvoker));
    result.setProperty(rt, \\"lowerCase\\", bridging::toJs(rt, value.lowerCase, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeEnumTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"NativeEnumTurboModule\\";

protected:
  NativeEnumTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeEnumTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getStatusRegular\\"] = MethodMetadata {.argCount = 1, .invoker = __getStatusRegular};
    methodMap_[\\"getStatusStr\\"] = MethodMetadata {.argCount = 1, .invoker = __getStatusStr};
    methodMap_[\\"getStatusNum\\"] = MethodMetadata {.argCount = 1, .invoker = __getStatusNum};
    methodMap_[\\"getStatusLowerCase\\"] = MethodMetadata {.argCount = 1, .invoker = __getStatusLowerCase};
    methodMap_[\\"getStateType\\"] = MethodMetadata {.argCount = 4, .invoker = __getStateType};
    methodMap_[\\"getStateTypeWithEnums\\"] = MethodMetadata {.argCount = 1, .invoker = __getStateTypeWithEnums};
  }
  
private:
  static jsi::Value __getStatusRegular(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStatusRegular) == 2,
      \\"Expected getStatusRegular(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getStatusRegular,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getStatusStr(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStatusStr) == 2,
      \\"Expected getStatusStr(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getStatusStr,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getStatusNum(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStatusNum) == 2,
      \\"Expected getStatusNum(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getStatusNum,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getStatusLowerCase(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStatusLowerCase) == 2,
      \\"Expected getStatusLowerCase(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getStatusLowerCase,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getStateType(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStateType) == 5,
      \\"Expected getStateType(...) to have 5 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getStateType,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, \\"Expected argument in position 1 to be passed\\") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, \\"Expected argument in position 2 to be passed\\") : args[2].asNumber(),
      count <= 3 ? throw jsi::JSError(rt, \\"Expected argument in position 3 to be passed\\") : args[3].asString(rt));
  }

  static jsi::Value __getStateTypeWithEnums(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStateTypeWithEnums) == 2,
      \\"Expected getStateTypeWithEnums(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getStateTypeWithEnums,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }
};


template <typename T>
class JSI_EXPORT NativeNullableTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeNullableTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeNullableTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 0, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<bool>>(rt, &T::getBool,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getNumber,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::String>>(rt, &T::getString,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Array>>(rt, &T::getArray,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asArray(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getObject,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 1,
      \\"Expected getValueWithPromise(...) to have 1 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Value>>(rt, &T::getValueWithPromise,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }
};


template <typename T>
class JSI_EXPORT NativeNumberTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeNumberTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeNumberTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getNumberWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumberWithAlias};
  }
  
private:
  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getNumber,  static_cast<NativeNumberTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asNumber());
  }

  static jsi::Value __getNumberWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumberWithAlias) == 2,
      \\"Expected getNumberWithAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getNumberWithAlias,  static_cast<NativeNumberTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asNumber());
  }
};


template <typename T>
class JSI_EXPORT NativeObjectTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeObjectTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getGenericObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getGenericObject};
    methodMap_[\\"getGenericObjectReadOnly\\"] = MethodMetadata {.argCount = 1, .invoker = __getGenericObjectReadOnly};
    methodMap_[\\"getGenericObjectWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getGenericObjectWithAlias};
    methodMap_[\\"difficultObject\\"] = MethodMetadata {.argCount = 1, .invoker = __difficultObject};
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
  }
  
private:
  static jsi::Value __getGenericObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getGenericObject) == 2,
      \\"Expected getGenericObject(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getGenericObject,  static_cast<NativeObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getGenericObjectReadOnly(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getGenericObjectReadOnly) == 2,
      \\"Expected getGenericObjectReadOnly(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getGenericObjectReadOnly,  static_cast<NativeObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getGenericObjectWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getGenericObjectWithAlias) == 2,
      \\"Expected getGenericObjectWithAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getGenericObjectWithAlias,  static_cast<NativeObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __difficultObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::difficultObject) == 2,
      \\"Expected difficultObject(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::difficultObject,  static_cast<NativeObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


template <typename T>
class JSI_EXPORT NativeOptionalObjectTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeOptionalObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeOptionalObjectTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeOptionalObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


#pragma mark - NativePartialAnnotationTurboModuleSomeObj

template <typename P0, typename P1>
struct NativePartialAnnotationTurboModuleSomeObj {
  P0 a;
  P1 b;
  bool operator==(const NativePartialAnnotationTurboModuleSomeObj &other) const {
    return a == other.a && b == other.b;
  }
};

template <typename T>
struct NativePartialAnnotationTurboModuleSomeObjBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.a)>(rt, value.getProperty(rt, \\"a\\"), jsInvoker),
      bridging::fromJs<decltype(types.b)>(rt, value.getProperty(rt, \\"b\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String aToJs(jsi::Runtime &rt, decltype(types.a) value) {
    return bridging::toJs(rt, value);
  }
  static bool bToJs(jsi::Runtime &rt, decltype(types.b) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"a\\", bridging::toJs(rt, value.a, jsInvoker));
    if (value.b) {
      result.setProperty(rt, \\"b\\", bridging::toJs(rt, value.b.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativePartialAnnotationTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"NativePartialAnnotationTurboModule\\";

protected:
  NativePartialAnnotationTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativePartialAnnotationTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getSomeObj\\"] = MethodMetadata {.argCount = 0, .invoker = __getSomeObj};
    methodMap_[\\"getPartialSomeObj\\"] = MethodMetadata {.argCount = 0, .invoker = __getPartialSomeObj};
    methodMap_[\\"getSomeObjFromPartialSomeObj\\"] = MethodMetadata {.argCount = 1, .invoker = __getSomeObjFromPartialSomeObj};
    methodMap_[\\"getPartialPartial\\"] = MethodMetadata {.argCount = 2, .invoker = __getPartialPartial};
  }
  
private:
  static jsi::Value __getSomeObj(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getSomeObj) == 1,
      \\"Expected getSomeObj(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getSomeObj,  static_cast<NativePartialAnnotationTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getPartialSomeObj(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getPartialSomeObj) == 1,
      \\"Expected getPartialSomeObj(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getPartialSomeObj,  static_cast<NativePartialAnnotationTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getSomeObjFromPartialSomeObj(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getSomeObjFromPartialSomeObj) == 2,
      \\"Expected getSomeObjFromPartialSomeObj(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getSomeObjFromPartialSomeObj,  static_cast<NativePartialAnnotationTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getPartialPartial(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getPartialPartial) == 3,
      \\"Expected getPartialPartial(...) to have 3 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getPartialPartial,  static_cast<NativePartialAnnotationTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, \\"Expected argument in position 1 to be passed\\") : args[1].asObject(rt));
  }
};


template <typename T>
class JSI_EXPORT NativePromiseTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativePromiseTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativePromiseTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
    methodMap_[\\"getValueWithPromiseWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromiseWithAlias};
  }
  
private:
  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromise,  static_cast<NativePromiseTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asBool());
  }

  static jsi::Value __getValueWithPromiseWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromiseWithAlias) == 2,
      \\"Expected getValueWithPromiseWithAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromiseWithAlias,  static_cast<NativePromiseTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asString(rt));
  }
};


#pragma mark - NativeSampleTurboModuleAnimal

template <typename P0>
struct NativeSampleTurboModuleAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSampleTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeSampleTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSampleTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_[\\"voidFunc\\"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getObjectShape\\"] = MethodMetadata {.argCount = 1, .invoker = __getObjectShape};
    methodMap_[\\"getAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getAlias};
    methodMap_[\\"getRootTag\\"] = MethodMetadata {.argCount = 1, .invoker = __getRootTag};
    methodMap_[\\"getValue\\"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      \\"Expected voidFunc(...) to have 1 parameters\\");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    return bridging::callFromJs<bool>(rt, &T::getBool,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asBool());
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getNumber,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asNumber());
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getString,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asString(rt));
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArray,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObject,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getObjectShape(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObjectShape) == 2,
      \\"Expected getObjectShape(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObjectShape,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlias) == 2,
      \\"Expected getAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getAlias,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getRootTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRootTag) == 2,
      \\"Expected getRootTag(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getRootTag,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asNumber());
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      \\"Expected getValue(...) to have 4 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getValue,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, \\"Expected argument in position 1 to be passed\\") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, \\"Expected argument in position 2 to be passed\\") : args[2].asObject(rt));
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromise,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asBool());
  }
};


#pragma mark - NativeSampleTurboModuleArraysAnimal

template <typename P0>
struct NativeSampleTurboModuleArraysAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleArraysAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleArraysAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSampleTurboModuleArraysCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModuleArrays\\";

protected:
  NativeSampleTurboModuleArraysCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSampleTurboModuleArraysCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_[\\"voidFunc\\"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getObjectShape\\"] = MethodMetadata {.argCount = 1, .invoker = __getObjectShape};
    methodMap_[\\"getAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getAlias};
    methodMap_[\\"getRootTag\\"] = MethodMetadata {.argCount = 1, .invoker = __getRootTag};
    methodMap_[\\"getValue\\"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      \\"Expected voidFunc(...) to have 1 parameters\\");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getBool,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getNumber,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getString,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArray,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getObject,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getObjectShape(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObjectShape) == 2,
      \\"Expected getObjectShape(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getObjectShape,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlias) == 2,
      \\"Expected getAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getAlias,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getRootTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRootTag) == 2,
      \\"Expected getRootTag(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getRootTag,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      \\"Expected getValue(...) to have 4 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getValue,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt),
      count <= 1 ? throw jsi::JSError(rt, \\"Expected argument in position 1 to be passed\\") : args[1].asObject(rt).asArray(rt),
      count <= 2 ? throw jsi::JSError(rt, \\"Expected argument in position 2 to be passed\\") : args[2].asObject(rt).asArray(rt));
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromise,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }
};


#pragma mark - NativeSampleTurboModuleNullableAnimal

template <typename P0>
struct NativeSampleTurboModuleNullableAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleNullableAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleNullableAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModuleNullable\\";

protected:
  NativeSampleTurboModuleNullableCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSampleTurboModuleNullableCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_[\\"voidFunc\\"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getObjectShape\\"] = MethodMetadata {.argCount = 1, .invoker = __getObjectShape};
    methodMap_[\\"getAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getAlias};
    methodMap_[\\"getRootTag\\"] = MethodMetadata {.argCount = 1, .invoker = __getRootTag};
    methodMap_[\\"getValue\\"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      \\"Expected voidFunc(...) to have 1 parameters\\");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<bool>>(rt, &T::getBool,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getNumber,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::String>>(rt, &T::getString,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Array>>(rt, &T::getArray,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asArray(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getObject,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getObjectShape(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObjectShape) == 2,
      \\"Expected getObjectShape(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getObjectShape,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlias) == 2,
      \\"Expected getAlias(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getAlias,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getRootTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRootTag) == 2,
      \\"Expected getRootTag(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getRootTag,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      \\"Expected getValue(...) to have 4 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getValue,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
      count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asString(rt)),
      count <= 2 || args[2].isNull() || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Value>>(rt, &T::getValueWithPromise,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }
};


#pragma mark - NativeSampleTurboModuleNullableAndOptionalAnimal

template <typename P0>
struct NativeSampleTurboModuleNullableAndOptionalAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleNullableAndOptionalAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleNullableAndOptionalAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.name) {
      result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableAndOptionalCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModuleNullableAndOptional\\";

protected:
  NativeSampleTurboModuleNullableAndOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSampleTurboModuleNullableAndOptionalCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_[\\"voidFunc\\"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getObjectShape\\"] = MethodMetadata {.argCount = 1, .invoker = __getObjectShape};
    methodMap_[\\"getAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getAlias};
    methodMap_[\\"getRootTag\\"] = MethodMetadata {.argCount = 1, .invoker = __getRootTag};
    methodMap_[\\"getValue\\"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      \\"Expected voidFunc(...) to have 1 parameters\\");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<bool>>(rt, &T::getBool,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getNumber,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::String>>(rt, &T::getString,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Array>>(rt, &T::getArray,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asArray(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getObject,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getObjectShape(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObjectShape) == 2,
      \\"Expected getObjectShape(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObjectShape,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __getAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlias) == 2,
      \\"Expected getAlias(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getAlias,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getRootTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRootTag) == 2,
      \\"Expected getRootTag(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getRootTag,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      \\"Expected getValue(...) to have 4 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getValue,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
      count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asString(rt)),
      count <= 2 || args[2].isNull() || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asFunction(rt)));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Value>>(rt, &T::getValueWithPromise,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }
};


#pragma mark - NativeSampleTurboModuleOptionalAnimal

template <typename P0>
struct NativeSampleTurboModuleOptionalAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleOptionalAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleOptionalAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.name) {
      result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSampleTurboModuleOptionalCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModuleOptional\\";

protected:
  NativeSampleTurboModuleOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSampleTurboModuleOptionalCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_[\\"voidFunc\\"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getObjectShape\\"] = MethodMetadata {.argCount = 1, .invoker = __getObjectShape};
    methodMap_[\\"getAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getAlias};
    methodMap_[\\"getRootTag\\"] = MethodMetadata {.argCount = 1, .invoker = __getRootTag};
    methodMap_[\\"getValue\\"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      \\"Expected voidFunc(...) to have 1 parameters\\");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    return bridging::callFromJs<bool>(rt, &T::getBool,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getNumber,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getString,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)));
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArray,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asArray(rt)));
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObject,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __getObjectShape(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObjectShape) == 2,
      \\"Expected getObjectShape(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObjectShape,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __getAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlias) == 2,
      \\"Expected getAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getAlias,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __getRootTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRootTag) == 2,
      \\"Expected getRootTag(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getRootTag,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      \\"Expected getValue(...) to have 4 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getValue,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
      count <= 1 || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asString(rt)),
      count <= 2 || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asObject(rt)));
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asFunction(rt)));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromise,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));
  }
};


template <typename T>
class JSI_EXPORT NativeStringTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeStringTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeStringTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getStringWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getStringWithAlias};
  }
  
private:
  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getString,  static_cast<NativeStringTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asString(rt));
  }

  static jsi::Value __getStringWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStringWithAlias) == 2,
      \\"Expected getStringWithAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getStringWithAlias,  static_cast<NativeStringTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asString(rt));
  }
};

} // namespace facebook::react
"
`;

exports[`GenerateModuleH can generate a header file NativeModule specs with assume nonnull enabled 1`] = `
"/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


template <typename T>
class JSI_EXPORT NativeArrayTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeArrayTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeArrayTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getReadOnlyArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getReadOnlyArray};
    methodMap_[\\"getArrayWithAlias\\"] = MethodMetadata {.argCount = 2, .invoker = __getArrayWithAlias};
  }
  
private:
  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArray,  static_cast<NativeArrayTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getReadOnlyArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getReadOnlyArray) == 2,
      \\"Expected getReadOnlyArray(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getReadOnlyArray,  static_cast<NativeArrayTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getArrayWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArrayWithAlias) == 3,
      \\"Expected getArrayWithAlias(...) to have 3 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArrayWithAlias,  static_cast<NativeArrayTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt),
      count <= 1 ? throw jsi::JSError(rt, \\"Expected argument in position 1 to be passed\\") : args[1].asObject(rt).asArray(rt));
  }
};


template <typename T>
class JSI_EXPORT NativeBooleanTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeBooleanTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeBooleanTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getBoolean\\"] = MethodMetadata {.argCount = 1, .invoker = __getBoolean};
    methodMap_[\\"getBooleanWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getBooleanWithAlias};
  }
  
private:
  static jsi::Value __getBoolean(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBoolean) == 2,
      \\"Expected getBoolean(...) to have 2 parameters\\");
    return bridging::callFromJs<bool>(rt, &T::getBoolean,  static_cast<NativeBooleanTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asBool());
  }

  static jsi::Value __getBooleanWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBooleanWithAlias) == 2,
      \\"Expected getBooleanWithAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<bool>(rt, &T::getBooleanWithAlias,  static_cast<NativeBooleanTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asBool());
  }
};


template <typename T>
class JSI_EXPORT NativeCallbackTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeCallbackTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeCallbackTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithCallbackWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallbackWithAlias};
  }
  
private:
  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeCallbackTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithCallbackWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallbackWithAlias) == 2,
      \\"Expected getValueWithCallbackWithAlias(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallbackWithAlias,  static_cast<NativeCallbackTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


#pragma mark - NativeEnumTurboModuleStatusLowerCaseEnum

enum class NativeEnumTurboModuleStatusLowerCaseEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusLowerCaseEnum> {
  static NativeEnumTurboModuleStatusLowerCaseEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"active\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Active;
    } else if (value == \\"paused\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Paused;
    } else if (value == \\"off\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value in NativeEnumTurboModuleStatusLowerCaseEnum\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusLowerCaseEnum value) {
    if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Active) {
      return bridging::toJs(rt, \\"active\\");
    } else if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Paused) {
      return bridging::toJs(rt, \\"paused\\");
    } else if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Off) {
      return bridging::toJs(rt, \\"off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value in NativeEnumTurboModuleStatusLowerCaseEnum\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusNumEnum

enum class NativeEnumTurboModuleStatusNumEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusNumEnum> {
  static NativeEnumTurboModuleStatusNumEnum fromJs(jsi::Runtime &rt, const jsi::Value &rawValue) {
    double value = (double)rawValue.asNumber();
    if (value == 2) {
      return NativeEnumTurboModuleStatusNumEnum::Active;
    } else if (value == 1) {
      return NativeEnumTurboModuleStatusNumEnum::Paused;
    } else if (value == 0) {
      return NativeEnumTurboModuleStatusNumEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value in NativeEnumTurboModuleStatusNumEnum\\");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusNumEnum value) {
    if (value == NativeEnumTurboModuleStatusNumEnum::Active) {
      return bridging::toJs(rt, 2);
    } else if (value == NativeEnumTurboModuleStatusNumEnum::Paused) {
      return bridging::toJs(rt, 1);
    } else if (value == NativeEnumTurboModuleStatusNumEnum::Off) {
      return bridging::toJs(rt, 0);
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value in NativeEnumTurboModuleStatusNumEnum\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusRegularEnum

enum class NativeEnumTurboModuleStatusRegularEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusRegularEnum> {
  static NativeEnumTurboModuleStatusRegularEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"Active\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Active;
    } else if (value == \\"Paused\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Paused;
    } else if (value == \\"Off\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value in NativeEnumTurboModuleStatusRegularEnum\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusRegularEnum value) {
    if (value == NativeEnumTurboModuleStatusRegularEnum::Active) {
      return bridging::toJs(rt, \\"Active\\");
    } else if (value == NativeEnumTurboModuleStatusRegularEnum::Paused) {
      return bridging::toJs(rt, \\"Paused\\");
    } else if (value == NativeEnumTurboModuleStatusRegularEnum::Off) {
      return bridging::toJs(rt, \\"Off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value in NativeEnumTurboModuleStatusRegularEnum\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusStrEnum

enum class NativeEnumTurboModuleStatusStrEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusStrEnum> {
  static NativeEnumTurboModuleStatusStrEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"active\\") {
      return NativeEnumTurboModuleStatusStrEnum::Active;
    } else if (value == \\"paused\\") {
      return NativeEnumTurboModuleStatusStrEnum::Paused;
    } else if (value == \\"off\\") {
      return NativeEnumTurboModuleStatusStrEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value in NativeEnumTurboModuleStatusStrEnum\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusStrEnum value) {
    if (value == NativeEnumTurboModuleStatusStrEnum::Active) {
      return bridging::toJs(rt, \\"active\\");
    } else if (value == NativeEnumTurboModuleStatusStrEnum::Paused) {
      return bridging::toJs(rt, \\"paused\\");
    } else if (value == NativeEnumTurboModuleStatusStrEnum::Off) {
      return bridging::toJs(rt, \\"off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value in NativeEnumTurboModuleStatusStrEnum\\");
    }
  }
};
#pragma mark - NativeEnumTurboModuleStateType

template <typename P0>
struct NativeEnumTurboModuleStateType {
  P0 state;
  bool operator==(const NativeEnumTurboModuleStateType &other) const {
    return state == other.state;
  }
};

template <typename T>
struct NativeEnumTurboModuleStateTypeBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.state)>(rt, value.getProperty(rt, \\"state\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, decltype(types.state) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
    return result;
  }
};



#pragma mark - NativeEnumTurboModuleStateTypeWithEnums

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeEnumTurboModuleStateTypeWithEnums {
  P0 state;
  P1 regular;
  P2 str;
  P3 num;
  P4 lowerCase;
  bool operator==(const NativeEnumTurboModuleStateTypeWithEnums &other) const {
    return state == other.state && regular == other.regular && str == other.str && num == other.num && lowerCase == other.lowerCase;
  }
};

template <typename T>
struct NativeEnumTurboModuleStateTypeWithEnumsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.state)>(rt, value.getProperty(rt, \\"state\\"), jsInvoker),
      bridging::fromJs<decltype(types.regular)>(rt, value.getProperty(rt, \\"regular\\"), jsInvoker),
      bridging::fromJs<decltype(types.str)>(rt, value.getProperty(rt, \\"str\\"), jsInvoker),
      bridging::fromJs<decltype(types.num)>(rt, value.getProperty(rt, \\"num\\"), jsInvoker),
      bridging::fromJs<decltype(types.lowerCase)>(rt, value.getProperty(rt, \\"lowerCase\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, decltype(types.state) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String regularToJs(jsi::Runtime &rt, decltype(types.regular) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String strToJs(jsi::Runtime &rt, decltype(types.str) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Value numToJs(jsi::Runtime &rt, decltype(types.num) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String lowerCaseToJs(jsi::Runtime &rt, decltype(types.lowerCase) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
    result.setProperty(rt, \\"regular\\", bridging::toJs(rt, value.regular, jsInvoker));
    result.setProperty(rt, \\"str\\", bridging::toJs(rt, value.str, jsInvoker));
    result.setProperty(rt, \\"num\\", bridging::toJs(rt, value.num, jsInvoker));
    result.setProperty(rt, \\"lowerCase\\", bridging::toJs(rt, value.lowerCase, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeEnumTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"NativeEnumTurboModule\\";

protected:
  NativeEnumTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeEnumTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getStatusRegular\\"] = MethodMetadata {.argCount = 1, .invoker = __getStatusRegular};
    methodMap_[\\"getStatusStr\\"] = MethodMetadata {.argCount = 1, .invoker = __getStatusStr};
    methodMap_[\\"getStatusNum\\"] = MethodMetadata {.argCount = 1, .invoker = __getStatusNum};
    methodMap_[\\"getStatusLowerCase\\"] = MethodMetadata {.argCount = 1, .invoker = __getStatusLowerCase};
    methodMap_[\\"getStateType\\"] = MethodMetadata {.argCount = 4, .invoker = __getStateType};
    methodMap_[\\"getStateTypeWithEnums\\"] = MethodMetadata {.argCount = 1, .invoker = __getStateTypeWithEnums};
  }
  
private:
  static jsi::Value __getStatusRegular(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStatusRegular) == 2,
      \\"Expected getStatusRegular(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getStatusRegular,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getStatusStr(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStatusStr) == 2,
      \\"Expected getStatusStr(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getStatusStr,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getStatusNum(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStatusNum) == 2,
      \\"Expected getStatusNum(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getStatusNum,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getStatusLowerCase(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStatusLowerCase) == 2,
      \\"Expected getStatusLowerCase(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getStatusLowerCase,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getStateType(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStateType) == 5,
      \\"Expected getStateType(...) to have 5 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getStateType,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, \\"Expected argument in position 1 to be passed\\") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, \\"Expected argument in position 2 to be passed\\") : args[2].asNumber(),
      count <= 3 ? throw jsi::JSError(rt, \\"Expected argument in position 3 to be passed\\") : args[3].asString(rt));
  }

  static jsi::Value __getStateTypeWithEnums(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStateTypeWithEnums) == 2,
      \\"Expected getStateTypeWithEnums(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getStateTypeWithEnums,  static_cast<NativeEnumTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }
};


template <typename T>
class JSI_EXPORT NativeNullableTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeNullableTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeNullableTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 0, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<bool>>(rt, &T::getBool,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getNumber,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::String>>(rt, &T::getString,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Array>>(rt, &T::getArray,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asArray(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getObject,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 1,
      \\"Expected getValueWithPromise(...) to have 1 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Value>>(rt, &T::getValueWithPromise,  static_cast<NativeNullableTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }
};


template <typename T>
class JSI_EXPORT NativeNumberTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeNumberTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeNumberTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getNumberWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumberWithAlias};
  }
  
private:
  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getNumber,  static_cast<NativeNumberTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asNumber());
  }

  static jsi::Value __getNumberWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumberWithAlias) == 2,
      \\"Expected getNumberWithAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getNumberWithAlias,  static_cast<NativeNumberTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asNumber());
  }
};


template <typename T>
class JSI_EXPORT NativeObjectTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeObjectTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getGenericObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getGenericObject};
    methodMap_[\\"getGenericObjectReadOnly\\"] = MethodMetadata {.argCount = 1, .invoker = __getGenericObjectReadOnly};
    methodMap_[\\"getGenericObjectWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getGenericObjectWithAlias};
    methodMap_[\\"difficultObject\\"] = MethodMetadata {.argCount = 1, .invoker = __difficultObject};
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
  }
  
private:
  static jsi::Value __getGenericObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getGenericObject) == 2,
      \\"Expected getGenericObject(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getGenericObject,  static_cast<NativeObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getGenericObjectReadOnly(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getGenericObjectReadOnly) == 2,
      \\"Expected getGenericObjectReadOnly(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getGenericObjectReadOnly,  static_cast<NativeObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getGenericObjectWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getGenericObjectWithAlias) == 2,
      \\"Expected getGenericObjectWithAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getGenericObjectWithAlias,  static_cast<NativeObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __difficultObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::difficultObject) == 2,
      \\"Expected difficultObject(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::difficultObject,  static_cast<NativeObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


template <typename T>
class JSI_EXPORT NativeOptionalObjectTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeOptionalObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeOptionalObjectTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeOptionalObjectTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


#pragma mark - NativePartialAnnotationTurboModuleSomeObj

template <typename P0, typename P1>
struct NativePartialAnnotationTurboModuleSomeObj {
  P0 a;
  P1 b;
  bool operator==(const NativePartialAnnotationTurboModuleSomeObj &other) const {
    return a == other.a && b == other.b;
  }
};

template <typename T>
struct NativePartialAnnotationTurboModuleSomeObjBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.a)>(rt, value.getProperty(rt, \\"a\\"), jsInvoker),
      bridging::fromJs<decltype(types.b)>(rt, value.getProperty(rt, \\"b\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String aToJs(jsi::Runtime &rt, decltype(types.a) value) {
    return bridging::toJs(rt, value);
  }
  static bool bToJs(jsi::Runtime &rt, decltype(types.b) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"a\\", bridging::toJs(rt, value.a, jsInvoker));
    if (value.b) {
      result.setProperty(rt, \\"b\\", bridging::toJs(rt, value.b.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativePartialAnnotationTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"NativePartialAnnotationTurboModule\\";

protected:
  NativePartialAnnotationTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativePartialAnnotationTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getSomeObj\\"] = MethodMetadata {.argCount = 0, .invoker = __getSomeObj};
    methodMap_[\\"getPartialSomeObj\\"] = MethodMetadata {.argCount = 0, .invoker = __getPartialSomeObj};
    methodMap_[\\"getSomeObjFromPartialSomeObj\\"] = MethodMetadata {.argCount = 1, .invoker = __getSomeObjFromPartialSomeObj};
    methodMap_[\\"getPartialPartial\\"] = MethodMetadata {.argCount = 2, .invoker = __getPartialPartial};
  }
  
private:
  static jsi::Value __getSomeObj(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getSomeObj) == 1,
      \\"Expected getSomeObj(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getSomeObj,  static_cast<NativePartialAnnotationTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getPartialSomeObj(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getPartialSomeObj) == 1,
      \\"Expected getPartialSomeObj(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getPartialSomeObj,  static_cast<NativePartialAnnotationTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getSomeObjFromPartialSomeObj(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getSomeObjFromPartialSomeObj) == 2,
      \\"Expected getSomeObjFromPartialSomeObj(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getSomeObjFromPartialSomeObj,  static_cast<NativePartialAnnotationTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getPartialPartial(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getPartialPartial) == 3,
      \\"Expected getPartialPartial(...) to have 3 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getPartialPartial,  static_cast<NativePartialAnnotationTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, \\"Expected argument in position 1 to be passed\\") : args[1].asObject(rt));
  }
};


template <typename T>
class JSI_EXPORT NativePromiseTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativePromiseTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativePromiseTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
    methodMap_[\\"getValueWithPromiseWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromiseWithAlias};
  }
  
private:
  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromise,  static_cast<NativePromiseTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asBool());
  }

  static jsi::Value __getValueWithPromiseWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromiseWithAlias) == 2,
      \\"Expected getValueWithPromiseWithAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromiseWithAlias,  static_cast<NativePromiseTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asString(rt));
  }
};


#pragma mark - NativeSampleTurboModuleAnimal

template <typename P0>
struct NativeSampleTurboModuleAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSampleTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeSampleTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSampleTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_[\\"voidFunc\\"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getObjectShape\\"] = MethodMetadata {.argCount = 1, .invoker = __getObjectShape};
    methodMap_[\\"getAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getAlias};
    methodMap_[\\"getRootTag\\"] = MethodMetadata {.argCount = 1, .invoker = __getRootTag};
    methodMap_[\\"getValue\\"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      \\"Expected voidFunc(...) to have 1 parameters\\");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    return bridging::callFromJs<bool>(rt, &T::getBool,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asBool());
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getNumber,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asNumber());
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getString,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asString(rt));
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArray,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObject,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getObjectShape(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObjectShape) == 2,
      \\"Expected getObjectShape(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObjectShape,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlias) == 2,
      \\"Expected getAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getAlias,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt));
  }

  static jsi::Value __getRootTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRootTag) == 2,
      \\"Expected getRootTag(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getRootTag,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asNumber());
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      \\"Expected getValue(...) to have 4 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getValue,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, \\"Expected argument in position 1 to be passed\\") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, \\"Expected argument in position 2 to be passed\\") : args[2].asObject(rt));
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromise,  static_cast<NativeSampleTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asBool());
  }
};


#pragma mark - NativeSampleTurboModuleArraysAnimal

template <typename P0>
struct NativeSampleTurboModuleArraysAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleArraysAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleArraysAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSampleTurboModuleArraysCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModuleArrays\\";

protected:
  NativeSampleTurboModuleArraysCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSampleTurboModuleArraysCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_[\\"voidFunc\\"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getObjectShape\\"] = MethodMetadata {.argCount = 1, .invoker = __getObjectShape};
    methodMap_[\\"getAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getAlias};
    methodMap_[\\"getRootTag\\"] = MethodMetadata {.argCount = 1, .invoker = __getRootTag};
    methodMap_[\\"getValue\\"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      \\"Expected voidFunc(...) to have 1 parameters\\");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getBool,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getNumber,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getString,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArray,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getObject,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getObjectShape(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObjectShape) == 2,
      \\"Expected getObjectShape(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getObjectShape,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlias) == 2,
      \\"Expected getAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getAlias,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getRootTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRootTag) == 2,
      \\"Expected getRootTag(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getRootTag,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      \\"Expected getValue(...) to have 4 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getValue,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt),
      count <= 1 ? throw jsi::JSError(rt, \\"Expected argument in position 1 to be passed\\") : args[1].asObject(rt).asArray(rt),
      count <= 2 ? throw jsi::JSError(rt, \\"Expected argument in position 2 to be passed\\") : args[2].asObject(rt).asArray(rt));
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromise,  static_cast<NativeSampleTurboModuleArraysCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asArray(rt));
  }
};


#pragma mark - NativeSampleTurboModuleNullableAnimal

template <typename P0>
struct NativeSampleTurboModuleNullableAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleNullableAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleNullableAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModuleNullable\\";

protected:
  NativeSampleTurboModuleNullableCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSampleTurboModuleNullableCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_[\\"voidFunc\\"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getObjectShape\\"] = MethodMetadata {.argCount = 1, .invoker = __getObjectShape};
    methodMap_[\\"getAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getAlias};
    methodMap_[\\"getRootTag\\"] = MethodMetadata {.argCount = 1, .invoker = __getRootTag};
    methodMap_[\\"getValue\\"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      \\"Expected voidFunc(...) to have 1 parameters\\");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<bool>>(rt, &T::getBool,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getNumber,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::String>>(rt, &T::getString,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Array>>(rt, &T::getArray,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asArray(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getObject,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getObjectShape(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObjectShape) == 2,
      \\"Expected getObjectShape(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getObjectShape,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlias) == 2,
      \\"Expected getAlias(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getAlias,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getRootTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRootTag) == 2,
      \\"Expected getRootTag(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getRootTag,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      \\"Expected getValue(...) to have 4 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getValue,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
      count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asString(rt)),
      count <= 2 || args[2].isNull() || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Value>>(rt, &T::getValueWithPromise,  static_cast<NativeSampleTurboModuleNullableCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }
};


#pragma mark - NativeSampleTurboModuleNullableAndOptionalAnimal

template <typename P0>
struct NativeSampleTurboModuleNullableAndOptionalAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleNullableAndOptionalAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleNullableAndOptionalAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.name) {
      result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableAndOptionalCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModuleNullableAndOptional\\";

protected:
  NativeSampleTurboModuleNullableAndOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSampleTurboModuleNullableAndOptionalCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_[\\"voidFunc\\"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getObjectShape\\"] = MethodMetadata {.argCount = 1, .invoker = __getObjectShape};
    methodMap_[\\"getAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getAlias};
    methodMap_[\\"getRootTag\\"] = MethodMetadata {.argCount = 1, .invoker = __getRootTag};
    methodMap_[\\"getValue\\"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      \\"Expected voidFunc(...) to have 1 parameters\\");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<bool>>(rt, &T::getBool,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getNumber,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::String>>(rt, &T::getString,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Array>>(rt, &T::getArray,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asArray(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getObject,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getObjectShape(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObjectShape) == 2,
      \\"Expected getObjectShape(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObjectShape,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __getAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlias) == 2,
      \\"Expected getAlias(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getAlias,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getRootTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRootTag) == 2,
      \\"Expected getRootTag(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getRootTag,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      \\"Expected getValue(...) to have 4 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Object>>(rt, &T::getValue,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
      count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asString(rt)),
      count <= 2 || args[2].isNull() || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asObject(rt)));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asFunction(rt)));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    auto result = bridging::callFromJs<std::optional<jsi::Value>>(rt, &T::getValueWithPromise,  static_cast<NativeSampleTurboModuleNullableAndOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }
};


#pragma mark - NativeSampleTurboModuleOptionalAnimal

template <typename P0>
struct NativeSampleTurboModuleOptionalAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleOptionalAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleOptionalAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.name) {
      result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSampleTurboModuleOptionalCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModuleOptional\\";

protected:
  NativeSampleTurboModuleOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSampleTurboModuleOptionalCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getConstants\\"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_[\\"voidFunc\\"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_[\\"getBool\\"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_[\\"getNumber\\"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getArray\\"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_[\\"getObject\\"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_[\\"getObjectShape\\"] = MethodMetadata {.argCount = 1, .invoker = __getObjectShape};
    methodMap_[\\"getAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getAlias};
    methodMap_[\\"getRootTag\\"] = MethodMetadata {.argCount = 1, .invoker = __getRootTag};
    methodMap_[\\"getValue\\"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_[\\"getValueWithCallback\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_[\\"getValueWithPromise\\"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      \\"Expected getConstants(...) to have 1 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      \\"Expected voidFunc(...) to have 1 parameters\\");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      \\"Expected getBool(...) to have 2 parameters\\");
    return bridging::callFromJs<bool>(rt, &T::getBool,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      \\"Expected getNumber(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getNumber,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getString,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)));
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      \\"Expected getArray(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArray,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asArray(rt)));
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      \\"Expected getObject(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObject,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __getObjectShape(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObjectShape) == 2,
      \\"Expected getObjectShape(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObjectShape,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __getAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlias) == 2,
      \\"Expected getAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getAlias,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __getRootTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRootTag) == 2,
      \\"Expected getRootTag(...) to have 2 parameters\\");
    return bridging::callFromJs<double>(rt, &T::getRootTag,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      \\"Expected getValue(...) to have 4 parameters\\");
    return bridging::callFromJs<jsi::Object>(rt, &T::getValue,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()),
      count <= 1 || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asString(rt)),
      count <= 2 || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asObject(rt)));
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      \\"Expected getValueWithCallback(...) to have 2 parameters\\");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt).asFunction(rt)));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      \\"Expected getValueWithPromise(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromise,  static_cast<NativeSampleTurboModuleOptionalCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asBool()));
  }
};


template <typename T>
class JSI_EXPORT NativeStringTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeStringTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeStringTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_[\\"getString\\"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_[\\"getStringWithAlias\\"] = MethodMetadata {.argCount = 1, .invoker = __getStringWithAlias};
  }
  
private:
  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      \\"Expected getString(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getString,  static_cast<NativeStringTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asString(rt));
  }

  static jsi::Value __getStringWithAlias(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getStringWithAlias) == 2,
      \\"Expected getStringWithAlias(...) to have 2 parameters\\");
    return bridging::callFromJs<jsi::String>(rt, &T::getStringWithAlias,  static_cast<NativeStringTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, \\"Expected argument in position 0 to be passed\\") : args[0].asString(rt));
  }
};

} // namespace facebook::react
"
`;

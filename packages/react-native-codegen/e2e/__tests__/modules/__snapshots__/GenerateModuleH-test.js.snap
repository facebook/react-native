// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`GenerateModuleH can generate a header file NativeModule specs 1`] = `
"/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  class JSI_EXPORT NativeArrayTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeArrayTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array a) = 0;
  virtual jsi::Array getReadOnlyArray(jsi::Runtime &rt, jsi::Array a) = 0;
  virtual jsi::Array getArrayWithAlias(jsi::Runtime &rt, jsi::Array a, jsi::Array b) = 0;

};

template <typename T>
class JSI_EXPORT NativeArrayTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeArrayTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeArrayTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeArrayTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeArrayTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Array getArray(jsi::Runtime &rt, jsi::Array a) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(a));
    }
    jsi::Array getReadOnlyArray(jsi::Runtime &rt, jsi::Array a) override {
      static_assert(
          bridging::getParameterCount(&T::getReadOnlyArray) == 2,
          \\"Expected getReadOnlyArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getReadOnlyArray, jsInvoker_, instance_, std::move(a));
    }
    jsi::Array getArrayWithAlias(jsi::Runtime &rt, jsi::Array a, jsi::Array b) override {
      static_assert(
          bridging::getParameterCount(&T::getArrayWithAlias) == 3,
          \\"Expected getArrayWithAlias(...) to have 3 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArrayWithAlias, jsInvoker_, instance_, std::move(a), std::move(b));
    }

  private:
    friend class NativeArrayTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeBooleanTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeBooleanTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual bool getBoolean(jsi::Runtime &rt, bool arg) = 0;
  virtual bool getBooleanWithAlias(jsi::Runtime &rt, bool arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeBooleanTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeBooleanTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeBooleanTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeBooleanTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeBooleanTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    bool getBoolean(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBoolean) == 2,
          \\"Expected getBoolean(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBoolean, jsInvoker_, instance_, std::move(arg));
    }
    bool getBooleanWithAlias(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBooleanWithAlias) == 2,
          \\"Expected getBooleanWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBooleanWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    friend class NativeBooleanTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeCallbackTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeCallbackTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void getValueWithCallbackWithAlias(jsi::Runtime &rt, jsi::Function c) = 0;

};

template <typename T>
class JSI_EXPORT NativeCallbackTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeCallbackTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeCallbackTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeCallbackTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCallbackTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    void getValueWithCallbackWithAlias(jsi::Runtime &rt, jsi::Function c) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallbackWithAlias) == 2,
          \\"Expected getValueWithCallbackWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallbackWithAlias, jsInvoker_, instance_, std::move(c));
    }

  private:
    friend class NativeCallbackTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


#pragma mark - NativeEnumTurboModuleStatusLowerCaseEnum

enum class NativeEnumTurboModuleStatusLowerCaseEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusLowerCaseEnum> {
  static NativeEnumTurboModuleStatusLowerCaseEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"active\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Active;
    } else if (value == \\"paused\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Paused;
    } else if (value == \\"off\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusLowerCaseEnum value) {
    if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Active) {
      return bridging::toJs(rt, \\"active\\");
    } else if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Paused) {
      return bridging::toJs(rt, \\"paused\\");
    } else if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Off) {
      return bridging::toJs(rt, \\"off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusNumEnum

enum class NativeEnumTurboModuleStatusNumEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusNumEnum> {
  static NativeEnumTurboModuleStatusNumEnum fromJs(jsi::Runtime &rt, const jsi::Value &rawValue) {
    double value = (double)rawValue.asNumber();
    if (value == 2) {
      return NativeEnumTurboModuleStatusNumEnum::Active;
    } else if (value == 1) {
      return NativeEnumTurboModuleStatusNumEnum::Paused;
    } else if (value == 0) {
      return NativeEnumTurboModuleStatusNumEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value\\");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusNumEnum value) {
    if (value == NativeEnumTurboModuleStatusNumEnum::Active) {
      return bridging::toJs(rt, 2);
    } else if (value == NativeEnumTurboModuleStatusNumEnum::Paused) {
      return bridging::toJs(rt, 1);
    } else if (value == NativeEnumTurboModuleStatusNumEnum::Off) {
      return bridging::toJs(rt, 0);
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusRegularEnum

enum class NativeEnumTurboModuleStatusRegularEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusRegularEnum> {
  static NativeEnumTurboModuleStatusRegularEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"Active\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Active;
    } else if (value == \\"Paused\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Paused;
    } else if (value == \\"Off\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusRegularEnum value) {
    if (value == NativeEnumTurboModuleStatusRegularEnum::Active) {
      return bridging::toJs(rt, \\"Active\\");
    } else if (value == NativeEnumTurboModuleStatusRegularEnum::Paused) {
      return bridging::toJs(rt, \\"Paused\\");
    } else if (value == NativeEnumTurboModuleStatusRegularEnum::Off) {
      return bridging::toJs(rt, \\"Off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusStrEnum

enum class NativeEnumTurboModuleStatusStrEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusStrEnum> {
  static NativeEnumTurboModuleStatusStrEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"active\\") {
      return NativeEnumTurboModuleStatusStrEnum::Active;
    } else if (value == \\"paused\\") {
      return NativeEnumTurboModuleStatusStrEnum::Paused;
    } else if (value == \\"off\\") {
      return NativeEnumTurboModuleStatusStrEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusStrEnum value) {
    if (value == NativeEnumTurboModuleStatusStrEnum::Active) {
      return bridging::toJs(rt, \\"active\\");
    } else if (value == NativeEnumTurboModuleStatusStrEnum::Paused) {
      return bridging::toJs(rt, \\"paused\\");
    } else if (value == NativeEnumTurboModuleStatusStrEnum::Off) {
      return bridging::toJs(rt, \\"off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value\\");
    }
  }
};
  
#pragma mark - NativeEnumTurboModuleStateType

template <typename P0>
struct NativeEnumTurboModuleStateType {
  P0 state;
  bool operator==(const NativeEnumTurboModuleStateType &other) const {
    return state == other.state;
  }
};

template <typename T>
struct NativeEnumTurboModuleStateTypeBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.state)>(rt, value.getProperty(rt, \\"state\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, decltype(types.state) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
    return result;
  }
};



#pragma mark - NativeEnumTurboModuleStateTypeWithEnums

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeEnumTurboModuleStateTypeWithEnums {
  P0 state;
  P1 regular;
  P2 str;
  P3 num;
  P4 lowerCase;
  bool operator==(const NativeEnumTurboModuleStateTypeWithEnums &other) const {
    return state == other.state && regular == other.regular && str == other.str && num == other.num && lowerCase == other.lowerCase;
  }
};

template <typename T>
struct NativeEnumTurboModuleStateTypeWithEnumsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.state)>(rt, value.getProperty(rt, \\"state\\"), jsInvoker),
      bridging::fromJs<decltype(types.regular)>(rt, value.getProperty(rt, \\"regular\\"), jsInvoker),
      bridging::fromJs<decltype(types.str)>(rt, value.getProperty(rt, \\"str\\"), jsInvoker),
      bridging::fromJs<decltype(types.num)>(rt, value.getProperty(rt, \\"num\\"), jsInvoker),
      bridging::fromJs<decltype(types.lowerCase)>(rt, value.getProperty(rt, \\"lowerCase\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, decltype(types.state) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String regularToJs(jsi::Runtime &rt, decltype(types.regular) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String strToJs(jsi::Runtime &rt, decltype(types.str) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Value numToJs(jsi::Runtime &rt, decltype(types.num) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String lowerCaseToJs(jsi::Runtime &rt, decltype(types.lowerCase) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
    result.setProperty(rt, \\"regular\\", bridging::toJs(rt, value.regular, jsInvoker));
    result.setProperty(rt, \\"str\\", bridging::toJs(rt, value.str, jsInvoker));
    result.setProperty(rt, \\"num\\", bridging::toJs(rt, value.num, jsInvoker));
    result.setProperty(rt, \\"lowerCase\\", bridging::toJs(rt, value.lowerCase, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeEnumTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeEnumTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::String getStatusRegular(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::String getStatusStr(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::Value getStatusNum(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::String getStatusLowerCase(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::Object getStateType(jsi::Runtime &rt, jsi::String a, jsi::String b, jsi::Value c, jsi::String d) = 0;
  virtual jsi::Object getStateTypeWithEnums(jsi::Runtime &rt, jsi::Object paramOfTypeWithEnums) = 0;

};

template <typename T>
class JSI_EXPORT NativeEnumTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"NativeEnumTurboModule\\";

protected:
  NativeEnumTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeEnumTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeEnumTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeEnumTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::String getStatusRegular(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusRegular) == 2,
          \\"Expected getStatusRegular(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStatusRegular, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::String getStatusStr(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusStr) == 2,
          \\"Expected getStatusStr(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStatusStr, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::Value getStatusNum(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusNum) == 2,
          \\"Expected getStatusNum(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getStatusNum, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::String getStatusLowerCase(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusLowerCase) == 2,
          \\"Expected getStatusLowerCase(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStatusLowerCase, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::Object getStateType(jsi::Runtime &rt, jsi::String a, jsi::String b, jsi::Value c, jsi::String d) override {
      static_assert(
          bridging::getParameterCount(&T::getStateType) == 5,
          \\"Expected getStateType(...) to have 5 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getStateType, jsInvoker_, instance_, std::move(a), std::move(b), std::move(c), std::move(d));
    }
    jsi::Object getStateTypeWithEnums(jsi::Runtime &rt, jsi::Object paramOfTypeWithEnums) override {
      static_assert(
          bridging::getParameterCount(&T::getStateTypeWithEnums) == 2,
          \\"Expected getStateTypeWithEnums(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getStateTypeWithEnums, jsInvoker_, instance_, std::move(paramOfTypeWithEnums));
    }

  private:
    friend class NativeEnumTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeNullableTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNullableTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> a) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> a) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<double> a) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> a) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> a) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeNullableTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeNullableTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeNullableTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeNullableTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNullableTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> a) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(a));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> a) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<double> a) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> a) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> a) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 1,
          \\"Expected getValueWithPromise(...) to have 1 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_);
    }

  private:
    friend class NativeNullableTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeNumberTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNumberTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual double getNumberWithAlias(jsi::Runtime &rt, double arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeNumberTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeNumberTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeNumberTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeNumberTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNumberTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    double getNumberWithAlias(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumberWithAlias) == 2,
          \\"Expected getNumberWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumberWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    friend class NativeNumberTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeObjectTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeObjectTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getGenericObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getGenericObjectReadOnly(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getGenericObjectWithAlias(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object difficultObject(jsi::Runtime &rt, jsi::Object A) = 0;
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeObjectTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeObjectTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeObjectTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeObjectTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getGenericObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObject) == 2,
          \\"Expected getGenericObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getGenericObjectReadOnly(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObjectReadOnly) == 2,
          \\"Expected getGenericObjectReadOnly(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObjectReadOnly, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getGenericObjectWithAlias(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObjectWithAlias) == 2,
          \\"Expected getGenericObjectWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObjectWithAlias, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object difficultObject(jsi::Runtime &rt, jsi::Object A) override {
      static_assert(
          bridging::getParameterCount(&T::difficultObject) == 2,
          \\"Expected difficultObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::difficultObject, jsInvoker_, instance_, std::move(A));
    }
    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    friend class NativeObjectTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeOptionalObjectTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeOptionalObjectTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeOptionalObjectTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeOptionalObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeOptionalObjectTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeOptionalObjectTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeOptionalObjectTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    friend class NativeOptionalObjectTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativePartialAnnotationTurboModuleSomeObj

template <typename P0, typename P1>
struct NativePartialAnnotationTurboModuleSomeObj {
  P0 a;
  P1 b;
  bool operator==(const NativePartialAnnotationTurboModuleSomeObj &other) const {
    return a == other.a && b == other.b;
  }
};

template <typename T>
struct NativePartialAnnotationTurboModuleSomeObjBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.a)>(rt, value.getProperty(rt, \\"a\\"), jsInvoker),
      bridging::fromJs<decltype(types.b)>(rt, value.getProperty(rt, \\"b\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String aToJs(jsi::Runtime &rt, decltype(types.a) value) {
    return bridging::toJs(rt, value);
  }

  static bool bToJs(jsi::Runtime &rt, decltype(types.b) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"a\\", bridging::toJs(rt, value.a, jsInvoker));
    if (value.b) {
      result.setProperty(rt, \\"b\\", bridging::toJs(rt, value.b.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativePartialAnnotationTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativePartialAnnotationTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getSomeObj(jsi::Runtime &rt) = 0;
  virtual jsi::Object getPartialSomeObj(jsi::Runtime &rt) = 0;
  virtual jsi::Object getSomeObjFromPartialSomeObj(jsi::Runtime &rt, jsi::Object value) = 0;
  virtual jsi::Object getPartialPartial(jsi::Runtime &rt, jsi::Object value1, jsi::Object value2) = 0;

};

template <typename T>
class JSI_EXPORT NativePartialAnnotationTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"NativePartialAnnotationTurboModule\\";

protected:
  NativePartialAnnotationTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePartialAnnotationTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativePartialAnnotationTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePartialAnnotationTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getSomeObj(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getSomeObj) == 1,
          \\"Expected getSomeObj(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getSomeObj, jsInvoker_, instance_);
    }
    jsi::Object getPartialSomeObj(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getPartialSomeObj) == 1,
          \\"Expected getPartialSomeObj(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getPartialSomeObj, jsInvoker_, instance_);
    }
    jsi::Object getSomeObjFromPartialSomeObj(jsi::Runtime &rt, jsi::Object value) override {
      static_assert(
          bridging::getParameterCount(&T::getSomeObjFromPartialSomeObj) == 2,
          \\"Expected getSomeObjFromPartialSomeObj(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getSomeObjFromPartialSomeObj, jsInvoker_, instance_, std::move(value));
    }
    jsi::Object getPartialPartial(jsi::Runtime &rt, jsi::Object value1, jsi::Object value2) override {
      static_assert(
          bridging::getParameterCount(&T::getPartialPartial) == 3,
          \\"Expected getPartialPartial(...) to have 3 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getPartialPartial, jsInvoker_, instance_, std::move(value1), std::move(value2));
    }

  private:
    friend class NativePartialAnnotationTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativePromiseTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativePromiseTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;
  virtual jsi::Value getValueWithPromiseWithAlias(jsi::Runtime &rt, jsi::String arg) = 0;

};

template <typename T>
class JSI_EXPORT NativePromiseTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativePromiseTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePromiseTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativePromiseTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePromiseTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }
    jsi::Value getValueWithPromiseWithAlias(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromiseWithAlias) == 2,
          \\"Expected getValueWithPromiseWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromiseWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    friend class NativePromiseTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSampleTurboModuleAnimal

template <typename P0>
struct NativeSampleTurboModuleAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeSampleTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual bool getBool(jsi::Runtime &rt, bool arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getAlias(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual double getRootTag(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String getValuegetValuegetValuegetValuegetValuey, jsi::Object z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeSampleTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSampleTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    bool getBool(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getAlias(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    double getRootTag(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String getValuegetValuegetValuegetValuegetValuey, jsi::Object z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(getValuegetValuegetValuegetValuegetValuey), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    friend class NativeSampleTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSampleTurboModuleArraysAnimal

template <typename P0>
struct NativeSampleTurboModuleArraysAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleArraysAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleArraysAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeSampleTurboModuleArraysCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleArraysCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual jsi::Array getBool(jsi::Runtime &rt, jsi::Array id) = 0;
  virtual jsi::Array getNumber(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getString(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getObject(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getObjectShape(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getAlias(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getRootTag(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getValue(jsi::Runtime &rt, jsi::Array x, jsi::Array y, jsi::Array z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, jsi::Array error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleArraysCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModuleArrays\\";

protected:
  NativeSampleTurboModuleArraysCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleArraysCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSampleTurboModuleArraysCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleArraysCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    jsi::Array getBool(jsi::Runtime &rt, jsi::Array id) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(id));
    }
    jsi::Array getNumber(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getString(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getObject(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getObjectShape(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getAlias(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getRootTag(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getValue(jsi::Runtime &rt, jsi::Array x, jsi::Array y, jsi::Array z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, jsi::Array error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    friend class NativeSampleTurboModuleArraysCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSampleTurboModuleNullableAnimal

template <typename P0>
struct NativeSampleTurboModuleNullableAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleNullableAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleNullableAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeSampleTurboModuleNullableCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleNullableCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModuleNullable\\";

protected:
  NativeSampleTurboModuleNullableCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleNullableCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSampleTurboModuleNullableCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleNullableCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    friend class NativeSampleTurboModuleNullableCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSampleTurboModuleNullableAndOptionalAnimal

template <typename P0>
struct NativeSampleTurboModuleNullableAndOptionalAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleNullableAndOptionalAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleNullableAndOptionalAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.name) {
      result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableAndOptionalCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModuleNullableAndOptional\\";

protected:
  NativeSampleTurboModuleNullableAndOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleNullableAndOptionalCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    friend class NativeSampleTurboModuleNullableAndOptionalCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSampleTurboModuleOptionalAnimal

template <typename P0>
struct NativeSampleTurboModuleOptionalAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleOptionalAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleOptionalAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.name) {
      result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeSampleTurboModuleOptionalCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleOptionalCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual bool getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual double getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleOptionalCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModuleOptional\\";

protected:
  NativeSampleTurboModuleOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleOptionalCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSampleTurboModuleOptionalCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleOptionalCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    bool getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    double getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    friend class NativeSampleTurboModuleOptionalCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeStringTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeStringTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::String getStringWithAlias(jsi::Runtime &rt, jsi::String arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeStringTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeStringTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeStringTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeStringTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeStringTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getStringWithAlias(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getStringWithAlias) == 2,
          \\"Expected getStringWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStringWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    friend class NativeStringTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
"
`;

exports[`GenerateModuleH can generate a header file NativeModule specs with assume nonnull enabled 1`] = `
"/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  class JSI_EXPORT NativeArrayTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeArrayTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array a) = 0;
  virtual jsi::Array getReadOnlyArray(jsi::Runtime &rt, jsi::Array a) = 0;
  virtual jsi::Array getArrayWithAlias(jsi::Runtime &rt, jsi::Array a, jsi::Array b) = 0;

};

template <typename T>
class JSI_EXPORT NativeArrayTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeArrayTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeArrayTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeArrayTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeArrayTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Array getArray(jsi::Runtime &rt, jsi::Array a) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(a));
    }
    jsi::Array getReadOnlyArray(jsi::Runtime &rt, jsi::Array a) override {
      static_assert(
          bridging::getParameterCount(&T::getReadOnlyArray) == 2,
          \\"Expected getReadOnlyArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getReadOnlyArray, jsInvoker_, instance_, std::move(a));
    }
    jsi::Array getArrayWithAlias(jsi::Runtime &rt, jsi::Array a, jsi::Array b) override {
      static_assert(
          bridging::getParameterCount(&T::getArrayWithAlias) == 3,
          \\"Expected getArrayWithAlias(...) to have 3 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArrayWithAlias, jsInvoker_, instance_, std::move(a), std::move(b));
    }

  private:
    friend class NativeArrayTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeBooleanTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeBooleanTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual bool getBoolean(jsi::Runtime &rt, bool arg) = 0;
  virtual bool getBooleanWithAlias(jsi::Runtime &rt, bool arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeBooleanTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeBooleanTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeBooleanTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeBooleanTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeBooleanTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    bool getBoolean(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBoolean) == 2,
          \\"Expected getBoolean(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBoolean, jsInvoker_, instance_, std::move(arg));
    }
    bool getBooleanWithAlias(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBooleanWithAlias) == 2,
          \\"Expected getBooleanWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBooleanWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    friend class NativeBooleanTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeCallbackTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeCallbackTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void getValueWithCallbackWithAlias(jsi::Runtime &rt, jsi::Function c) = 0;

};

template <typename T>
class JSI_EXPORT NativeCallbackTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeCallbackTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeCallbackTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeCallbackTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCallbackTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    void getValueWithCallbackWithAlias(jsi::Runtime &rt, jsi::Function c) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallbackWithAlias) == 2,
          \\"Expected getValueWithCallbackWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallbackWithAlias, jsInvoker_, instance_, std::move(c));
    }

  private:
    friend class NativeCallbackTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


#pragma mark - NativeEnumTurboModuleStatusLowerCaseEnum

enum class NativeEnumTurboModuleStatusLowerCaseEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusLowerCaseEnum> {
  static NativeEnumTurboModuleStatusLowerCaseEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"active\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Active;
    } else if (value == \\"paused\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Paused;
    } else if (value == \\"off\\") {
      return NativeEnumTurboModuleStatusLowerCaseEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusLowerCaseEnum value) {
    if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Active) {
      return bridging::toJs(rt, \\"active\\");
    } else if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Paused) {
      return bridging::toJs(rt, \\"paused\\");
    } else if (value == NativeEnumTurboModuleStatusLowerCaseEnum::Off) {
      return bridging::toJs(rt, \\"off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusNumEnum

enum class NativeEnumTurboModuleStatusNumEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusNumEnum> {
  static NativeEnumTurboModuleStatusNumEnum fromJs(jsi::Runtime &rt, const jsi::Value &rawValue) {
    double value = (double)rawValue.asNumber();
    if (value == 2) {
      return NativeEnumTurboModuleStatusNumEnum::Active;
    } else if (value == 1) {
      return NativeEnumTurboModuleStatusNumEnum::Paused;
    } else if (value == 0) {
      return NativeEnumTurboModuleStatusNumEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value\\");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusNumEnum value) {
    if (value == NativeEnumTurboModuleStatusNumEnum::Active) {
      return bridging::toJs(rt, 2);
    } else if (value == NativeEnumTurboModuleStatusNumEnum::Paused) {
      return bridging::toJs(rt, 1);
    } else if (value == NativeEnumTurboModuleStatusNumEnum::Off) {
      return bridging::toJs(rt, 0);
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusRegularEnum

enum class NativeEnumTurboModuleStatusRegularEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusRegularEnum> {
  static NativeEnumTurboModuleStatusRegularEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"Active\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Active;
    } else if (value == \\"Paused\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Paused;
    } else if (value == \\"Off\\") {
      return NativeEnumTurboModuleStatusRegularEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusRegularEnum value) {
    if (value == NativeEnumTurboModuleStatusRegularEnum::Active) {
      return bridging::toJs(rt, \\"Active\\");
    } else if (value == NativeEnumTurboModuleStatusRegularEnum::Paused) {
      return bridging::toJs(rt, \\"Paused\\");
    } else if (value == NativeEnumTurboModuleStatusRegularEnum::Off) {
      return bridging::toJs(rt, \\"Off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value\\");
    }
  }
};

#pragma mark - NativeEnumTurboModuleStatusStrEnum

enum class NativeEnumTurboModuleStatusStrEnum { Active, Paused, Off };

template <>
struct Bridging<NativeEnumTurboModuleStatusStrEnum> {
  static NativeEnumTurboModuleStatusStrEnum fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == \\"active\\") {
      return NativeEnumTurboModuleStatusStrEnum::Active;
    } else if (value == \\"paused\\") {
      return NativeEnumTurboModuleStatusStrEnum::Paused;
    } else if (value == \\"off\\") {
      return NativeEnumTurboModuleStatusStrEnum::Off;
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for value\\");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeEnumTurboModuleStatusStrEnum value) {
    if (value == NativeEnumTurboModuleStatusStrEnum::Active) {
      return bridging::toJs(rt, \\"active\\");
    } else if (value == NativeEnumTurboModuleStatusStrEnum::Paused) {
      return bridging::toJs(rt, \\"paused\\");
    } else if (value == NativeEnumTurboModuleStatusStrEnum::Off) {
      return bridging::toJs(rt, \\"off\\");
    } else {
      throw jsi::JSError(rt, \\"No appropriate enum member found for enum value\\");
    }
  }
};
  
#pragma mark - NativeEnumTurboModuleStateType

template <typename P0>
struct NativeEnumTurboModuleStateType {
  P0 state;
  bool operator==(const NativeEnumTurboModuleStateType &other) const {
    return state == other.state;
  }
};

template <typename T>
struct NativeEnumTurboModuleStateTypeBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.state)>(rt, value.getProperty(rt, \\"state\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, decltype(types.state) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
    return result;
  }
};



#pragma mark - NativeEnumTurboModuleStateTypeWithEnums

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeEnumTurboModuleStateTypeWithEnums {
  P0 state;
  P1 regular;
  P2 str;
  P3 num;
  P4 lowerCase;
  bool operator==(const NativeEnumTurboModuleStateTypeWithEnums &other) const {
    return state == other.state && regular == other.regular && str == other.str && num == other.num && lowerCase == other.lowerCase;
  }
};

template <typename T>
struct NativeEnumTurboModuleStateTypeWithEnumsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.state)>(rt, value.getProperty(rt, \\"state\\"), jsInvoker),
      bridging::fromJs<decltype(types.regular)>(rt, value.getProperty(rt, \\"regular\\"), jsInvoker),
      bridging::fromJs<decltype(types.str)>(rt, value.getProperty(rt, \\"str\\"), jsInvoker),
      bridging::fromJs<decltype(types.num)>(rt, value.getProperty(rt, \\"num\\"), jsInvoker),
      bridging::fromJs<decltype(types.lowerCase)>(rt, value.getProperty(rt, \\"lowerCase\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, decltype(types.state) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String regularToJs(jsi::Runtime &rt, decltype(types.regular) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String strToJs(jsi::Runtime &rt, decltype(types.str) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Value numToJs(jsi::Runtime &rt, decltype(types.num) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String lowerCaseToJs(jsi::Runtime &rt, decltype(types.lowerCase) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
    result.setProperty(rt, \\"regular\\", bridging::toJs(rt, value.regular, jsInvoker));
    result.setProperty(rt, \\"str\\", bridging::toJs(rt, value.str, jsInvoker));
    result.setProperty(rt, \\"num\\", bridging::toJs(rt, value.num, jsInvoker));
    result.setProperty(rt, \\"lowerCase\\", bridging::toJs(rt, value.lowerCase, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeEnumTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeEnumTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::String getStatusRegular(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::String getStatusStr(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::Value getStatusNum(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::String getStatusLowerCase(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::Object getStateType(jsi::Runtime &rt, jsi::String a, jsi::String b, jsi::Value c, jsi::String d) = 0;
  virtual jsi::Object getStateTypeWithEnums(jsi::Runtime &rt, jsi::Object paramOfTypeWithEnums) = 0;

};

template <typename T>
class JSI_EXPORT NativeEnumTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"NativeEnumTurboModule\\";

protected:
  NativeEnumTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeEnumTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeEnumTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeEnumTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::String getStatusRegular(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusRegular) == 2,
          \\"Expected getStatusRegular(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStatusRegular, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::String getStatusStr(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusStr) == 2,
          \\"Expected getStatusStr(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStatusStr, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::Value getStatusNum(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusNum) == 2,
          \\"Expected getStatusNum(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getStatusNum, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::String getStatusLowerCase(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusLowerCase) == 2,
          \\"Expected getStatusLowerCase(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStatusLowerCase, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::Object getStateType(jsi::Runtime &rt, jsi::String a, jsi::String b, jsi::Value c, jsi::String d) override {
      static_assert(
          bridging::getParameterCount(&T::getStateType) == 5,
          \\"Expected getStateType(...) to have 5 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getStateType, jsInvoker_, instance_, std::move(a), std::move(b), std::move(c), std::move(d));
    }
    jsi::Object getStateTypeWithEnums(jsi::Runtime &rt, jsi::Object paramOfTypeWithEnums) override {
      static_assert(
          bridging::getParameterCount(&T::getStateTypeWithEnums) == 2,
          \\"Expected getStateTypeWithEnums(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getStateTypeWithEnums, jsInvoker_, instance_, std::move(paramOfTypeWithEnums));
    }

  private:
    friend class NativeEnumTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeNullableTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNullableTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> a) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> a) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<double> a) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> a) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> a) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeNullableTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeNullableTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeNullableTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeNullableTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNullableTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> a) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(a));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> a) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<double> a) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> a) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> a) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 1,
          \\"Expected getValueWithPromise(...) to have 1 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_);
    }

  private:
    friend class NativeNullableTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeNumberTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNumberTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual double getNumberWithAlias(jsi::Runtime &rt, double arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeNumberTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeNumberTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeNumberTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeNumberTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNumberTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    double getNumberWithAlias(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumberWithAlias) == 2,
          \\"Expected getNumberWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumberWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    friend class NativeNumberTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeObjectTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeObjectTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getGenericObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getGenericObjectReadOnly(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getGenericObjectWithAlias(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object difficultObject(jsi::Runtime &rt, jsi::Object A) = 0;
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeObjectTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeObjectTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeObjectTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeObjectTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getGenericObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObject) == 2,
          \\"Expected getGenericObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getGenericObjectReadOnly(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObjectReadOnly) == 2,
          \\"Expected getGenericObjectReadOnly(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObjectReadOnly, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getGenericObjectWithAlias(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObjectWithAlias) == 2,
          \\"Expected getGenericObjectWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObjectWithAlias, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object difficultObject(jsi::Runtime &rt, jsi::Object A) override {
      static_assert(
          bridging::getParameterCount(&T::difficultObject) == 2,
          \\"Expected difficultObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::difficultObject, jsInvoker_, instance_, std::move(A));
    }
    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    friend class NativeObjectTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeOptionalObjectTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeOptionalObjectTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeOptionalObjectTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeOptionalObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeOptionalObjectTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeOptionalObjectTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeOptionalObjectTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    friend class NativeOptionalObjectTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativePartialAnnotationTurboModuleSomeObj

template <typename P0, typename P1>
struct NativePartialAnnotationTurboModuleSomeObj {
  P0 a;
  P1 b;
  bool operator==(const NativePartialAnnotationTurboModuleSomeObj &other) const {
    return a == other.a && b == other.b;
  }
};

template <typename T>
struct NativePartialAnnotationTurboModuleSomeObjBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.a)>(rt, value.getProperty(rt, \\"a\\"), jsInvoker),
      bridging::fromJs<decltype(types.b)>(rt, value.getProperty(rt, \\"b\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String aToJs(jsi::Runtime &rt, decltype(types.a) value) {
    return bridging::toJs(rt, value);
  }

  static bool bToJs(jsi::Runtime &rt, decltype(types.b) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"a\\", bridging::toJs(rt, value.a, jsInvoker));
    if (value.b) {
      result.setProperty(rt, \\"b\\", bridging::toJs(rt, value.b.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativePartialAnnotationTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativePartialAnnotationTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getSomeObj(jsi::Runtime &rt) = 0;
  virtual jsi::Object getPartialSomeObj(jsi::Runtime &rt) = 0;
  virtual jsi::Object getSomeObjFromPartialSomeObj(jsi::Runtime &rt, jsi::Object value) = 0;
  virtual jsi::Object getPartialPartial(jsi::Runtime &rt, jsi::Object value1, jsi::Object value2) = 0;

};

template <typename T>
class JSI_EXPORT NativePartialAnnotationTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"NativePartialAnnotationTurboModule\\";

protected:
  NativePartialAnnotationTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePartialAnnotationTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativePartialAnnotationTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePartialAnnotationTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getSomeObj(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getSomeObj) == 1,
          \\"Expected getSomeObj(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getSomeObj, jsInvoker_, instance_);
    }
    jsi::Object getPartialSomeObj(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getPartialSomeObj) == 1,
          \\"Expected getPartialSomeObj(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getPartialSomeObj, jsInvoker_, instance_);
    }
    jsi::Object getSomeObjFromPartialSomeObj(jsi::Runtime &rt, jsi::Object value) override {
      static_assert(
          bridging::getParameterCount(&T::getSomeObjFromPartialSomeObj) == 2,
          \\"Expected getSomeObjFromPartialSomeObj(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getSomeObjFromPartialSomeObj, jsInvoker_, instance_, std::move(value));
    }
    jsi::Object getPartialPartial(jsi::Runtime &rt, jsi::Object value1, jsi::Object value2) override {
      static_assert(
          bridging::getParameterCount(&T::getPartialPartial) == 3,
          \\"Expected getPartialPartial(...) to have 3 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getPartialPartial, jsInvoker_, instance_, std::move(value1), std::move(value2));
    }

  private:
    friend class NativePartialAnnotationTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativePromiseTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativePromiseTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;
  virtual jsi::Value getValueWithPromiseWithAlias(jsi::Runtime &rt, jsi::String arg) = 0;

};

template <typename T>
class JSI_EXPORT NativePromiseTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativePromiseTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePromiseTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativePromiseTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePromiseTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }
    jsi::Value getValueWithPromiseWithAlias(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromiseWithAlias) == 2,
          \\"Expected getValueWithPromiseWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromiseWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    friend class NativePromiseTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSampleTurboModuleAnimal

template <typename P0>
struct NativeSampleTurboModuleAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeSampleTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual bool getBool(jsi::Runtime &rt, bool arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getAlias(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual double getRootTag(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String getValuegetValuegetValuegetValuegetValuey, jsi::Object z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeSampleTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSampleTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    bool getBool(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getAlias(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    double getRootTag(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String getValuegetValuegetValuegetValuegetValuey, jsi::Object z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(getValuegetValuegetValuegetValuegetValuey), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    friend class NativeSampleTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSampleTurboModuleArraysAnimal

template <typename P0>
struct NativeSampleTurboModuleArraysAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleArraysAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleArraysAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeSampleTurboModuleArraysCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleArraysCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual jsi::Array getBool(jsi::Runtime &rt, jsi::Array id) = 0;
  virtual jsi::Array getNumber(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getString(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getObject(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getObjectShape(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getAlias(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getRootTag(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getValue(jsi::Runtime &rt, jsi::Array x, jsi::Array y, jsi::Array z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, jsi::Array error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleArraysCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModuleArrays\\";

protected:
  NativeSampleTurboModuleArraysCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleArraysCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSampleTurboModuleArraysCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleArraysCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    jsi::Array getBool(jsi::Runtime &rt, jsi::Array id) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(id));
    }
    jsi::Array getNumber(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getString(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getObject(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getObjectShape(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getAlias(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getRootTag(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getValue(jsi::Runtime &rt, jsi::Array x, jsi::Array y, jsi::Array z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, jsi::Array error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    friend class NativeSampleTurboModuleArraysCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSampleTurboModuleNullableAnimal

template <typename P0>
struct NativeSampleTurboModuleNullableAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleNullableAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleNullableAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeSampleTurboModuleNullableCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleNullableCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModuleNullable\\";

protected:
  NativeSampleTurboModuleNullableCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleNullableCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSampleTurboModuleNullableCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleNullableCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    friend class NativeSampleTurboModuleNullableCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSampleTurboModuleNullableAndOptionalAnimal

template <typename P0>
struct NativeSampleTurboModuleNullableAndOptionalAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleNullableAndOptionalAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleNullableAndOptionalAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.name) {
      result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableAndOptionalCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModuleNullableAndOptional\\";

protected:
  NativeSampleTurboModuleNullableAndOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleNullableAndOptionalCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    friend class NativeSampleTurboModuleNullableAndOptionalCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSampleTurboModuleOptionalAnimal

template <typename P0>
struct NativeSampleTurboModuleOptionalAnimal {
  P0 name;
  bool operator==(const NativeSampleTurboModuleOptionalAnimal &other) const {
    return name == other.name;
  }
};

template <typename T>
struct NativeSampleTurboModuleOptionalAnimalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.name) {
      result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeSampleTurboModuleOptionalCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleOptionalCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual bool getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual double getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleOptionalCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModuleOptional\\";

protected:
  NativeSampleTurboModuleOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleOptionalCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSampleTurboModuleOptionalCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleOptionalCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    bool getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    double getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    friend class NativeSampleTurboModuleOptionalCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeStringTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeStringTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::String getStringWithAlias(jsi::Runtime &rt, jsi::String arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeStringTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = \\"SampleTurboModule\\";

protected:
  NativeStringTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeStringTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeStringTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeStringTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getStringWithAlias(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getStringWithAlias) == 2,
          \\"Expected getStringWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStringWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    friend class NativeStringTurboModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
"
`;

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`GenerateModuleH can generate a header file NativeModule specs 1`] = `
"/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook {
namespace react {

class JSI_EXPORT NativeArrayTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeArrayTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array a) = 0;
  virtual jsi::Array getReadOnlyArray(jsi::Runtime &rt, jsi::Array a) = 0;
  virtual jsi::Array getArrayWithAlias(jsi::Runtime &rt, jsi::Array a, jsi::Array b) = 0;

};

template <typename T>
class JSI_EXPORT NativeArrayTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeArrayTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeArrayTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeArrayTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Array getArray(jsi::Runtime &rt, jsi::Array a) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(a));
    }
    jsi::Array getReadOnlyArray(jsi::Runtime &rt, jsi::Array a) override {
      static_assert(
          bridging::getParameterCount(&T::getReadOnlyArray) == 2,
          \\"Expected getReadOnlyArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getReadOnlyArray, jsInvoker_, instance_, std::move(a));
    }
    jsi::Array getArrayWithAlias(jsi::Runtime &rt, jsi::Array a, jsi::Array b) override {
      static_assert(
          bridging::getParameterCount(&T::getArrayWithAlias) == 3,
          \\"Expected getArrayWithAlias(...) to have 3 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArrayWithAlias, jsInvoker_, instance_, std::move(a), std::move(b));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeBooleanTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeBooleanTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual bool getBoolean(jsi::Runtime &rt, bool arg) = 0;
  virtual bool getBooleanWithAlias(jsi::Runtime &rt, bool arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeBooleanTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeBooleanTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeBooleanTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeBooleanTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    bool getBoolean(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBoolean) == 2,
          \\"Expected getBoolean(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBoolean, jsInvoker_, instance_, std::move(arg));
    }
    bool getBooleanWithAlias(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBooleanWithAlias) == 2,
          \\"Expected getBooleanWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBooleanWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeCallbackTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeCallbackTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void getValueWithCallbackWithAlias(jsi::Runtime &rt, jsi::Function c) = 0;

};

template <typename T>
class JSI_EXPORT NativeCallbackTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeCallbackTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeCallbackTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCallbackTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    void getValueWithCallbackWithAlias(jsi::Runtime &rt, jsi::Function c) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallbackWithAlias) == 2,
          \\"Expected getValueWithCallbackWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallbackWithAlias, jsInvoker_, instance_, std::move(c));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - NativeEnumTurboModuleBaseStateType

template <typename P0>
struct NativeEnumTurboModuleBaseStateType {
  P0 state;
  bool operator==(const NativeEnumTurboModuleBaseStateType &other) const {
    return state == other.state;
  }
};

template <typename P0>
struct NativeEnumTurboModuleBaseStateTypeBridging {
  static NativeEnumTurboModuleBaseStateType<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeEnumTurboModuleBaseStateType<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"state\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativeEnumTurboModuleBaseStateType<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
          return result;
        }
      };


#pragma mark - NativeEnumTurboModuleBaseStateTypeWithEnums

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeEnumTurboModuleBaseStateTypeWithEnums {
  P0 state;
  P1 regular;
  P2 str;
  P3 num;
  P4 fraction;
  bool operator==(const NativeEnumTurboModuleBaseStateTypeWithEnums &other) const {
    return state == other.state && regular == other.regular && str == other.str && num == other.num && fraction == other.fraction;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeEnumTurboModuleBaseStateTypeWithEnumsBridging {
  static NativeEnumTurboModuleBaseStateTypeWithEnums<P0, P1, P2, P3, P4> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeEnumTurboModuleBaseStateTypeWithEnums<P0, P1, P2, P3, P4> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"state\\"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, \\"regular\\"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, \\"str\\"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, \\"num\\"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, \\"fraction\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String regularToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String strToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static double numToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static double fractionToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativeEnumTurboModuleBaseStateTypeWithEnums<P0, P1, P2, P3, P4> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
    result.setProperty(rt, \\"regular\\", bridging::toJs(rt, value.regular, jsInvoker));
    result.setProperty(rt, \\"str\\", bridging::toJs(rt, value.str, jsInvoker));
    result.setProperty(rt, \\"num\\", bridging::toJs(rt, value.num, jsInvoker));
    result.setProperty(rt, \\"fraction\\", bridging::toJs(rt, value.fraction, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeEnumTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeEnumTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::String getStatusRegular(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::String getStatusStr(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual double getStatusNum(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual double getStatusFraction(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::Object getStateType(jsi::Runtime &rt, jsi::String a, jsi::String b, double c, double d) = 0;
  virtual jsi::Object getStateTypeWithEnums(jsi::Runtime &rt, jsi::Object paramOfTypeWithEnums) = 0;

};

template <typename T>
class JSI_EXPORT NativeEnumTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeEnumTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"NativeEnumTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeEnumTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeEnumTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::String getStatusRegular(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusRegular) == 2,
          \\"Expected getStatusRegular(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStatusRegular, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::String getStatusStr(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusStr) == 2,
          \\"Expected getStatusStr(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStatusStr, jsInvoker_, instance_, std::move(statusProp));
    }
    double getStatusNum(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusNum) == 2,
          \\"Expected getStatusNum(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getStatusNum, jsInvoker_, instance_, std::move(statusProp));
    }
    double getStatusFraction(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusFraction) == 2,
          \\"Expected getStatusFraction(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getStatusFraction, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::Object getStateType(jsi::Runtime &rt, jsi::String a, jsi::String b, double c, double d) override {
      static_assert(
          bridging::getParameterCount(&T::getStateType) == 5,
          \\"Expected getStateType(...) to have 5 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getStateType, jsInvoker_, instance_, std::move(a), std::move(b), std::move(c), std::move(d));
    }
    jsi::Object getStateTypeWithEnums(jsi::Runtime &rt, jsi::Object paramOfTypeWithEnums) override {
      static_assert(
          bridging::getParameterCount(&T::getStateTypeWithEnums) == 2,
          \\"Expected getStateTypeWithEnums(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getStateTypeWithEnums, jsInvoker_, instance_, std::move(paramOfTypeWithEnums));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeNullableTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNullableTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> a) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> a) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<double> a) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> a) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> a) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeNullableTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeNullableTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeNullableTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNullableTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> a) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(a));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> a) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<double> a) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> a) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> a) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 1,
          \\"Expected getValueWithPromise(...) to have 1 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeNumberTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNumberTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual double getNumberWithAlias(jsi::Runtime &rt, double arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeNumberTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeNumberTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeNumberTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNumberTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    double getNumberWithAlias(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumberWithAlias) == 2,
          \\"Expected getNumberWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumberWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeObjectTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeObjectTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getGenericObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getGenericObjectReadOnly(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getGenericObjectWithAlias(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object difficultObject(jsi::Runtime &rt, jsi::Object A) = 0;
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeObjectTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeObjectTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeObjectTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getGenericObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObject) == 2,
          \\"Expected getGenericObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getGenericObjectReadOnly(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObjectReadOnly) == 2,
          \\"Expected getGenericObjectReadOnly(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObjectReadOnly, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getGenericObjectWithAlias(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObjectWithAlias) == 2,
          \\"Expected getGenericObjectWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObjectWithAlias, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object difficultObject(jsi::Runtime &rt, jsi::Object A) override {
      static_assert(
          bridging::getParameterCount(&T::difficultObject) == 2,
          \\"Expected difficultObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::difficultObject, jsInvoker_, instance_, std::move(A));
    }
    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeOptionalObjectTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeOptionalObjectTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeOptionalObjectTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeOptionalObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeOptionalObjectTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeOptionalObjectTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - NativePartialAnnotationTurboModuleBaseSomeObj

template <typename P0, typename P1>
struct NativePartialAnnotationTurboModuleBaseSomeObj {
  P0 a;
  P1 b;
  bool operator==(const NativePartialAnnotationTurboModuleBaseSomeObj &other) const {
    return a == other.a && b == other.b;
  }
};

template <typename P0, typename P1>
struct NativePartialAnnotationTurboModuleBaseSomeObjBridging {
  static NativePartialAnnotationTurboModuleBaseSomeObj<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativePartialAnnotationTurboModuleBaseSomeObj<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"a\\"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, \\"b\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String aToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static bool bToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativePartialAnnotationTurboModuleBaseSomeObj<P0, P1> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"a\\", bridging::toJs(rt, value.a, jsInvoker));
    if (value.b) {
            result.setProperty(rt, \\"b\\", bridging::toJs(rt, value.b.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativePartialAnnotationTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativePartialAnnotationTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getSomeObj(jsi::Runtime &rt) = 0;
  virtual jsi::Object getPartialSomeObj(jsi::Runtime &rt) = 0;
  virtual jsi::Object getSomeObjFromPartialSomeObj(jsi::Runtime &rt, jsi::Object value) = 0;
  virtual jsi::Object getPartialPartial(jsi::Runtime &rt, jsi::Object value1, jsi::Object value2) = 0;

};

template <typename T>
class JSI_EXPORT NativePartialAnnotationTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePartialAnnotationTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"NativePartialAnnotationTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePartialAnnotationTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePartialAnnotationTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getSomeObj(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getSomeObj) == 1,
          \\"Expected getSomeObj(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getSomeObj, jsInvoker_, instance_);
    }
    jsi::Object getPartialSomeObj(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getPartialSomeObj) == 1,
          \\"Expected getPartialSomeObj(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getPartialSomeObj, jsInvoker_, instance_);
    }
    jsi::Object getSomeObjFromPartialSomeObj(jsi::Runtime &rt, jsi::Object value) override {
      static_assert(
          bridging::getParameterCount(&T::getSomeObjFromPartialSomeObj) == 2,
          \\"Expected getSomeObjFromPartialSomeObj(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getSomeObjFromPartialSomeObj, jsInvoker_, instance_, std::move(value));
    }
    jsi::Object getPartialPartial(jsi::Runtime &rt, jsi::Object value1, jsi::Object value2) override {
      static_assert(
          bridging::getParameterCount(&T::getPartialPartial) == 3,
          \\"Expected getPartialPartial(...) to have 3 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getPartialPartial, jsInvoker_, instance_, std::move(value1), std::move(value2));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativePromiseTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativePromiseTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;
  virtual jsi::Value getValueWithPromiseWithAlias(jsi::Runtime &rt, jsi::String arg) = 0;

};

template <typename T>
class JSI_EXPORT NativePromiseTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePromiseTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePromiseTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePromiseTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }
    jsi::Value getValueWithPromiseWithAlias(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromiseWithAlias) == 2,
          \\"Expected getValueWithPromiseWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromiseWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - SampleTurboModuleBaseAnimal

template <typename P0>
struct SampleTurboModuleBaseAnimal {
  P0 name;
  bool operator==(const SampleTurboModuleBaseAnimal &other) const {
    return name == other.name;
  }
};

template <typename P0>
struct SampleTurboModuleBaseAnimalBridging {
  static SampleTurboModuleBaseAnimal<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SampleTurboModuleBaseAnimal<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const SampleTurboModuleBaseAnimal<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeSampleTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual bool getBool(jsi::Runtime &rt, bool arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getAlias(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual double getRootTag(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String getValuegetValuegetValuegetValuegetValuey, jsi::Object z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    bool getBool(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getAlias(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    double getRootTag(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String getValuegetValuegetValuegetValuegetValuey, jsi::Object z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(getValuegetValuegetValuegetValuegetValuey), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - SampleTurboModuleArraysBaseAnimal

template <typename P0>
struct SampleTurboModuleArraysBaseAnimal {
  P0 name;
  bool operator==(const SampleTurboModuleArraysBaseAnimal &other) const {
    return name == other.name;
  }
};

template <typename P0>
struct SampleTurboModuleArraysBaseAnimalBridging {
  static SampleTurboModuleArraysBaseAnimal<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SampleTurboModuleArraysBaseAnimal<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const SampleTurboModuleArraysBaseAnimal<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeSampleTurboModuleArraysCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleArraysCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual jsi::Array getBool(jsi::Runtime &rt, jsi::Array id) = 0;
  virtual jsi::Array getNumber(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getString(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getObject(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getObjectShape(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getAlias(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getRootTag(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getValue(jsi::Runtime &rt, jsi::Array x, jsi::Array y, jsi::Array z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, jsi::Array error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleArraysCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleArraysCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModuleArrays\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleArraysCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleArraysCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    jsi::Array getBool(jsi::Runtime &rt, jsi::Array id) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(id));
    }
    jsi::Array getNumber(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getString(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getObject(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getObjectShape(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getAlias(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getRootTag(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getValue(jsi::Runtime &rt, jsi::Array x, jsi::Array y, jsi::Array z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, jsi::Array error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - SampleTurboModuleNullableBaseAnimal

template <typename P0>
struct SampleTurboModuleNullableBaseAnimal {
  P0 name;
  bool operator==(const SampleTurboModuleNullableBaseAnimal &other) const {
    return name == other.name;
  }
};

template <typename P0>
struct SampleTurboModuleNullableBaseAnimalBridging {
  static SampleTurboModuleNullableBaseAnimal<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SampleTurboModuleNullableBaseAnimal<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const SampleTurboModuleNullableBaseAnimal<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeSampleTurboModuleNullableCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleNullableCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleNullableCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModuleNullable\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleNullableCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleNullableCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - SampleTurboModuleNullableAndOptionalBaseAnimal

template <typename P0>
struct SampleTurboModuleNullableAndOptionalBaseAnimal {
  P0 name;
  bool operator==(const SampleTurboModuleNullableAndOptionalBaseAnimal &other) const {
    return name == other.name;
  }
};

template <typename P0>
struct SampleTurboModuleNullableAndOptionalBaseAnimalBridging {
  static SampleTurboModuleNullableAndOptionalBaseAnimal<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SampleTurboModuleNullableAndOptionalBaseAnimal<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const SampleTurboModuleNullableAndOptionalBaseAnimal<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          if (value.name) {
            result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableAndOptionalCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleNullableAndOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModuleNullableAndOptional\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - SampleTurboModuleOptionalBaseAnimal

template <typename P0>
struct SampleTurboModuleOptionalBaseAnimal {
  P0 name;
  bool operator==(const SampleTurboModuleOptionalBaseAnimal &other) const {
    return name == other.name;
  }
};

template <typename P0>
struct SampleTurboModuleOptionalBaseAnimalBridging {
  static SampleTurboModuleOptionalBaseAnimal<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SampleTurboModuleOptionalBaseAnimal<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const SampleTurboModuleOptionalBaseAnimal<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          if (value.name) {
            result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativeSampleTurboModuleOptionalCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleOptionalCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual bool getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual double getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleOptionalCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModuleOptional\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleOptionalCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleOptionalCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    bool getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    double getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeStringTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeStringTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::String getStringWithAlias(jsi::Runtime &rt, jsi::String arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeStringTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeStringTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeStringTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeStringTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getStringWithAlias(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getStringWithAlias) == 2,
          \\"Expected getStringWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStringWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace react
} // namespace facebook
"
`;

exports[`GenerateModuleH can generate a header file NativeModule specs with assume nonnull enabled 1`] = `
"/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook {
namespace react {

class JSI_EXPORT NativeArrayTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeArrayTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array a) = 0;
  virtual jsi::Array getReadOnlyArray(jsi::Runtime &rt, jsi::Array a) = 0;
  virtual jsi::Array getArrayWithAlias(jsi::Runtime &rt, jsi::Array a, jsi::Array b) = 0;

};

template <typename T>
class JSI_EXPORT NativeArrayTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeArrayTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeArrayTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeArrayTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Array getArray(jsi::Runtime &rt, jsi::Array a) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(a));
    }
    jsi::Array getReadOnlyArray(jsi::Runtime &rt, jsi::Array a) override {
      static_assert(
          bridging::getParameterCount(&T::getReadOnlyArray) == 2,
          \\"Expected getReadOnlyArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getReadOnlyArray, jsInvoker_, instance_, std::move(a));
    }
    jsi::Array getArrayWithAlias(jsi::Runtime &rt, jsi::Array a, jsi::Array b) override {
      static_assert(
          bridging::getParameterCount(&T::getArrayWithAlias) == 3,
          \\"Expected getArrayWithAlias(...) to have 3 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArrayWithAlias, jsInvoker_, instance_, std::move(a), std::move(b));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeBooleanTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeBooleanTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual bool getBoolean(jsi::Runtime &rt, bool arg) = 0;
  virtual bool getBooleanWithAlias(jsi::Runtime &rt, bool arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeBooleanTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeBooleanTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeBooleanTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeBooleanTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    bool getBoolean(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBoolean) == 2,
          \\"Expected getBoolean(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBoolean, jsInvoker_, instance_, std::move(arg));
    }
    bool getBooleanWithAlias(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBooleanWithAlias) == 2,
          \\"Expected getBooleanWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBooleanWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeCallbackTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeCallbackTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void getValueWithCallbackWithAlias(jsi::Runtime &rt, jsi::Function c) = 0;

};

template <typename T>
class JSI_EXPORT NativeCallbackTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeCallbackTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeCallbackTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCallbackTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    void getValueWithCallbackWithAlias(jsi::Runtime &rt, jsi::Function c) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallbackWithAlias) == 2,
          \\"Expected getValueWithCallbackWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallbackWithAlias, jsInvoker_, instance_, std::move(c));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - NativeEnumTurboModuleBaseStateType

template <typename P0>
struct NativeEnumTurboModuleBaseStateType {
  P0 state;
  bool operator==(const NativeEnumTurboModuleBaseStateType &other) const {
    return state == other.state;
  }
};

template <typename P0>
struct NativeEnumTurboModuleBaseStateTypeBridging {
  static NativeEnumTurboModuleBaseStateType<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeEnumTurboModuleBaseStateType<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"state\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativeEnumTurboModuleBaseStateType<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
          return result;
        }
      };


#pragma mark - NativeEnumTurboModuleBaseStateTypeWithEnums

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeEnumTurboModuleBaseStateTypeWithEnums {
  P0 state;
  P1 regular;
  P2 str;
  P3 num;
  P4 fraction;
  bool operator==(const NativeEnumTurboModuleBaseStateTypeWithEnums &other) const {
    return state == other.state && regular == other.regular && str == other.str && num == other.num && fraction == other.fraction;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeEnumTurboModuleBaseStateTypeWithEnumsBridging {
  static NativeEnumTurboModuleBaseStateTypeWithEnums<P0, P1, P2, P3, P4> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeEnumTurboModuleBaseStateTypeWithEnums<P0, P1, P2, P3, P4> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"state\\"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, \\"regular\\"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, \\"str\\"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, \\"num\\"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, \\"fraction\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String stateToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String regularToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String strToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static double numToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static double fractionToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativeEnumTurboModuleBaseStateTypeWithEnums<P0, P1, P2, P3, P4> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"state\\", bridging::toJs(rt, value.state, jsInvoker));
    result.setProperty(rt, \\"regular\\", bridging::toJs(rt, value.regular, jsInvoker));
    result.setProperty(rt, \\"str\\", bridging::toJs(rt, value.str, jsInvoker));
    result.setProperty(rt, \\"num\\", bridging::toJs(rt, value.num, jsInvoker));
    result.setProperty(rt, \\"fraction\\", bridging::toJs(rt, value.fraction, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeEnumTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeEnumTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::String getStatusRegular(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::String getStatusStr(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual double getStatusNum(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual double getStatusFraction(jsi::Runtime &rt, jsi::Object statusProp) = 0;
  virtual jsi::Object getStateType(jsi::Runtime &rt, jsi::String a, jsi::String b, double c, double d) = 0;
  virtual jsi::Object getStateTypeWithEnums(jsi::Runtime &rt, jsi::Object paramOfTypeWithEnums) = 0;

};

template <typename T>
class JSI_EXPORT NativeEnumTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeEnumTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"NativeEnumTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeEnumTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeEnumTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::String getStatusRegular(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusRegular) == 2,
          \\"Expected getStatusRegular(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStatusRegular, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::String getStatusStr(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusStr) == 2,
          \\"Expected getStatusStr(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStatusStr, jsInvoker_, instance_, std::move(statusProp));
    }
    double getStatusNum(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusNum) == 2,
          \\"Expected getStatusNum(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getStatusNum, jsInvoker_, instance_, std::move(statusProp));
    }
    double getStatusFraction(jsi::Runtime &rt, jsi::Object statusProp) override {
      static_assert(
          bridging::getParameterCount(&T::getStatusFraction) == 2,
          \\"Expected getStatusFraction(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getStatusFraction, jsInvoker_, instance_, std::move(statusProp));
    }
    jsi::Object getStateType(jsi::Runtime &rt, jsi::String a, jsi::String b, double c, double d) override {
      static_assert(
          bridging::getParameterCount(&T::getStateType) == 5,
          \\"Expected getStateType(...) to have 5 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getStateType, jsInvoker_, instance_, std::move(a), std::move(b), std::move(c), std::move(d));
    }
    jsi::Object getStateTypeWithEnums(jsi::Runtime &rt, jsi::Object paramOfTypeWithEnums) override {
      static_assert(
          bridging::getParameterCount(&T::getStateTypeWithEnums) == 2,
          \\"Expected getStateTypeWithEnums(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getStateTypeWithEnums, jsInvoker_, instance_, std::move(paramOfTypeWithEnums));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeNullableTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNullableTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> a) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> a) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<double> a) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> a) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> a) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeNullableTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeNullableTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeNullableTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNullableTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> a) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(a));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> a) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<double> a) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> a) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> a) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(a));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 1,
          \\"Expected getValueWithPromise(...) to have 1 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeNumberTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNumberTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual double getNumberWithAlias(jsi::Runtime &rt, double arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeNumberTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeNumberTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeNumberTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNumberTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    double getNumberWithAlias(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumberWithAlias) == 2,
          \\"Expected getNumberWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumberWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeObjectTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeObjectTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getGenericObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getGenericObjectReadOnly(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getGenericObjectWithAlias(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object difficultObject(jsi::Runtime &rt, jsi::Object A) = 0;
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeObjectTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeObjectTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeObjectTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getGenericObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObject) == 2,
          \\"Expected getGenericObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getGenericObjectReadOnly(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObjectReadOnly) == 2,
          \\"Expected getGenericObjectReadOnly(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObjectReadOnly, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getGenericObjectWithAlias(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGenericObjectWithAlias) == 2,
          \\"Expected getGenericObjectWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGenericObjectWithAlias, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object difficultObject(jsi::Runtime &rt, jsi::Object A) override {
      static_assert(
          bridging::getParameterCount(&T::difficultObject) == 2,
          \\"Expected difficultObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::difficultObject, jsInvoker_, instance_, std::move(A));
    }
    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeOptionalObjectTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeOptionalObjectTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeOptionalObjectTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeOptionalObjectTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeOptionalObjectTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeOptionalObjectTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - NativePartialAnnotationTurboModuleBaseSomeObj

template <typename P0, typename P1>
struct NativePartialAnnotationTurboModuleBaseSomeObj {
  P0 a;
  P1 b;
  bool operator==(const NativePartialAnnotationTurboModuleBaseSomeObj &other) const {
    return a == other.a && b == other.b;
  }
};

template <typename P0, typename P1>
struct NativePartialAnnotationTurboModuleBaseSomeObjBridging {
  static NativePartialAnnotationTurboModuleBaseSomeObj<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativePartialAnnotationTurboModuleBaseSomeObj<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"a\\"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, \\"b\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String aToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static bool bToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativePartialAnnotationTurboModuleBaseSomeObj<P0, P1> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"a\\", bridging::toJs(rt, value.a, jsInvoker));
    if (value.b) {
            result.setProperty(rt, \\"b\\", bridging::toJs(rt, value.b.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativePartialAnnotationTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativePartialAnnotationTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getSomeObj(jsi::Runtime &rt) = 0;
  virtual jsi::Object getPartialSomeObj(jsi::Runtime &rt) = 0;
  virtual jsi::Object getSomeObjFromPartialSomeObj(jsi::Runtime &rt, jsi::Object value) = 0;
  virtual jsi::Object getPartialPartial(jsi::Runtime &rt, jsi::Object value1, jsi::Object value2) = 0;

};

template <typename T>
class JSI_EXPORT NativePartialAnnotationTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePartialAnnotationTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"NativePartialAnnotationTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePartialAnnotationTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePartialAnnotationTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getSomeObj(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getSomeObj) == 1,
          \\"Expected getSomeObj(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getSomeObj, jsInvoker_, instance_);
    }
    jsi::Object getPartialSomeObj(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getPartialSomeObj) == 1,
          \\"Expected getPartialSomeObj(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getPartialSomeObj, jsInvoker_, instance_);
    }
    jsi::Object getSomeObjFromPartialSomeObj(jsi::Runtime &rt, jsi::Object value) override {
      static_assert(
          bridging::getParameterCount(&T::getSomeObjFromPartialSomeObj) == 2,
          \\"Expected getSomeObjFromPartialSomeObj(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getSomeObjFromPartialSomeObj, jsInvoker_, instance_, std::move(value));
    }
    jsi::Object getPartialPartial(jsi::Runtime &rt, jsi::Object value1, jsi::Object value2) override {
      static_assert(
          bridging::getParameterCount(&T::getPartialPartial) == 3,
          \\"Expected getPartialPartial(...) to have 3 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getPartialPartial, jsInvoker_, instance_, std::move(value1), std::move(value2));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativePromiseTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativePromiseTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;
  virtual jsi::Value getValueWithPromiseWithAlias(jsi::Runtime &rt, jsi::String arg) = 0;

};

template <typename T>
class JSI_EXPORT NativePromiseTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePromiseTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePromiseTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePromiseTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }
    jsi::Value getValueWithPromiseWithAlias(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromiseWithAlias) == 2,
          \\"Expected getValueWithPromiseWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromiseWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - SampleTurboModuleBaseAnimal

template <typename P0>
struct SampleTurboModuleBaseAnimal {
  P0 name;
  bool operator==(const SampleTurboModuleBaseAnimal &other) const {
    return name == other.name;
  }
};

template <typename P0>
struct SampleTurboModuleBaseAnimalBridging {
  static SampleTurboModuleBaseAnimal<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SampleTurboModuleBaseAnimal<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const SampleTurboModuleBaseAnimal<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeSampleTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual bool getBool(jsi::Runtime &rt, bool arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getAlias(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual double getRootTag(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String getValuegetValuegetValuegetValuegetValuey, jsi::Object z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    bool getBool(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getAlias(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    double getRootTag(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String getValuegetValuegetValuegetValuegetValuey, jsi::Object z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(getValuegetValuegetValuegetValuegetValuey), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - SampleTurboModuleArraysBaseAnimal

template <typename P0>
struct SampleTurboModuleArraysBaseAnimal {
  P0 name;
  bool operator==(const SampleTurboModuleArraysBaseAnimal &other) const {
    return name == other.name;
  }
};

template <typename P0>
struct SampleTurboModuleArraysBaseAnimalBridging {
  static SampleTurboModuleArraysBaseAnimal<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SampleTurboModuleArraysBaseAnimal<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const SampleTurboModuleArraysBaseAnimal<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeSampleTurboModuleArraysCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleArraysCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual jsi::Array getBool(jsi::Runtime &rt, jsi::Array id) = 0;
  virtual jsi::Array getNumber(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getString(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getObject(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getObjectShape(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getAlias(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getRootTag(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Array getValue(jsi::Runtime &rt, jsi::Array x, jsi::Array y, jsi::Array z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, jsi::Array error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleArraysCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleArraysCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModuleArrays\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleArraysCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleArraysCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    jsi::Array getBool(jsi::Runtime &rt, jsi::Array id) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(id));
    }
    jsi::Array getNumber(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getString(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getObject(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getObjectShape(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getAlias(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getRootTag(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getValue(jsi::Runtime &rt, jsi::Array x, jsi::Array y, jsi::Array z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, jsi::Array error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - SampleTurboModuleNullableBaseAnimal

template <typename P0>
struct SampleTurboModuleNullableBaseAnimal {
  P0 name;
  bool operator==(const SampleTurboModuleNullableBaseAnimal &other) const {
    return name == other.name;
  }
};

template <typename P0>
struct SampleTurboModuleNullableBaseAnimalBridging {
  static SampleTurboModuleNullableBaseAnimal<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SampleTurboModuleNullableBaseAnimal<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const SampleTurboModuleNullableBaseAnimal<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeSampleTurboModuleNullableCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleNullableCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleNullableCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModuleNullable\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleNullableCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleNullableCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - SampleTurboModuleNullableAndOptionalBaseAnimal

template <typename P0>
struct SampleTurboModuleNullableAndOptionalBaseAnimal {
  P0 name;
  bool operator==(const SampleTurboModuleNullableAndOptionalBaseAnimal &other) const {
    return name == other.name;
  }
};

template <typename P0>
struct SampleTurboModuleNullableAndOptionalBaseAnimalBridging {
  static SampleTurboModuleNullableAndOptionalBaseAnimal<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SampleTurboModuleNullableAndOptionalBaseAnimal<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const SampleTurboModuleNullableAndOptionalBaseAnimal<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          if (value.name) {
            result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) = 0;
  virtual std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleNullableAndOptionalCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleNullableAndOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModuleNullableAndOptional\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleNullableAndOptionalCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    std::optional<bool> getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::String> getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Array> getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Array>>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<double> getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<double>>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    std::optional<jsi::Object> getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    std::optional<jsi::Value> getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<std::optional<jsi::Value>>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

#pragma mark - SampleTurboModuleOptionalBaseAnimal

template <typename P0>
struct SampleTurboModuleOptionalBaseAnimal {
  P0 name;
  bool operator==(const SampleTurboModuleOptionalBaseAnimal &other) const {
    return name == other.name;
  }
};

template <typename P0>
struct SampleTurboModuleOptionalBaseAnimalBridging {
  static SampleTurboModuleOptionalBaseAnimal<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SampleTurboModuleOptionalBaseAnimal<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, \\"name\\"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const SampleTurboModuleOptionalBaseAnimal<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          if (value.name) {
            result.setProperty(rt, \\"name\\", bridging::toJs(rt, value.name.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativeSampleTurboModuleOptionalCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleOptionalCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual bool getBool(jsi::Runtime &rt, std::optional<bool> arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, std::optional<jsi::String> arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual jsi::Object getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) = 0;
  virtual double getRootTag(jsi::Runtime &rt, std::optional<double> arg) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleOptionalCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleOptionalCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModuleOptional\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleOptionalCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleOptionalCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          \\"Expected getConstants(...) to have 1 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          \\"Expected voidFunc(...) to have 1 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    bool getBool(jsi::Runtime &rt, std::optional<bool> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          \\"Expected getBool(...) to have 2 parameters\\");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          \\"Expected getNumber(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, std::optional<jsi::String> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, std::optional<jsi::Array> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          \\"Expected getArray(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          \\"Expected getObject(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObjectShape(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectShape) == 2,
          \\"Expected getObjectShape(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectShape, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getAlias(jsi::Runtime &rt, std::optional<jsi::Object> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getAlias) == 2,
          \\"Expected getAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getAlias, jsInvoker_, instance_, std::move(arg));
    }
    double getRootTag(jsi::Runtime &rt, std::optional<double> arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          \\"Expected getRootTag(...) to have 2 parameters\\");

      return bridging::callFromJs<double>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getValue(jsi::Runtime &rt, std::optional<double> x, std::optional<jsi::String> y, std::optional<jsi::Object> z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          \\"Expected getValue(...) to have 4 parameters\\");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          \\"Expected getValueWithCallback(...) to have 2 parameters\\");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, std::optional<bool> error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          \\"Expected getValueWithPromise(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

class JSI_EXPORT NativeStringTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeStringTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::String getStringWithAlias(jsi::Runtime &rt, jsi::String arg) = 0;

};

template <typename T>
class JSI_EXPORT NativeStringTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeStringTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(\\"SampleTurboModule\\", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeStringTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeStringTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          \\"Expected getString(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getStringWithAlias(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getStringWithAlias) == 2,
          \\"Expected getStringWithAlias(...) to have 2 parameters\\");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStringWithAlias, jsInvoker_, instance_, std::move(arg));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace react
} // namespace facebook
"
`;

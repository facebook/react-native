/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict-local
 * @format
 */

import type {PluginObj} from '@babel/core';

import * as t from '@babel/types';

/**
 * Renames local symbols which are exported by default using the pattern
 * generated by flow-api-translator.
 * It checks which symbol is default-exported (if any), then it looks for
 * a variable declaration in form of:
 * `declare const ExportedSymbol: typeof LocalSymbol`
 * or declarations of classes and functions to figure out the local name of
 * the symbol. Finally, it replaces occurences of the local symbol by suffixing
 * it with `_default`.
 */
const visitor: PluginObj<mixed> = {
  visitor: {
    Program(nodePath) {
      let localSymbol: ?string = null;
      let exportedSymbol: ?string = null;

      nodePath.traverse({
        ExportDefaultDeclaration(innerPath) {
          if (
            t.isTSDeclareFunction(innerPath.node.declaration) ||
            t.isClassDeclaration(innerPath.node.declaration) ||
            t.isFunctionDeclaration(innerPath.node.declaration)
          ) {
            exportedSymbol = localSymbol = innerPath.node.declaration.id?.name;
          } else {
            exportedSymbol = innerPath.node.declaration.name;
          }
        },
      });

      if (exportedSymbol == null) {
        return;
      }

      // the exported symbol wasn't declared inline or is anonymous
      if (localSymbol == null) {
        nodePath.traverse({
          VariableDeclarator(innerPath) {
            if (innerPath.node.id.name !== exportedSymbol) {
              return;
            }

            if (t.isTSTypeAnnotation(innerPath.node.id.typeAnnotation)) {
              const typeAnnotation = innerPath.node.id.typeAnnotation;

              if (t.isTSTypeQuery(typeAnnotation.typeAnnotation)) {
                const expr = typeAnnotation.typeAnnotation.exprName;

                if (t.isIdentifier(expr)) {
                  localSymbol = expr.name;
                }
              }
            }
          },
          ClassDeclaration(innerPath) {
            if (innerPath.node.id?.name !== exportedSymbol) {
              return;
            }

            localSymbol = innerPath.node.id.name;
          },
          FunctionDeclaration(innerPath) {
            if (innerPath.node.id?.name !== exportedSymbol) {
              return;
            }

            localSymbol = innerPath.node.id.name;
          },
          TSDeclareFunction(innerPath) {
            if (innerPath.node.id?.name !== exportedSymbol) {
              return;
            }

            localSymbol = innerPath.node.id.name;
          },
        });
      }

      if (localSymbol == null) {
        return;
      }

      const newName = `${localSymbol}_default`;
      nodePath.traverse({
        Identifier(innerPath) {
          if (
            innerPath.node.name === localSymbol &&
            !innerPath.findParent(
              path => t.isMemberExpression(path) || t.isTSQualifiedName(path),
            )
          ) {
            innerPath.node.name = newName;
          }
        },
      });
    },
  },
};

module.exports = visitor;

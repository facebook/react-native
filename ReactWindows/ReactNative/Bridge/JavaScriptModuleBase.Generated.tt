<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
var maxArgs = 4;
var ordinals = new[]
{
	"first",
	"second",
	"third",
	"fourth",
	"fifth",
	"sixth",
	"seventh",
};
#>
using System.Runtime.CompilerServices;

namespace ReactNative.Bridge
{
    /// <summary>
    /// Base class for <see cref="IJavaScriptModule"/>s.
    /// </summary>
    public abstract partial class JavaScriptModuleBase : IJavaScriptModule
    {
<#
for (var i = 0; i <= maxArgs; ++i)
{
    var paramNames = Enumerable.Range(0, i).Select(x => "arg" + x).ToList();
	var paramArgs = paramNames.Select(x => "object " + x).ToList();
#>
		/// <summary>
        /// Invoke a JavaScript method with the given arguments.
        /// </summary>
<#
    for (var j = 0; j < i; ++j)
	{
#>
        /// <param name="<#=paramNames[j]#>">The <#=ordinals[j]#> argument.</param>
<#
    }
#>
        /// <param name="caller">
        /// The name of the method. This parameter may be ignored if the name
        /// of the native method matches the name of the JavaScript method. The
        /// method name will be filled in automatically using the
        /// <see cref="CallerMemberNameAttribute"/>.
        /// </param>
        /// <remarks>
        /// The expectation is that <see cref="IJavaScriptModule"/>s will use
        /// this method to notify the framework of a JavaScript call to be
        /// executed. This is to overcome the absense of a performant "proxy"
        /// implementation in the .NET framework.
        /// </remarks>
		protected void Invoke(<#=string.Join("", paramArgs.Select(x => x + ", "))#>[CallerMemberName]string caller = null)
		{
<#
    if (i == 0)
	{
#>
			Invoke(default(object[]), caller);
<#
    }
	else
	{
#>
			Invoke(new[] { <#=string.Join(", ", paramNames)#> }, caller);
<#
    }
#>
		}

<#
}
#>
    }
}
/**
 * @generated
 */
var React = require("React");
var Layout = require("AutodocsLayout");
var content = `\{
  "methods": [
    \{
      "line": 279,
      "source": "create: function (config) \{\\n    const interactionState = \{\\n      handle: (null: ?number),\\n    };\\n    const gestureState = \{\\n      // Useful for debugging\\n      stateID: Math.random(),\\n    };\\n    PanResponder._initializeGestureState(gestureState);\\n    const panHandlers = \{\\n      onStartShouldSetResponder: function (e) \{\\n        return config.onStartShouldSetPanResponder === undefined ?\\n          false :\\n          config.onStartShouldSetPanResponder(e, gestureState);\\n      },\\n      onMoveShouldSetResponder: function (e) \{\\n        return config.onMoveShouldSetPanResponder === undefined ?\\n          false :\\n          config.onMoveShouldSetPanResponder(e, gestureState);\\n      },\\n      onStartShouldSetResponderCapture: function (e) \{\\n        // TODO: Actually, we should reinitialize the state any time\\n        // touches.length increases from 0 active to > 0 active.\\n        if (e.nativeEvent.touches.length === 1) \{\\n          PanResponder._initializeGestureState(gestureState);\\n        }\\n        gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;\\n        return config.onStartShouldSetPanResponderCapture !== undefined ?\\n          config.onStartShouldSetPanResponderCapture(e, gestureState) :\\n          false;\\n      },\\n\\n      onMoveShouldSetResponderCapture: function (e) \{\\n        const touchHistory = e.touchHistory;\\n        // Responder system incorrectly dispatches should* to current responder\\n        // Filter out any touch moves past the first one - we would have\\n        // already processed multi-touch geometry during the first event.\\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) \{\\n          return false;\\n        }\\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\\n        return config.onMoveShouldSetPanResponderCapture ?\\n          config.onMoveShouldSetPanResponderCapture(e, gestureState) :\\n          false;\\n      },\\n\\n      onResponderGrant: function (e) \{\\n        if (!interactionState.handle) \{\\n          interactionState.handle = InteractionManager.createInteractionHandle();\\n        }\\n        gestureState.x0 = currentCentroidX(e.touchHistory);\\n        gestureState.y0 = currentCentroidY(e.touchHistory);\\n        gestureState.dx = 0;\\n        gestureState.dy = 0;\\n        if (config.onPanResponderGrant) \{\\n          config.onPanResponderGrant(e, gestureState);\\n        }\\n        // TODO: t7467124 investigate if this can be removed\\n        return config.onShouldBlockNativeResponder === undefined ?\\n          true :\\n          config.onShouldBlockNativeResponder();\\n      },\\n\\n      onResponderReject: function (e) \{\\n        clearInteractionHandle(interactionState, config.onPanResponderReject, e, gestureState);\\n      },\\n\\n      onResponderRelease: function (e) \{\\n        clearInteractionHandle(interactionState, config.onPanResponderRelease, e, gestureState);\\n        PanResponder._initializeGestureState(gestureState);\\n      },\\n\\n      onResponderStart: function (e) \{\\n        const touchHistory = e.touchHistory;\\n        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\\n        if (config.onPanResponderStart) \{\\n          config.onPanResponderStart(e, gestureState);\\n        }\\n      },\\n\\n      onResponderMove: function (e) \{\\n        const touchHistory = e.touchHistory;\\n        // Guard against the dispatch of two touch moves when there are two\\n        // simultaneously changed touches.\\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) \{\\n          return;\\n        }\\n        // Filter out any touch moves past the first one - we would have\\n        // already processed multi-touch geometry during the first event.\\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\\n        if (config.onPanResponderMove) \{\\n          config.onPanResponderMove(e, gestureState);\\n        }\\n      },\\n\\n      onResponderEnd: function (e) \{\\n        const touchHistory = e.touchHistory;\\n        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\\n        clearInteractionHandle(interactionState, config.onPanResponderEnd, e, gestureState);\\n      },\\n\\n      onResponderTerminate: function (e) \{\\n        clearInteractionHandle(interactionState, config.onPanResponderTerminate, e, gestureState);\\n        PanResponder._initializeGestureState(gestureState);\\n      },\\n\\n      onResponderTerminationRequest: function (e) \{\\n        return config.onPanResponderTerminationRequest === undefined ?\\n          true :\\n          config.onPanResponderTerminationRequest(e, gestureState);\\n      }\\n    };\\n    return \{\\n      panHandlers,\\n      getInteractionHandle(): ?number \{\\n        return interactionState.handle;\\n      },\\n    };\\n  }",
      "docblock": "/**\\n   * @param \{object} config Enhanced versions of all of the responder callbacks\\n   * that provide not only the typical \`ResponderSyntheticEvent\`, but also the\\n   * \`PanResponder\` gesture state.  Simply replace the word \`Responder\` with\\n   * \`PanResponder\` in each of the typical \`onResponder*\` callbacks. For\\n   * example, the \`config\` object would look like:\\n   *\\n   *  - \`onMoveShouldSetPanResponder: (e, gestureState) => \{...}\`\\n   *  - \`onMoveShouldSetPanResponderCapture: (e, gestureState) => \{...}\`\\n   *  - \`onStartShouldSetPanResponder: (e, gestureState) => \{...}\`\\n   *  - \`onStartShouldSetPanResponderCapture: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderReject: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderGrant: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderStart: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderEnd: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderRelease: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderMove: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderTerminate: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderTerminationRequest: (e, gestureState) => \{...}\`\\n   *  - \`onShouldBlockNativeResponder: (e, gestureState) => \{...}\`\\n   *\\n   *  In general, for events that have capture equivalents, we update the\\n   *  gestureState once in the capture phase and can use it in the bubble phase\\n   *  as well.\\n   *\\n   *  Be careful with onStartShould* callbacks. They only reflect updated\\n   *  \`gestureState\` for start/end events that bubble/capture to the Node.\\n   *  Once the node is the responder, you can rely on every start/end event\\n   *  being processed by the gesture and \`gestureState\` being updated\\n   *  accordingly. (numberActiveTouches) may not be totally accurate unless you\\n   *  are the responder.\\n   */\\n",
      "modifiers": [
        "static"
      ],
      "params": [
        \{
          "typehint": "\{\\"type\\":\\"simple\\",\\"value\\":\\"object\\",\\"length\\":1}",
          "name": "config"
        }
      ],
      "tparams": null,
      "returntypehint": null,
      "name": "create"
    }
  ],
  "properties": [],
  "classes": [],
  "superClass": null,
  "type": "api",
  "line": 122,
  "name": "PanResponder",
  "docblock": "/**\\n * \`PanResponder\` reconciles several touches into a single gesture. It makes\\n * single-touch gestures resilient to extra touches, and can be used to\\n * recognize simple multi-touch gestures.\\n *\\n * By default, \`PanResponder\` holds an \`InteractionManager\` handle to block\\n * long-running JS events from interrupting active gestures.\\n *\\n * It provides a predictable wrapper of the responder handlers provided by the\\n * [gesture responder system](docs/gesture-responder-system.html).\\n * For each handler, it provides a new \`gestureState\` object alongside the\\n * native event object:\\n *\\n * \`\`\`\\n * onPanResponderMove: (event, gestureState) => \{}\\n * \`\`\`\\n *\\n * A native event is a synthetic touch event with the following form:\\n *\\n *  - \`nativeEvent\`\\n *      + \`changedTouches\` - Array of all touch events that have changed since the last event\\n *      + \`identifier\` - The ID of the touch\\n *      + \`locationX\` - The X position of the touch, relative to the element\\n *      + \`locationY\` - The Y position of the touch, relative to the element\\n *      + \`pageX\` - The X position of the touch, relative to the root element\\n *      + \`pageY\` - The Y position of the touch, relative to the root element\\n *      + \`target\` - The node id of the element receiving the touch event\\n *      + \`timestamp\` - A time identifier for the touch, useful for velocity calculation\\n *      + \`touches\` - Array of all current touches on the screen\\n *\\n * A \`gestureState\` object has the following:\\n *\\n *  - \`stateID\` - ID of the gestureState- persisted as long as there at least\\n *     one touch on screen\\n *  - \`moveX\` - the latest screen coordinates of the recently-moved touch\\n *  - \`moveY\` - the latest screen coordinates of the recently-moved touch\\n *  - \`x0\` - the screen coordinates of the responder grant\\n *  - \`y0\` - the screen coordinates of the responder grant\\n *  - \`dx\` - accumulated distance of the gesture since the touch started\\n *  - \`dy\` - accumulated distance of the gesture since the touch started\\n *  - \`vx\` - current velocity of the gesture\\n *  - \`vy\` - current velocity of the gesture\\n *  - \`numberActiveTouches\` - Number of touches currently on screen\\n *\\n * ### Basic Usage\\n *\\n * \`\`\`\\n *   componentWillMount: function() \{\\n *     this._panResponder = PanResponder.create(\{\\n *       // Ask to be the responder:\\n *       onStartShouldSetPanResponder: (evt, gestureState) => true,\\n *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,\\n *       onMoveShouldSetPanResponder: (evt, gestureState) => true,\\n *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,\\n *\\n *       onPanResponderGrant: (evt, gestureState) => \{\\n *         // The gesture has started. Show visual feedback so the user knows\\n *         // what is happening!\\n *\\n *         // gestureState.d\{x,y} will be set to zero now\\n *       },\\n *       onPanResponderMove: (evt, gestureState) => \{\\n *         // The most recent move distance is gestureState.move\{X,Y}\\n *\\n *         // The accumulated gesture distance since becoming responder is\\n *         // gestureState.d\{x,y}\\n *       },\\n *       onPanResponderTerminationRequest: (evt, gestureState) => true,\\n *       onPanResponderRelease: (evt, gestureState) => \{\\n *         // The user has released all touches while this view is the\\n *         // responder. This typically means a gesture has succeeded\\n *       },\\n *       onPanResponderTerminate: (evt, gestureState) => \{\\n *         // Another component has become the responder, so this gesture\\n *         // should be cancelled\\n *       },\\n *       onShouldBlockNativeResponder: (evt, gestureState) => \{\\n *         // Returns whether this component should block native components from becoming the JS\\n *         // responder. Returns true by default. Is currently only supported on android.\\n *         return true;\\n *       },\\n *     });\\n *   },\\n *\\n *   render: function() \{\\n *     return (\\n *       <View \{...this._panResponder.panHandlers} />\\n *     );\\n *   },\\n *\\n * \`\`\`\\n *\\n * ### Working Example\\n *\\n * To see it in action, try the\\n * [PanResponder example in RNTester](https://github.com/facebook/react-native/blob/master/RNTester/js/PanResponderExample.js)\\n */\\n",
  "requires": [
    \{
      "name": "./InteractionManager"
    },
    \{
      "name": "TouchHistoryMath"
    }
  ],
  "filepath": "Libraries/Interaction/PanResponder.js",
  "componentName": "PanResponder",
  "componentPlatform": "cross"
}`;
var Page = React.createClass({
  statics: { content: content },
  render: function() {
    return (
      <Layout metadata={{"id":"panresponder","title":"PanResponder","layout":"autodocs","category":"APIs","permalink":"docs/panresponder.html","platform":"cross","next":"panresponder","previous":"linking","sidebar":true,"path":"Libraries/Interaction/PanResponder.js","filename":null}}>
        {content}
      </Layout>
    );
  }
});
module.exports = Page;